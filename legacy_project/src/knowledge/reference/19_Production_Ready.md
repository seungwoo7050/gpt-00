# 15. í”„ë¡œë•ì…˜ ì¤€ë¹„ ğŸš€
## ì‹¤ì œ ì„œë¹„ìŠ¤ ë°°í¬ë¥¼ ìœ„í•œ ì™„ë²½ ê°€ì´ë“œ

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ë‚œì´ë„**: ê³ ê¸‰ (Advanced)
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 15-20ì‹œê°„
- **í•„ìš” ì„ ìˆ˜ ì§€ì‹**: 
  - C/C++ ì¤‘ê¸‰ ì´ìƒ
  - ë©€í‹°ìŠ¤ë ˆë”© ê°œë…
  - ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°
  - íŒŒì¼ ì‹œìŠ¤í…œ ì´í•´
- **ì‹¤ìŠµ í™˜ê²½**: Linux/Unix í”„ë¡œë•ì…˜ í™˜ê²½

---

## ğŸ¯ ì´ ë¬¸ì„œì—ì„œ ë°°ìš¸ ë‚´ìš©

**"í…ŒìŠ¤íŠ¸ëŠ” ì˜ë˜ëŠ”ë°, ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” ì™œ ë¬¸ì œê°€ ìƒê¸¸ê¹Œìš”?"** ğŸ¤”

ì •ë§ ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”! ê°œë°œ í™˜ê²½ì€ ë§ˆì¹˜ **ì¡°ìš©í•œ ì—°ìŠµì‹¤**ì´ê³ , í”„ë¡œë•ì…˜ì€ **ì‹¤ì œ ì½˜ì„œíŠ¸ ë¬´ëŒ€**ì˜ˆìš”. ê´€ê°(ì‚¬ìš©ì)ë“¤ì´ ëª°ë ¤ì˜¤ë©´ ì˜ˆìƒì¹˜ ëª»í•œ ë¬¸ì œë“¤ì´ í„°ì ¸ë‚˜ì˜¤ì£ !

ê·¸ë˜ì„œ **ë¬´ëŒ€ ì¤€ë¹„**ë¥¼ ì² ì €íˆ í•´ì•¼ í•´ìš” - ë°±ì—… ì¥ë¹„, ë³´ì•ˆ ì‹œìŠ¤í…œ, ëª¨ë‹ˆí„°ë§ê¹Œì§€! ğŸ­

ì´ ë¬¸ì„œëŠ” LogCasterë¥¼ ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ìš´ì˜í•˜ê¸° ìœ„í•œ í•µì‹¬ ê¸°ìˆ ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤. ë¡œê·¸ ë¡œí…Œì´ì…˜, ê³ ê°€ìš©ì„± ì„¤ê³„, ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§, ì¥ì•  ë³µêµ¬ ë“± ì‹¤ë¬´ì—ì„œ ë°˜ë“œì‹œ í•„ìš”í•œ ë‚´ìš©ë“¤ì„ ì‹¬ë„ ìˆê²Œ ì„¤ëª…í•©ë‹ˆë‹¤.

---

## 1. ë¡œê·¸ ë¡œí…Œì´ì…˜ê³¼ ì•„ì¹´ì´ë¹™

**"ë¡œê·¸ íŒŒì¼ì´ ê³„ì† ì»¤ì ¸ì„œ í•˜ë“œë””ìŠ¤í¬ê°€ ê½‰ ì°°ê¹Œë´ ê±±ì •ë¼ìš”!"** ğŸ’¾

ì™„ì „íˆ ì´í•´í•´ìš”! ë¡œê·¸ëŠ” ë§ˆì¹˜ **ì¼ê¸°ì¥**ì²˜ëŸ¼ ê³„ì† ìŒ“ì´ë‹¤ ë³´ë©´ ì±…ì¥ì´ ê½‰ ì°° ìˆ˜ ìˆì–´ìš”. ê·¸ë˜ì„œ **ë˜‘ë˜‘í•œ ì •ë¦¬ ì‹œìŠ¤í…œ**ì´ í•„ìš”í•˜ì£ !

í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ë¡œê·¸ íŒŒì¼ì´ ë¬´ì œí•œ ì¦ê°€í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³ , ì €ì¥ ê³µê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.

### ì‹œê°„ ê¸°ë°˜ ë¡œê·¸ ë¡œí…Œì´ì…˜ - ìë™ íŒŒì¼ ì •ë¦¬ ì‹œìŠ¤í…œ ğŸ“…

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <chrono>
#include <filesystem>
#include <thread>
#include <mutex>
#include <iomanip>
#include <sstream>

class TimeBasedLogRotator {
private:
    std::string base_filename_;
    std::string log_directory_;
    std::chrono::hours rotation_interval_;
    std::ofstream current_file_;
    std::chrono::system_clock::time_point next_rotation_;
    std::mutex file_mutex_;
    
    // ì••ì¶• ê´€ë ¨
    bool enable_compression_;
    int max_archive_files_;
    
public:
    TimeBasedLogRotator(const std::string& base_filename, 
                       const std::string& directory = "./logs",
                       std::chrono::hours interval = std::chrono::hours(24),
                       bool compress = true,
                       int max_archives = 30)
        : base_filename_(base_filename)
        , log_directory_(directory)
        , rotation_interval_(interval)
        , enable_compression_(compress)
        , max_archive_files_(max_archives) {
        
        // ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        std::filesystem::create_directories(log_directory_);
        
        // ì²« ë²ˆì§¸ ë¡œê·¸ íŒŒì¼ ì—´ê¸°
        rotateLogFile();
    }
    
    ~TimeBasedLogRotator() {
        std::lock_guard<std::mutex> lock(file_mutex_);
        if (current_file_.is_open()) {
            current_file_.close();
        }
    }
    
    void writeLog(const std::string& message) {
        std::lock_guard<std::mutex> lock(file_mutex_);
        
        // ë¡œí…Œì´ì…˜ ì‹œê°„ í™•ì¸
        if (std::chrono::system_clock::now() >= next_rotation_) {
            rotateLogFile();
        }
        
        if (current_file_.is_open()) {
            current_file_ << getCurrentTimestamp() << " " << message << std::endl;
            current_file_.flush();
        }
    }
    
private:
    void rotateLogFile() {
        // í˜„ì¬ íŒŒì¼ ë‹«ê¸°
        if (current_file_.is_open()) {
            current_file_.close();
            
            // ì´ì „ íŒŒì¼ ì••ì¶• (ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ)
            if (enable_compression_) {
                std::thread compression_thread(&TimeBasedLogRotator::compressOldFile, 
                                             this, getCurrentLogPath());
                compression_thread.detach();
            }
        }
        
        // ìƒˆ íŒŒì¼ ì—´ê¸°
        std::string new_filename = generateLogFilename();
        current_file_.open(new_filename, std::ios::app);
        
        if (!current_file_.is_open()) {
            throw std::runtime_error("Cannot open log file: " + new_filename);
        }
        
        // ë‹¤ìŒ ë¡œí…Œì´ì…˜ ì‹œê°„ ì„¤ì •
        next_rotation_ = std::chrono::system_clock::now() + rotation_interval_;
        
        std::cout << "Log rotated to: " << new_filename << std::endl;
        
        // ì˜¤ë˜ëœ ì•„ì¹´ì´ë¸Œ íŒŒì¼ ì •ë¦¬
        cleanupOldArchives();
    }
    
    std::string generateLogFilename() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        std::stringstream ss;
        ss << log_directory_ << "/" << base_filename_ << "_"
           << std::put_time(std::localtime(&time_t), "%Y%m%d_%H%M%S")
           << ".log";
        
        return ss.str();
    }
    
    std::string getCurrentLogPath() {
        // í˜„ì¬ ì—´ë¦° íŒŒì¼ì˜ ê²½ë¡œë¥¼ ë°˜í™˜í•˜ëŠ” ë¡œì§
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íŒŒì¼ ê²½ë¡œë¥¼ ë©¤ë²„ ë³€ìˆ˜ë¡œ ì €ì¥í•´ì•¼ í•¨
        return ""; // ê°„ì†Œí™”ëœ ì˜ˆì œ
    }
    
    void compressOldFile(const std::string& filepath) {
        if (filepath.empty()) return;
        
        // gzip ì••ì¶• (ì‹œìŠ¤í…œ ëª…ë ¹ì–´ ì‚¬ìš©)
        std::string command = "gzip " + filepath;
        int result = std::system(command.c_str());
        
        if (result == 0) {
            std::cout << "Compressed: " << filepath << std::endl;
        } else {
            std::cerr << "Failed to compress: " << filepath << std::endl;
        }
    }
    
    void cleanupOldArchives() {
        try {
            std::vector<std::filesystem::path> archive_files;
            
            // ì•„ì¹´ì´ë¸Œ íŒŒì¼ë“¤ ìˆ˜ì§‘
            for (const auto& entry : std::filesystem::directory_iterator(log_directory_)) {
                if (entry.is_regular_file()) {
                    std::string filename = entry.path().filename().string();
                    if (filename.find(base_filename_) == 0 && 
                        (filename.ends_with(".log.gz") || filename.ends_with(".log"))) {
                        archive_files.push_back(entry.path());
                    }
                }
            }
            
            // íŒŒì¼ì„ ìˆ˜ì • ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ì˜¤ë˜ëœ ê²ƒë¶€í„°)
            std::sort(archive_files.begin(), archive_files.end(),
                     [](const std::filesystem::path& a, const std::filesystem::path& b) {
                         return std::filesystem::last_write_time(a) < 
                                std::filesystem::last_write_time(b);
                     });
            
            // ìµœëŒ€ ê°œìˆ˜ë¥¼ ì´ˆê³¼í•˜ëŠ” íŒŒì¼ë“¤ ì‚­ì œ
            while (archive_files.size() > static_cast<size_t>(max_archive_files_)) {
                std::filesystem::remove(archive_files.front());
                std::cout << "Deleted old archive: " << archive_files.front() << std::endl;
                archive_files.erase(archive_files.begin());
            }
            
        } catch (const std::exception& e) {
            std::cerr << "Error during archive cleanup: " << e.what() << std::endl;
        }
    }
    
    std::string getCurrentTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            now.time_since_epoch()) % 1000;
        
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        ss << "." << std::setfill('0') << std::setw(3) << ms.count();
        
        return ss.str();
    }
};
```

### í¬ê¸° ê¸°ë°˜ ë¡œê·¸ ë¡œí…Œì´ì…˜

```cpp
class SizeBasedLogRotator {
private:
    std::string base_filename_;
    std::string log_directory_;
    size_t max_file_size_;
    int max_backup_files_;
    
    std::ofstream current_file_;
    std::string current_filepath_;
    size_t current_file_size_;
    std::mutex file_mutex_;

public:
    SizeBasedLogRotator(const std::string& base_filename,
                       const std::string& directory = "./logs",
                       size_t max_size_mb = 100,
                       int max_backups = 10)
        : base_filename_(base_filename)
        , log_directory_(directory)
        , max_file_size_(max_size_mb * 1024 * 1024)  // MB to bytes
        , max_backup_files_(max_backups)
        , current_file_size_(0) {
        
        std::filesystem::create_directories(log_directory_);
        openNewLogFile();
    }
    
    ~SizeBasedLogRotator() {
        std::lock_guard<std::mutex> lock(file_mutex_);
        if (current_file_.is_open()) {
            current_file_.close();
        }
    }
    
    void writeLog(const std::string& message) {
        std::lock_guard<std::mutex> lock(file_mutex_);
        
        std::string log_entry = getCurrentTimestamp() + " " + message + "\n";
        
        // íŒŒì¼ í¬ê¸° í™•ì¸ í›„ ë¡œí…Œì´ì…˜
        if (current_file_size_ + log_entry.length() > max_file_size_) {
            rotateLogFiles();
        }
        
        if (current_file_.is_open()) {
            current_file_ << log_entry;
            current_file_.flush();
            current_file_size_ += log_entry.length();
        }
    }

private:
    void openNewLogFile() {
        current_filepath_ = log_directory_ + "/" + base_filename_ + ".log";
        current_file_.open(current_filepath_, std::ios::app);
        
        if (!current_file_.is_open()) {
            throw std::runtime_error("Cannot open log file: " + current_filepath_);
        }
        
        // í˜„ì¬ íŒŒì¼ í¬ê¸° í™•ì¸
        if (std::filesystem::exists(current_filepath_)) {
            current_file_size_ = std::filesystem::file_size(current_filepath_);
        } else {
            current_file_size_ = 0;
        }
    }
    
    void rotateLogFiles() {
        current_file_.close();
        
        // ë°±ì—… íŒŒì¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì´ë™
        // logfile.log.3 -> logfile.log.4
        // logfile.log.2 -> logfile.log.3
        // logfile.log.1 -> logfile.log.2
        // logfile.log -> logfile.log.1
        
        for (int i = max_backup_files_ - 1; i >= 1; i--) {
            std::string old_name = current_filepath_ + "." + std::to_string(i);
            std::string new_name = current_filepath_ + "." + std::to_string(i + 1);
            
            if (std::filesystem::exists(old_name)) {
                if (i == max_backup_files_ - 1) {
                    // ê°€ì¥ ì˜¤ë˜ëœ íŒŒì¼ ì‚­ì œ
                    std::filesystem::remove(new_name);
                }
                std::filesystem::rename(old_name, new_name);
            }
        }
        
        // í˜„ì¬ íŒŒì¼ì„ .1ë¡œ ì´ë™
        std::string backup_name = current_filepath_ + ".1";
        std::filesystem::rename(current_filepath_, backup_name);
        
        // ìƒˆ ë¡œê·¸ íŒŒì¼ ìƒì„±
        current_file_size_ = 0;
        openNewLogFile();
        
        std::cout << "Log rotated. New file: " << current_filepath_ << std::endl;
    }
    
    std::string getCurrentTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        
        return ss.str();
    }
};
```

---

## 2. êµ¬ì¡°í™”ëœ ë¡œê·¸ì™€ JSON í¬ë§·

í˜„ëŒ€ì ì¸ ë¡œê·¸ ì‹œìŠ¤í…œì€ êµ¬ì¡°í™”ëœ ë°ì´í„° í˜•íƒœë¡œ ë¡œê·¸ë¥¼ ì €ì¥í•˜ì—¬ ê²€ìƒ‰ê³¼ ë¶„ì„ì„ ìš©ì´í•˜ê²Œ í•©ë‹ˆë‹¤.

### JSON ë¡œê·¸ í¬ë§·í„°

```cpp
#include <nlohmann/json.hpp>  // JSON ë¼ì´ë¸ŒëŸ¬ë¦¬
#include <iostream>
#include <string>
#include <chrono>
#include <unordered_map>

using json = nlohmann::json;

enum class LogLevel {
    TRACE = 0,
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4,
    FATAL = 5
};

class StructuredLogger {
private:
    std::string service_name_;
    std::string version_;
    std::string environment_;
    std::unordered_map<LogLevel, std::string> level_names_;

public:
    StructuredLogger(const std::string& service_name,
                    const std::string& version = "1.0.0",
                    const std::string& environment = "production")
        : service_name_(service_name)
        , version_(version)
        , environment_(environment) {
        
        level_names_[LogLevel::TRACE] = "TRACE";
        level_names_[LogLevel::DEBUG] = "DEBUG";
        level_names_[LogLevel::INFO] = "INFO";
        level_names_[LogLevel::WARN] = "WARN";
        level_names_[LogLevel::ERROR] = "ERROR";
        level_names_[LogLevel::FATAL] = "FATAL";
    }
    
    // ê¸°ë³¸ ë¡œê·¸ ë©”ì‹œì§€
    void log(LogLevel level, const std::string& message, 
             const json& context = json::object()) {
        
        json log_entry = createBaseLogEntry(level, message);
        
        // ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì¶”ê°€
        if (!context.empty()) {
            log_entry["context"] = context;
        }
        
        outputLog(log_entry);
    }
    
    // HTTP ìš”ì²­ ë¡œê·¸
    void logHttpRequest(const std::string& method, const std::string& url,
                       int status_code, long response_time_ms,
                       const std::string& user_id = "",
                       const std::string& request_id = "") {
        
        json log_entry = createBaseLogEntry(LogLevel::INFO, "HTTP Request");
        
        log_entry["http"] = {
            {"method", method},
            {"url", url},
            {"status_code", status_code},
            {"response_time_ms", response_time_ms}
        };
        
        if (!user_id.empty()) {
            log_entry["user_id"] = user_id;
        }
        
        if (!request_id.empty()) {
            log_entry["request_id"] = request_id;
        }
        
        outputLog(log_entry);
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ë¡œê·¸
    void logDatabaseQuery(const std::string& query_type, 
                         const std::string& table,
                         long execution_time_ms,
                         bool success = true,
                         const std::string& error = "") {
        
        LogLevel level = success ? LogLevel::DEBUG : LogLevel::ERROR;
        std::string message = success ? "Database Query" : "Database Query Failed";
        
        json log_entry = createBaseLogEntry(level, message);
        
        log_entry["database"] = {
            {"query_type", query_type},
            {"table", table},
            {"execution_time_ms", execution_time_ms},
            {"success", success}
        };
        
        if (!error.empty()) {
            log_entry["error"] = error;
        }
        
        outputLog(log_entry);
    }
    
    // ì—ëŸ¬ ë¡œê·¸ (ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ í¬í•¨)
    void logError(const std::string& error_message,
                  const std::string& error_code = "",
                  const json& error_details = json::object()) {
        
        json log_entry = createBaseLogEntry(LogLevel::ERROR, error_message);
        
        json error_info = {
            {"message", error_message}
        };
        
        if (!error_code.empty()) {
            error_info["code"] = error_code;
        }
        
        if (!error_details.empty()) {
            error_info["details"] = error_details;
        }
        
        // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ì¶”ê°€ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ë°©ë²• í•„ìš”)
        error_info["stack_trace"] = getCurrentStackTrace();
        
        log_entry["error"] = error_info;
        
        outputLog(log_entry);
    }
    
    // ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¡œê·¸
    void logMetric(const std::string& metric_name, double value,
                   const std::string& unit = "",
                   const json& tags = json::object()) {
        
        json log_entry = createBaseLogEntry(LogLevel::INFO, "Metric");
        
        log_entry["metric"] = {
            {"name", metric_name},
            {"value", value}
        };
        
        if (!unit.empty()) {
            log_entry["metric"]["unit"] = unit;
        }
        
        if (!tags.empty()) {
            log_entry["metric"]["tags"] = tags;
        }
        
        outputLog(log_entry);
    }

private:
    json createBaseLogEntry(LogLevel level, const std::string& message) {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            now.time_since_epoch()) % 1000;
        
        // ISO 8601 í¬ë§· íƒ€ì„ìŠ¤íƒ¬í”„
        std::stringstream timestamp_ss;
        timestamp_ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
        timestamp_ss << "." << std::setfill('0') << std::setw(3) << ms.count() << "Z";
        
        json log_entry = {
            {"timestamp", timestamp_ss.str()},
            {"level", level_names_[level]},
            {"message", message},
            {"service", {
                {"name", service_name_},
                {"version", version_},
                {"environment", environment_}
            }},
            {"host", {
                {"hostname", getHostname()},
                {"pid", getCurrentPid()}
            }}
        };
        
        return log_entry;
    }
    
    void outputLog(const json& log_entry) {
        // JSONì„ í•œ ì¤„ë¡œ ì¶œë ¥ (ê°œí–‰ ì—†ì´)
        std::cout << log_entry.dump() << std::endl;
    }
    
    std::string getHostname() {
        char hostname[256];
        if (gethostname(hostname, sizeof(hostname)) == 0) {
            return std::string(hostname);
        }
        return "unknown";
    }
    
    int getCurrentPid() {
        #ifdef _WIN32
            return GetCurrentProcessId();
        #else
            return getpid();
        #endif
    }
    
    std::string getCurrentStackTrace() {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” backtrace() í•¨ìˆ˜ ë“±ì„ ì‚¬ìš©
        // ì—¬ê¸°ì„œëŠ” ê°„ì†Œí™”ëœ ì˜ˆì œ
        return "Stack trace not implemented in this example";
    }
};

// ì‚¬ìš© ì˜ˆì œ
int main() {
    StructuredLogger logger("logcaster-service", "2.1.0", "production");
    
    // ê¸°ë³¸ ë¡œê·¸
    logger.log(LogLevel::INFO, "Service started successfully");
    
    // HTTP ìš”ì²­ ë¡œê·¸
    logger.logHttpRequest("POST", "/api/logs", 201, 45, "user123", "req-456");
    
    // ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ë¡œê·¸
    logger.logDatabaseQuery("INSERT", "logs", 12, true);
    
    // ì—ëŸ¬ ë¡œê·¸
    json error_details = {
        {"connection_string", "postgresql://..."},
        {"retry_count", 3}
    };
    logger.logError("Database connection failed", "DB_CONN_001", error_details);
    
    // ë©”íŠ¸ë¦­ ë¡œê·¸
    json metric_tags = {
        {"endpoint", "/api/logs"},
        {"method", "POST"}
    };
    logger.logMetric("response_time", 0.045, "seconds", metric_tags);
    
    return 0;
}
```

---

## 3. ê³ ê°€ìš©ì„± (High Availability) ì„¤ê³„

### ë¡œê·¸ ë³µì œì™€ ë°±ì—…

```cpp
#include <vector>
#include <memory>
#include <future>
#include <atomic>

// ë¡œê·¸ ì‹±í¬ ì¸í„°í˜ì´ìŠ¤
class LogSink {
public:
    virtual ~LogSink() = default;
    virtual bool writeLog(const std::string& log_entry) = 0;
    virtual bool isHealthy() = 0;
    virtual std::string getName() const = 0;
};

// íŒŒì¼ ì‹±í¬
class FileSink : public LogSink {
private:
    std::string filepath_;
    std::ofstream file_;
    std::mutex file_mutex_;

public:
    FileSink(const std::string& filepath) : filepath_(filepath) {
        file_.open(filepath_, std::ios::app);
    }
    
    bool writeLog(const std::string& log_entry) override {
        std::lock_guard<std::mutex> lock(file_mutex_);
        if (file_.is_open()) {
            file_ << log_entry << std::endl;
            file_.flush();
            return true;
        }
        return false;
    }
    
    bool isHealthy() override {
        std::lock_guard<std::mutex> lock(file_mutex_);
        return file_.is_open() && file_.good();
    }
    
    std::string getName() const override {
        return "FileSink:" + filepath_;
    }
};

// ë„¤íŠ¸ì›Œí¬ ì‹±í¬ (ê°„ì†Œí™”ëœ ì˜ˆì œ)
class NetworkSink : public LogSink {
private:
    std::string endpoint_;
    std::atomic<bool> connected_{false};

public:
    NetworkSink(const std::string& endpoint) : endpoint_(endpoint) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì´ˆê¸°í™”
        connected_ = true; // ì˜ˆì œì—ì„œëŠ” í•­ìƒ ì—°ê²°ëœ ê²ƒìœ¼ë¡œ ê°€ì •
    }
    
    bool writeLog(const std::string& log_entry) override {
        if (!connected_) return false;
        
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” HTTP POST, TCP ì†Œì¼“ ë“±ì„ ì‚¬ìš©í•˜ì—¬ ì „ì†¡
        // ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
        std::cout << "Sending to " << endpoint_ << ": " << log_entry << std::endl;
        return true;
    }
    
    bool isHealthy() override {
        return connected_;
    }
    
    std::string getName() const override {
        return "NetworkSink:" + endpoint_;
    }
};

// ê³ ê°€ìš©ì„± ë¡œê±°
class HighAvailabilityLogger {
private:
    std::vector<std::unique_ptr<LogSink>> primary_sinks_;
    std::vector<std::unique_ptr<LogSink>> backup_sinks_;
    
    // ì„¤ì •
    int min_successful_writes_;
    std::chrono::milliseconds write_timeout_;
    
    // í†µê³„
    std::atomic<int> total_writes_{0};
    std::atomic<int> successful_writes_{0};
    std::atomic<int> failed_writes_{0};

public:
    HighAvailabilityLogger(int min_success = 1, 
                          std::chrono::milliseconds timeout = std::chrono::milliseconds(1000))
        : min_successful_writes_(min_success)
        , write_timeout_(timeout) {}
    
    void addPrimarySink(std::unique_ptr<LogSink> sink) {
        primary_sinks_.push_back(std::move(sink));
    }
    
    void addBackupSink(std::unique_ptr<LogSink> sink) {
        backup_sinks_.push_back(std::move(sink));
    }
    
    bool writeLog(const std::string& log_entry) {
        total_writes_++;
        
        // ë¨¼ì € ì£¼ ì‹±í¬ë“¤ì— ì‹œë„
        int successful_count = writeToSinks(primary_sinks_, log_entry);
        
        // ì£¼ ì‹±í¬ì—ì„œ ì¶©ë¶„í•œ ì„±ê³µì„ ì–»ì§€ ëª»í–ˆë‹¤ë©´ ë°±ì—… ì‹±í¬ ì‚¬ìš©
        if (successful_count < min_successful_writes_) {
            successful_count += writeToSinks(backup_sinks_, log_entry);
        }
        
        if (successful_count >= min_successful_writes_) {
            successful_writes_++;
            return true;
        } else {
            failed_writes_++;
            return false;
        }
    }
    
    // í—¬ìŠ¤ ì²´í¬
    void performHealthCheck() {
        std::cout << "\n=== Health Check ===" << std::endl;
        
        std::cout << "Primary Sinks:" << std::endl;
        checkSinkHealth(primary_sinks_);
        
        std::cout << "Backup Sinks:" << std::endl;
        checkSinkHealth(backup_sinks_);
        
        std::cout << "Statistics:" << std::endl;
        std::cout << "  Total writes: " << total_writes_ << std::endl;
        std::cout << "  Successful: " << successful_writes_ << std::endl;
        std::cout << "  Failed: " << failed_writes_ << std::endl;
        
        if (total_writes_ > 0) {
            double success_rate = (double)successful_writes_ / total_writes_ * 100;
            std::cout << "  Success rate: " << std::fixed << std::setprecision(2) 
                      << success_rate << "%" << std::endl;
        }
    }

private:
    int writeToSinks(const std::vector<std::unique_ptr<LogSink>>& sinks, 
                     const std::string& log_entry) {
        
        std::vector<std::future<bool>> futures;
        
        // ëª¨ë“  ì‹±í¬ì— ë³‘ë ¬ë¡œ ì“°ê¸° ì‹œë„
        for (const auto& sink : sinks) {
            if (sink->isHealthy()) {
                futures.push_back(
                    std::async(std::launch::async, [&sink, &log_entry]() {
                        return sink->writeLog(log_entry);
                    })
                );
            }
        }
        
        // ê²°ê³¼ ìˆ˜ì§‘ (íƒ€ì„ì•„ì›ƒ ì ìš©)
        int successful_count = 0;
        for (auto& future : futures) {
            try {
                if (future.wait_for(write_timeout_) == std::future_status::ready) {
                    if (future.get()) {
                        successful_count++;
                    }
                } else {
                    // íƒ€ì„ì•„ì›ƒ ë°œìƒ
                    std::cerr << "Write timeout occurred" << std::endl;
                }
            } catch (const std::exception& e) {
                std::cerr << "Write exception: " << e.what() << std::endl;
            }
        }
        
        return successful_count;
    }
    
    void checkSinkHealth(const std::vector<std::unique_ptr<LogSink>>& sinks) {
        for (const auto& sink : sinks) {
            bool healthy = sink->isHealthy();
            std::cout << "  " << sink->getName() << ": " 
                      << (healthy ? "HEALTHY" : "UNHEALTHY") << std::endl;
        }
    }
};

// ì‚¬ìš© ì˜ˆì œ
int main() {
    HighAvailabilityLogger ha_logger(1, std::chrono::milliseconds(500));
    
    // ì£¼ ì‹±í¬ë“¤ ì¶”ê°€
    ha_logger.addPrimarySink(std::make_unique<FileSink>("primary_log.txt"));
    ha_logger.addPrimarySink(std::make_unique<NetworkSink>("http://log-server-1:8080"));
    
    // ë°±ì—… ì‹±í¬ë“¤ ì¶”ê°€
    ha_logger.addBackupSink(std::make_unique<FileSink>("backup_log.txt"));
    ha_logger.addBackupSink(std::make_unique<NetworkSink>("http://log-server-backup:8080"));
    
    // ë¡œê·¸ ì‘ì„± í…ŒìŠ¤íŠ¸
    for (int i = 0; i < 10; i++) {
        std::string log_message = "Test log message " + std::to_string(i);
        bool success = ha_logger.writeLog(log_message);
        
        if (!success) {
            std::cerr << "Failed to write log: " << log_message << std::endl;
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // í—¬ìŠ¤ ì²´í¬ ìˆ˜í–‰
    ha_logger.performHealthCheck();
    
    return 0;
}
```

---

## 4. ë°±í”„ë ˆì…”ì™€ í”Œë¡œìš° ì œì–´

ê³ ë¶€í•˜ ìƒí™©ì—ì„œ ë¡œê·¸ ì‹œìŠ¤í…œì´ ì••ë„ë˜ì§€ ì•Šë„ë¡ ë°±í”„ë ˆì…”ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

### ì ì‘í˜• ë°±í”„ë ˆì…” ì‹œìŠ¤í…œ

```cpp
#include <queue>
#include <atomic>
#include <chrono>
#include <thread>
#include <condition_variable>

enum class BackpressureStrategy {
    DROP_OLDEST,    // ê°€ì¥ ì˜¤ë˜ëœ ë¡œê·¸ ë“œë¡­
    DROP_NEWEST,    // ìƒˆë¡œìš´ ë¡œê·¸ ë“œë¡­
    BLOCK_PRODUCER, // ìƒì‚°ì ë¸”ë¡
    SAMPLE_LOGS     // ë¡œê·¸ ìƒ˜í”Œë§
};

class BackpressureController {
private:
    // í ê´€ë ¨
    std::queue<std::string> log_queue_;
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    
    // ë°±í”„ë ˆì…” ì„¤ì •
    size_t max_queue_size_;
    size_t warning_threshold_;
    BackpressureStrategy strategy_;
    
    // ìƒ˜í”Œë§ ê´€ë ¨
    std::atomic<int> sampling_rate_{1}; // 1 = ëª¨ë“  ë¡œê·¸, 2 = 50%, 10 = 10%
    std::atomic<int> log_counter_{0};
    
    // í†µê³„
    std::atomic<int> total_received_{0};
    std::atomic<int> total_dropped_{0};
    std::atomic<int> total_processed_{0};
    
    // ë™ì  ì¡°ì •
    std::chrono::steady_clock::time_point last_adjustment_;
    double current_load_{0.0};

public:
    BackpressureController(size_t max_queue_size = 10000,
                          BackpressureStrategy strategy = BackpressureStrategy::DROP_OLDEST)
        : max_queue_size_(max_queue_size)
        , warning_threshold_(max_queue_size * 0.8)
        , strategy_(strategy)
        , last_adjustment_(std::chrono::steady_clock::now()) {}
    
    bool enqueue(const std::string& log_entry) {
        total_received_++;
        
        // ìƒ˜í”Œë§ ì²´í¬
        if (strategy_ == BackpressureStrategy::SAMPLE_LOGS) {
            int current_count = log_counter_++;
            if (current_count % sampling_rate_ != 0) {
                total_dropped_++;
                return false; // ìƒ˜í”Œë§ìœ¼ë¡œ ë“œë¡­
            }
        }
        
        std::unique_lock<std::mutex> lock(queue_mutex_);
        
        // í í¬ê¸° ì²´í¬
        if (log_queue_.size() >= max_queue_size_) {
            switch (strategy_) {
                case BackpressureStrategy::DROP_OLDEST:
                    if (!log_queue_.empty()) {
                        log_queue_.pop();
                        total_dropped_++;
                    }
                    log_queue_.push(log_entry);
                    break;
                    
                case BackpressureStrategy::DROP_NEWEST:
                    total_dropped_++;
                    return false;
                    
                case BackpressureStrategy::BLOCK_PRODUCER:
                    // íì— ê³µê°„ì´ ìƒê¸¸ ë•Œê¹Œì§€ ëŒ€ê¸°
                    queue_cv_.wait(lock, [this] { 
                        return log_queue_.size() < max_queue_size_; 
                    });
                    log_queue_.push(log_entry);
                    break;
                    
                case BackpressureStrategy::SAMPLE_LOGS:
                    // ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨
                    break;
            }
        } else {
            log_queue_.push(log_entry);
        }
        
        // ë¡œë“œ ëª¨ë‹ˆí„°ë§ ë° ë™ì  ì¡°ì •
        updateLoadMetrics();
        
        queue_cv_.notify_one();
        return true;
    }
    
    bool dequeue(std::string& log_entry, 
                std::chrono::milliseconds timeout = std::chrono::milliseconds(1000)) {
        
        std::unique_lock<std::mutex> lock(queue_mutex_);
        
        if (queue_cv_.wait_for(lock, timeout, [this] { return !log_queue_.empty(); })) {
            log_entry = log_queue_.front();
            log_queue_.pop();
            total_processed_++;
            
            // íì— ê³µê°„ì´ ìƒê²¼ìŒì„ ì•Œë¦¼
            queue_cv_.notify_one();
            return true;
        }
        
        return false;
    }
    
    // ì‹¤ì‹œê°„ í†µê³„
    void printStatistics() {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        
        std::cout << "\n=== Backpressure Statistics ===" << std::endl;
        std::cout << "Queue size: " << log_queue_.size() << "/" << max_queue_size_ << std::endl;
        std::cout << "Current load: " << std::fixed << std::setprecision(2) << current_load_ * 100 << "%" << std::endl;
        std::cout << "Sampling rate: 1/" << sampling_rate_ << std::endl;
        std::cout << "Total received: " << total_received_ << std::endl;
        std::cout << "Total dropped: " << total_dropped_ << std::endl;
        std::cout << "Total processed: " << total_processed_ << std::endl;
        
        if (total_received_ > 0) {
            double drop_rate = (double)total_dropped_ / total_received_ * 100;
            std::cout << "Drop rate: " << std::fixed << std::setprecision(2) << drop_rate << "%" << std::endl;
        }
    }
    
    size_t getQueueSize() const {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        return log_queue_.size();
    }

private:
    void updateLoadMetrics() {
        auto now = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::seconds>(now - last_adjustment_);
        
        // 1ì´ˆë§ˆë‹¤ ë¡œë“œ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
        if (duration.count() >= 1) {
            current_load_ = (double)log_queue_.size() / max_queue_size_;
            
            // ë™ì  ìƒ˜í”Œë§ ë ˆì´íŠ¸ ì¡°ì •
            if (strategy_ == BackpressureStrategy::SAMPLE_LOGS) {
                adjustSamplingRate();
            }
            
            last_adjustment_ = now;
        }
    }
    
    void adjustSamplingRate() {
        if (current_load_ > 0.9) {
            // ë†’ì€ ë¡œë“œ: ìƒ˜í”Œë§ ë ˆì´íŠ¸ ì¦ê°€ (ë” ì ì€ ë¡œê·¸ ìˆ˜ìš©)
            sampling_rate_ = std::min(sampling_rate_ * 2, 100);
        } else if (current_load_ < 0.5) {
            // ë‚®ì€ ë¡œë“œ: ìƒ˜í”Œë§ ë ˆì´íŠ¸ ê°ì†Œ (ë” ë§ì€ ë¡œê·¸ ìˆ˜ìš©)
            sampling_rate_ = std::max(sampling_rate_ / 2, 1);
        }
    }
};

// ì‚¬ìš© ì˜ˆì œ
class AdaptiveLogger {
private:
    BackpressureController controller_;
    std::thread processing_thread_;
    std::atomic<bool> running_{true};

public:
    AdaptiveLogger(BackpressureStrategy strategy = BackpressureStrategy::DROP_OLDEST) 
        : controller_(10000, strategy) {
        
        // ë¡œê·¸ ì²˜ë¦¬ ìŠ¤ë ˆë“œ ì‹œì‘
        processing_thread_ = std::thread(&AdaptiveLogger::processLogs, this);
    }
    
    ~AdaptiveLogger() {
        running_ = false;
        if (processing_thread_.joinable()) {
            processing_thread_.join();
        }
    }
    
    void log(const std::string& message) {
        std::string timestamped_message = getCurrentTimestamp() + " " + message;
        
        if (!controller_.enqueue(timestamped_message)) {
            // ë¡œê·¸ê°€ ë“œë¡­ëœ ê²½ìš°ì˜ ì²˜ë¦¬
            // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë©”íŠ¸ë¦­ ìˆ˜ì§‘, ì•Œë¦¼ ë“±ì„ ìˆ˜í–‰
        }
    }
    
    void printStatistics() {
        controller_.printStatistics();
    }

private:
    void processLogs() {
        std::string log_entry;
        
        while (running_) {
            if (controller_.dequeue(log_entry, std::chrono::milliseconds(100))) {
                // ì‹¤ì œ ë¡œê·¸ ì²˜ë¦¬ (íŒŒì¼ ì“°ê¸°, ë„¤íŠ¸ì›Œí¬ ì „ì†¡ ë“±)
                std::cout << log_entry << std::endl;
                
                // ì²˜ë¦¬ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
                std::this_thread::sleep_for(std::chrono::microseconds(100));
            }
        }
    }
    
    std::string getCurrentTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }
};

// ë°±í”„ë ˆì…” í…ŒìŠ¤íŠ¸
int main() {
    AdaptiveLogger logger(BackpressureStrategy::SAMPLE_LOGS);
    
    // ê³ ë¶€í•˜ ì‹œë®¬ë ˆì´ì…˜
    std::vector<std::thread> producer_threads;
    
    for (int i = 0; i < 5; i++) {
        producer_threads.emplace_back([&logger, i]() {
            for (int j = 0; j < 1000; j++) {
                logger.log("High-load log from producer " + std::to_string(i) + 
                          " message " + std::to_string(j));
                
                // ëœë¤í•œ ê°„ê²©ìœ¼ë¡œ ë¡œê·¸ ìƒì„±
                std::this_thread::sleep_for(std::chrono::microseconds(rand() % 1000));
            }
        });
    }
    
    // í†µê³„ ì¶œë ¥ ìŠ¤ë ˆë“œ
    std::thread stats_thread([&logger]() {
        for (int i = 0; i < 10; i++) {
            std::this_thread::sleep_for(std::chrono::seconds(2));
            logger.printStatistics();
        }
    });
    
    // ëª¨ë“  ìƒì‚°ì ìŠ¤ë ˆë“œ ì™„ë£Œ ëŒ€ê¸°
    for (auto& thread : producer_threads) {
        thread.join();
    }
    
    stats_thread.join();
    
    // ìµœì¢… í†µê³„
    std::this_thread::sleep_for(std::chrono::seconds(2));
    logger.printStatistics();
    
    return 0;
}
```

---

## ğŸ”¥ 5. í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë°©ë²•

### 5.1 ë¡œê·¸ ë¡œí…Œì´ì…˜ ì‹¤ìˆ˜

#### [SEQUENCE: 42] ë¡œí…Œì´ì…˜ íƒ€ì´ë° ì˜¤ë¥˜
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ë¡œí…Œì´ì…˜ ì¤‘ ë¡œê·¸ ì†ì‹¤
void rotateLogFile() {
    current_file_.close();  // ë²„í¼ë§ëœ ë°ì´í„° ì†ì‹¤ ê°€ëŠ¥
    rename("app.log", "app.log.old");
    current_file_.open("app.log");
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì•ˆì „í•œ ë¡œí…Œì´ì…˜
void rotateLogFile() {
    current_file_.flush();  // ë²„í¼ í”ŒëŸ¬ì‹œ
    current_file_.close();
    
    // ì›ìì  ì´ë¦„ ë³€ê²½
    std::string new_name = generateTimestampedName();
    rename("app.log", new_name.c_str());
    
    current_file_.open("app.log");
}
```

### 5.2 ê³ ê°€ìš©ì„± ì‹¤ìˆ˜

#### [SEQUENCE: 43] ë‹¨ì¼ ì§€ì  ì¥ì• 
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ë‹¨ì¼ ë¡œê·¸ ì €ì¥ì†Œ
class SimpleLogger {
    void log(const std::string& message) {
        file_ << message << std::endl;  // íŒŒì¼ ì‹œìŠ¤í…œ ì¥ì•  ì‹œ ì „ì²´ ë¡œê·¸ ì†ì‹¤
    }
};

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ë‹¤ì¤‘ ì €ì¥ì†Œ
class ResilientLogger {
    void log(const std::string& message) {
        // ì£¼ ì €ì¥ì†Œ ì‹œë„
        if (!primary_sink_->write(message)) {
            // ë°±ì—… ì €ì¥ì†Œë¡œ í´ë°±
            backup_sink_->write(message);
        }
    }
};
```

### 5.3 ë°±í”„ë ˆì…” ì‹¤ìˆ˜

#### [SEQUENCE: 44] ë¬´ì œí•œ í ì¦ê°€
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: í í¬ê¸° ì œí•œ ì—†ìŒ
void enqueue(const std::string& log) {
    queue_.push(log);  // OOM ê°€ëŠ¥ì„±
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì œí•œëœ í
void enqueue(const std::string& log) {
    if (queue_.size() >= MAX_QUEUE_SIZE) {
        // ë°±í”„ë ˆì…” ì „ëµ ì ìš©
        applyBackpressureStrategy();
    }
    queue_.push(log);
}
```

---

## 6. ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ê¸°ë³¸ ë¡œê·¸ ë¡œí…Œì´í„° (ê¸°ì´ˆ)
**ëª©í‘œ**: ì‹œê°„/í¬ê¸° ê¸°ë°˜ ë¡œê·¸ ë¡œí…Œì´ì…˜ êµ¬í˜„

**êµ¬í˜„ ì‚¬í•­**:
- íŒŒì¼ í¬ê¸° ëª¨ë‹ˆí„°ë§
- ì•ˆì „í•œ íŒŒì¼ ì´ë¦„ ë³€ê²½
- ìë™ ì••ì¶• ë° ì•„ì¹´ì´ë¹™
- ì˜¤ë˜ëœ íŒŒì¼ ìë™ ì‚­ì œ

### í”„ë¡œì íŠ¸ 2: ê³ ê°€ìš©ì„± ë¡œê·¸ ì‹œìŠ¤í…œ (ì¤‘ê¸‰)
**ëª©í‘œ**: ë‹¤ì¤‘ ì €ì¥ì†Œì™€ í´ë°±ì„ ê°–ì¶˜ ë¡œê±°

**êµ¬í˜„ ì‚¬í•­**:
- ë‹¤ì¤‘ ë¡œê·¸ ì‹±í¬ (file, network, database)
- í—¬ìŠ¤ ì²´í¬ ë° ìë™ í´ì˜¤ë²„
- ë¹„ë™ê¸° ë¡œê·¸ ì „ì†¡
- ì‹¤íŒ¨ ë¡œê·¸ ë¦¬íŠ¸ë¼ì´ í

### í”„ë¡œì íŠ¸ 3: í”„ë¡œë•ì…˜ê¸‰ ë¡œê·¸ íŒŒì´í”„ë¼ì¸ (ê³ ê¸‰)
**ëª©í‘œ**: ëŒ€ê·œëª¨ íŠ¸ë˜í”½ì„ ì²˜ë¦¬í•˜ëŠ” ì™„ì „í•œ ë¡œê·¸ ì‹œìŠ¤í…œ

**êµ¬í˜„ ì‚¬í•­**:
- ì ì‘í˜• ë°±í”„ë ˆì…” ì œì–´
- êµ¬ì¡°í™”ëœ JSON ë¡œê·¸ í¬ë§·
- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
- ë¶„ì‚° ë¡œê·¸ ìˆ˜ì§‘ ë° ì§‘ê³„

---

## 7. í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ì´ˆ ë ˆë²¨ âœ…
- [ ] ë¡œê·¸ ë¡œí…Œì´ì…˜ ê°œë… ì´í•´
- [ ] JSON í¬ë§· ë¡œê·¸ ì‘ì„±
- [ ] ê¸°ë³¸ì ì¸ ë¹„ë™ê¸° ë¡œê¹…
- [ ] ì˜ˆì™¸ ì²˜ë¦¬ì™€ ë¡œê¹…

### ì¤‘ê¸‰ ë ˆë²¨ ğŸ“š
- [ ] ë‹¤ì¤‘ ë¡œê·¸ ì‹±í¬ êµ¬í˜„
- [ ] ë°±í”„ë ˆì…” ì „ëµ ì´í•´
- [ ] ë¡œê·¸ í•„í„°ë§ê³¼ ìƒ˜í”Œë§
- [ ] ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

### ê³ ê¸‰ ë ˆë²¨ ğŸš€
- [ ] ê³ ê°€ìš©ì„± ì•„í‚¤í…ì²˜ ì„¤ê³„
- [ ] ì ì‘í˜• ë°±í”„ë ˆì…” êµ¬í˜„
- [ ] ë¶„ì‚° ë¡œê·¸ ì‹œìŠ¤í…œ
- [ ] ë¡œê·¸ ë¶„ì„ íŒŒì´í”„ë¼ì¸

### ì „ë¬¸ê°€ ë ˆë²¨ ğŸ†
- [ ] ëŒ€ê·œëª¨ ë¡œê·¸ ì²˜ë¦¬ ìµœì í™”
- [ ] ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
- [ ] ì»¤ìŠ¤í…€ ë¡œê·¸ í”„ë¡œí† ì½œ
- [ ] í´ë¼ìš°ë“œ ë„¤ì´í‹°ë¸Œ ë¡œê¹…

---

## 8. ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì¶”ì²œ ë„ì„œ
- "Site Reliability Engineering" - Google
- "Distributed Systems Observability" - Cindy Sridharan
- "The Art of Monitoring" - James Turnbull

### ì˜¨ë¼ì¸ ë¦¬ì†ŒìŠ¤
- [Elasticsearch Documentation](https://www.elastic.co/guide/)
- [Prometheus Best Practices](https://prometheus.io/docs/practices/)
- [Grafana Tutorials](https://grafana.com/tutorials/)

### ì‹¤ìŠµ ë„êµ¬
- ELK Stack (Elasticsearch, Logstash, Kibana)
- Prometheus + Grafana
- Fluentd/Fluent Bit
- Apache Kafka

---

## 5. ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„

ì´ í”„ë¡œë•ì…˜ ì¤€ë¹„ ê°€ì´ë“œë¥¼ ì´í•´í–ˆë‹¤ë©´ LogCasterë¥¼ ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ë°°í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **ë¡œê·¸ ê´€ë¦¬**: ë¡œí…Œì´ì…˜, ì••ì¶•, ì•„ì¹´ì´ë¹™ìœ¼ë¡œ ì €ì¥ ê³µê°„ íš¨ìœ¨ì„±
2. **êµ¬ì¡°í™”ëœ ë¡œê·¸**: JSON í¬ë§·ìœ¼ë¡œ ê²€ìƒ‰ê³¼ ë¶„ì„ ìš©ì´ì„± 
3. **ê³ ê°€ìš©ì„±**: ë‹¤ì¤‘ ì‹±í¬ì™€ ë°±ì—…ìœ¼ë¡œ ë¬´ì¤‘ë‹¨ ì„œë¹„ìŠ¤
4. **ë°±í”„ë ˆì…”**: ê³ ë¶€í•˜ ìƒí™©ì—ì„œì˜ ì•ˆì •ì ì¸ ë™ì‘

### í™•ì¸ ë¬¸ì œ

1. ë¡œê·¸ ë¡œí…Œì´ì…˜ì„ ì‹œê°„ ê¸°ë°˜ê³¼ í¬ê¸° ê¸°ë°˜ ì¤‘ ì–¸ì œ ì–´ë–¤ ê²ƒì„ ì„ íƒí•´ì•¼ í• ê¹Œìš”?
2. êµ¬ì¡°í™”ëœ ë¡œê·¸ì˜ ì¥ì ê³¼ ë‹¨ì ì€ ë¬´ì—‡ì¸ê°€ìš”?
3. ë°±í”„ë ˆì…” ì „ëµ ì¤‘ ì–´ë–¤ ìƒí™©ì—ì„œ ì–´ë–¤ ì „ëµì„ ì‚¬ìš©í•´ì•¼ í• ê¹Œìš”?

---

*ğŸ’¡ íŒ: í”„ë¡œë•ì…˜ í™˜ê²½ì€ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ìƒí™©ì´ ë§ìŠµë‹ˆë‹¤. ëª¨ë‹ˆí„°ë§ê³¼ ì•Œë¦¼ ì‹œìŠ¤í…œì„ ë°˜ë“œì‹œ êµ¬ì¶•í•˜ì„¸ìš”!*