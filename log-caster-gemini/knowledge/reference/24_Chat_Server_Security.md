# 20. ì±„íŒ… ì„œë²„ ë³´ì•ˆ ğŸ›¡ï¸
## ì•ˆì „í•œ ì±„íŒ… ì„œë¹„ìŠ¤ë¥¼ ìœ„í•œ ë³´ì•ˆ ì™„ë²½ ê°€ì´ë“œ

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ë‚œì´ë„**: ê³ ê¸‰ (Advanced)
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 25-30ì‹œê°„
- **í•„ìš” ì„ ìˆ˜ ì§€ì‹**: 
  - ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ê¸°ì´ˆ
  - ì•”í˜¸í™”ì™€ ì¸ì¦
  - IRC í”„ë¡œí† ì½œ
  - ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°
- **ì‹¤ìŠµ í™˜ê²½**: OpenSSL, ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ë„êµ¬, ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸ í™˜ê²½

---

## Overview

**"ì¸í„°ë„·ì—ì„œ ì•ˆì „í•˜ê²Œ ì±„íŒ…í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?"** ğŸ›¡ï¸

ì •ë§ ì¤‘ìš”í•œ ì§ˆë¬¸ì´ì—ìš”! ì±„íŒ… ì„œë²„ë¥¼ ìš´ì˜í•˜ëŠ” ê²ƒì€ ë§ˆì¹˜ **í° íŒŒí‹°ë¥¼ ì—¬ëŠ” ê²ƒ**ê³¼ ê°™ì•„ìš”. ë§ì€ ì‚¬ëŒë“¤ì´ ì™€ì„œ ëŒ€í™”í•˜ì§€ë§Œ, ë•Œë¡œëŠ” **ë¶ˆì²­ê°**ë“¤ë„ ë¼ì–´ë“¤ ìˆ˜ ìˆì–´ìš”. í•´ì»¤ë“¤ì€ í”ŒëŸ¬ë”©, ìŠ¤í‘¸í•‘, ì¸ì ì…˜ ê³µê²© ë“±ìœ¼ë¡œ ìš°ë¦¬ì˜ íŒŒí‹°ë¥¼ ë§ì¹˜ë ¤ê³  í•´ìš”!

í•˜ì§€ë§Œ ê±±ì •í•˜ì§€ ë§ˆì„¸ìš”! ë§ˆì¹˜ **ê²½ë¹„ì›ê³¼ ë³´ì•ˆ ì‹œìŠ¤í…œ**ì„ ê°–ì¶˜ ì•ˆì „í•œ ê±´ë¬¼ì²˜ëŸ¼, ìš°ë¦¬ë„ ì—¬ëŸ¬ ê²¹ì˜ ë³´ì•ˆ ì¥ì¹˜ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ìš”. ğŸ°

IRC ì„œë²„ë¥¼ LogCasterì— í†µí•©í•˜ë©´ ìƒˆë¡œìš´ ê³µê²© ë²¡í„°ê°€ ìƒê¹ë‹ˆë‹¤. ì±„íŒ… ì„œë²„ëŠ” í”ŒëŸ¬ë”©, ìŠ¤í‘¸í•‘, ì¸ì ì…˜ ê³µê²© ë“± ë‹¤ì–‘í•œ ë³´ì•ˆ ìœ„í˜‘ì— ë…¸ì¶œë©ë‹ˆë‹¤. ì´ ê°€ì´ë“œëŠ” LogCaster-IRCë¥¼ ì•ˆì „í•˜ê²Œ ìš´ì˜í•˜ê¸° ìœ„í•œ ë³´ì•ˆ ê¸°ìˆ ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## 1. ë„¤íŠ¸ì›Œí¬ ë ˆë²¨ ë³´ì•ˆ

**"ë¬´ìˆ˜íˆ ë§ì€ ì—°ê²° ìš”ì²­ì´ ëª°ë ¤ë“ ë‹¤ë©´?"** ğŸŒŠ

ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”! ë§ˆì¹˜ **í´ëŸ½ ì…êµ¬ì˜ ë„ì–´ë§¨**ì²˜ëŸ¼, ìš°ë¦¬ë„ ëˆ„ê°€ ë“¤ì–´ì˜¬ ìˆ˜ ìˆëŠ”ì§€ ì² ì €íˆ ê´€ë¦¬í•´ì•¼ í•´ìš”!

### 1.1 ì—°ê²° ì œí•œê³¼ í”ŒëŸ¬ë“œ ë°©ì–´ - ë””ì§€í„¸ ë„ì–´ë§¨ ğŸšª
```cpp
class ConnectionManager {
private:
    struct ConnectionInfo {
        std::chrono::steady_clock::time_point connectTime;
        std::atomic<int> connectionCount{0};
        std::atomic<int> recentAttempts{0};
        std::chrono::steady_clock::time_point lastAttempt;
        bool banned = false;
        std::chrono::steady_clock::time_point banExpiry;
    };
    
    std::unordered_map<std::string, ConnectionInfo> ipInfo_;
    std::shared_mutex ipMutex_;
    
    // ì„¤ì • ê°€ëŠ¥í•œ ì œí•œê°’
    static constexpr int MAX_CONNECTIONS_PER_IP = 5;
    static constexpr int MAX_CONNECTION_RATE = 10;  // per minute
    static constexpr auto BAN_DURATION = std::chrono::minutes(30);
    
public:
    bool acceptConnection(int sockfd) {
        // í´ë¼ì´ì–¸íŠ¸ IP ì¶”ì¶œ
        struct sockaddr_in addr;
        socklen_t len = sizeof(addr);
        getpeername(sockfd, (struct sockaddr*)&addr, &len);
        std::string ip = inet_ntoa(addr.sin_addr);
        
        auto now = std::chrono::steady_clock::now();
        
        {
            std::unique_lock lock(ipMutex_);
            auto& info = ipInfo_[ip];
            
            // ì°¨ë‹¨ í™•ì¸
            if (info.banned) {
                if (now < info.banExpiry) {
                    logWarning("Rejected connection from banned IP: {}", ip);
                    return false;
                } else {
                    // ì°¨ë‹¨ í•´ì œ
                    info.banned = false;
                    info.recentAttempts = 0;
                }
            }
            
            // ì—°ê²° ì†ë„ ì œí•œ
            if (now - info.lastAttempt < std::chrono::seconds(6)) {
                info.recentAttempts++;
                
                if (info.recentAttempts > MAX_CONNECTION_RATE) {
                    // ì¼ì‹œ ì°¨ë‹¨
                    info.banned = true;
                    info.banExpiry = now + BAN_DURATION;
                    logWarning("Banned IP {} for connection flooding", ip);
                    return false;
                }
            } else {
                info.recentAttempts = 1;
            }
            
            info.lastAttempt = now;
            
            // ë™ì‹œ ì—°ê²° ìˆ˜ ì œí•œ
            if (info.connectionCount >= MAX_CONNECTIONS_PER_IP) {
                logWarning("Too many connections from IP: {}", ip);
                return false;
            }
            
            info.connectionCount++;
            info.connectTime = now;
        }
        
        // ì—°ê²° ì¢…ë£Œ ì‹œ ì¹´ìš´íŠ¸ ê°ì†Œ ì½œë°± ì„¤ì •
        setDisconnectCallback(sockfd, [this, ip]() {
            std::unique_lock lock(ipMutex_);
            if (auto it = ipInfo_.find(ip); it != ipInfo_.end()) {
                it->second.connectionCount--;
            }
        });
        
        return true;
    }
    
    // IP ê¸°ë°˜ í•„í„°ë§
    class IPFilter {
    private:
        std::vector<std::pair<uint32_t, uint32_t>> whitelist_;  // IP ë²”ìœ„
        std::vector<std::pair<uint32_t, uint32_t>> blacklist_;
        std::shared_mutex filterMutex_;
        
    public:
        void addWhitelist(const std::string& cidr) {
            auto range = parseCIDR(cidr);
            std::unique_lock lock(filterMutex_);
            whitelist_.push_back(range);
        }
        
        void addBlacklist(const std::string& cidr) {
            auto range = parseCIDR(cidr);
            std::unique_lock lock(filterMutex_);
            blacklist_.push_back(range);
        }
        
        bool isAllowed(const std::string& ip) {
            uint32_t ipNum = ipToUint32(ip);
            std::shared_lock lock(filterMutex_);
            
            // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ìš°ì„ 
            if (!whitelist_.empty()) {
                for (const auto& [start, end] : whitelist_) {
                    if (ipNum >= start && ipNum <= end) {
                        return true;
                    }
                }
                return false;  // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ì—†ìœ¼ë©´ ê±°ë¶€
            }
            
            // ë¸”ë™ë¦¬ìŠ¤íŠ¸ í™•ì¸
            for (const auto& [start, end] : blacklist_) {
                if (ipNum >= start && ipNum <= end) {
                    return false;
                }
            }
            
            return true;
        }
        
    private:
        std::pair<uint32_t, uint32_t> parseCIDR(const std::string& cidr) {
            size_t slashPos = cidr.find('/');
            std::string ip = cidr.substr(0, slashPos);
            int prefixLen = std::stoi(cidr.substr(slashPos + 1));
            
            uint32_t ipNum = ipToUint32(ip);
            uint32_t mask = ~((1 << (32 - prefixLen)) - 1);
            
            uint32_t start = ipNum & mask;
            uint32_t end = start | ~mask;
            
            return {start, end};
        }
        
        uint32_t ipToUint32(const std::string& ip) {
            struct in_addr addr;
            inet_pton(AF_INET, ip.c_str(), &addr);
            return ntohl(addr.s_addr);
        }
    };
};
```

### 1.2 SSL/TLS í†µí•© - ë¹„ë°€ìŠ¤ëŸ¬ìš´ ëŒ€í™”ë¥¼ ìœ„í•œ ì•”í˜¸í™” ğŸ”’

**"ë‹¤ë¥¸ ì‚¬ëŒì´ ìš°ë¦¬ ëŒ€í™”ë¥¼ ì—¿ë“£ê³  ìˆë‹¤ë©´?"**

ë¬´ì„œìš´ ìƒê°ì´ì—ìš”! í•˜ì§€ë§Œ SSL/TLSëŠ” ë§ˆì¹˜ **ì•”í˜¸ í¸ì§€**ë¥¼ ì£¼ê³ ë°›ëŠ” ê²ƒ ê°™ì•„ìš”. ì¤‘ê°„ì— ëˆ„ê°€ ê°€ë¡œì±„ë„ ì•”í˜¸ë¬¸ë§Œ ë³´ì´ì£ !
```cpp
class TLSServer {
private:
    SSL_CTX* ctx_;
    std::string certFile_;
    std::string keyFile_;
    
public:
    TLSServer(const std::string& cert, const std::string& key) 
        : certFile_(cert), keyFile_(key) {
        
        // OpenSSL ì´ˆê¸°í™”
        SSL_library_init();
        SSL_load_error_strings();
        
        // TLS 1.2 ì´ìƒë§Œ í—ˆìš©
        ctx_ = SSL_CTX_new(TLS_server_method());
        SSL_CTX_set_min_proto_version(ctx_, TLS1_2_VERSION);
        
        // ê°•ë ¥í•œ ì•”í˜¸ ìŠ¤ìœ„íŠ¸ë§Œ ì‚¬ìš©
        SSL_CTX_set_cipher_list(ctx_, 
            "ECDHE-ECDSA-AES256-GCM-SHA384:"
            "ECDHE-RSA-AES256-GCM-SHA384:"
            "ECDHE-ECDSA-AES128-GCM-SHA256:"
            "ECDHE-RSA-AES128-GCM-SHA256");
        
        // ì¸ì¦ì„œ ë¡œë“œ
        if (SSL_CTX_use_certificate_file(ctx_, certFile_.c_str(), 
                                        SSL_FILETYPE_PEM) <= 0) {
            throw std::runtime_error("Failed to load certificate");
        }
        
        if (SSL_CTX_use_PrivateKey_file(ctx_, keyFile_.c_str(), 
                                        SSL_FILETYPE_PEM) <= 0) {
            throw std::runtime_error("Failed to load private key");
        }
        
        // DH íŒŒë¼ë¯¸í„° ì„¤ì • (Perfect Forward Secrecy)
        setupDHParams();
    }
    
    std::unique_ptr<TLSConnection> acceptTLS(int clientFd) {
        SSL* ssl = SSL_new(ctx_);
        SSL_set_fd(ssl, clientFd);
        
        if (SSL_accept(ssl) <= 0) {
            SSL_free(ssl);
            throw std::runtime_error("SSL handshake failed");
        }
        
        // í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œ ê²€ì¦ (ì„ íƒì )
        X509* clientCert = SSL_get_peer_certificate(ssl);
        if (clientCert) {
            if (SSL_get_verify_result(ssl) != X509_V_OK) {
                logWarning("Client certificate verification failed");
            }
            X509_free(clientCert);
        }
        
        return std::make_unique<TLSConnection>(ssl);
    }
    
private:
    void setupDHParams() {
        DH* dh = DH_new();
        BIGNUM* p = BN_new();
        BIGNUM* g = BN_new();
        
        // 2048ë¹„íŠ¸ DH íŒŒë¼ë¯¸í„°
        BN_hex2bn(&p, "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1"
                      "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
                      "EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245"
                      "E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED"
                      "EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D"
                      "C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F"
                      "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
                      "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
                      "E39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9"
                      "DE2BCBF6955817183995497CEA956AE515D2261898FA0510"
                      "15728E5A8AACAA68FFFFFFFFFFFFFFFF");
        BN_set_word(g, 2);
        
        DH_set0_pqg(dh, p, NULL, g);
        SSL_CTX_set_tmp_dh(ctx_, dh);
        DH_free(dh);
    }
};

// TLS ì—°ê²° ë˜í¼
class TLSConnection {
private:
    SSL* ssl_;
    std::mutex writeMutex_;
    
public:
    explicit TLSConnection(SSL* ssl) : ssl_(ssl) {}
    
    ~TLSConnection() {
        if (ssl_) {
            SSL_shutdown(ssl_);
            SSL_free(ssl_);
        }
    }
    
    ssize_t read(char* buffer, size_t size) {
        return SSL_read(ssl_, buffer, size);
    }
    
    ssize_t write(const char* data, size_t size) {
        std::lock_guard lock(writeMutex_);
        return SSL_write(ssl_, data, size);
    }
    
    std::string getCipherName() {
        return SSL_get_cipher_name(ssl_);
    }
};
```

## 2. ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ë³´ì•ˆ

### 2.1 ì…ë ¥ ê²€ì¦ê³¼ ì‚´ê· 
```cpp
class InputValidator {
private:
    // IRC í”„ë¡œí† ì½œ ì œì•½
    static constexpr size_t MAX_NICK_LENGTH = 30;
    static constexpr size_t MAX_CHANNEL_LENGTH = 50;
    static constexpr size_t MAX_MESSAGE_LENGTH = 512;
    
    // ê¸ˆì§€ëœ ë¬¸ì íŒ¨í„´
    std::regex ctrlCharPattern_{R"([\x00-\x1F\x7F])"};  // ì œì–´ ë¬¸ì
    std::regex nickPattern_{R"(^[a-zA-Z\[\]\\`_^{|}][a-zA-Z0-9\[\]\\`_^{|}-]*$)"};
    std::regex channelPattern_{R"(^[#&][^\x00\x07\x0A\x0D ,]+$)"};
    
public:
    struct ValidationResult {
        bool valid;
        std::string error;
        std::string sanitized;
    };
    
    ValidationResult validateNickname(const std::string& nick) {
        if (nick.empty()) {
            return {false, "Nickname cannot be empty", ""};
        }
        
        if (nick.length() > MAX_NICK_LENGTH) {
            return {false, "Nickname too long", ""};
        }
        
        if (!std::regex_match(nick, nickPattern_)) {
            return {false, "Invalid characters in nickname", ""};
        }
        
        // ì˜ˆì•½ëœ ë‹‰ë„¤ì„ í™•ì¸
        if (isReservedNick(nick)) {
            return {false, "Reserved nickname", ""};
        }
        
        return {true, "", nick};
    }
    
    ValidationResult validateChannel(const std::string& channel) {
        if (channel.length() < 2 || channel.length() > MAX_CHANNEL_LENGTH) {
            return {false, "Invalid channel name length", ""};
        }
        
        if (!std::regex_match(channel, channelPattern_)) {
            return {false, "Invalid channel name format", ""};
        }
        
        return {true, "", channel};
    }
    
    ValidationResult validateMessage(const std::string& message) {
        if (message.length() > MAX_MESSAGE_LENGTH) {
            // ë©”ì‹œì§€ ìë¥´ê¸°
            std::string truncated = message.substr(0, MAX_MESSAGE_LENGTH);
            return {true, "Message truncated", truncated};
        }
        
        // ì œì–´ ë¬¸ì ì œê±°
        std::string sanitized = std::regex_replace(message, ctrlCharPattern_, "");
        
        // CTCP ê³µê²© ë°©ì§€
        if (sanitized.find('\x01') != std::string::npos) {
            sanitized.erase(std::remove(sanitized.begin(), sanitized.end(), '\x01'), 
                           sanitized.end());
        }
        
        return {true, "", sanitized};
    }
    
    // SQL ì¸ì ì…˜ ë°©ì§€ (ë¡œê·¸ ì¿¼ë¦¬ìš©)
    std::string sanitizeQueryParam(const std::string& param) {
        std::string sanitized = param;
        
        // ìœ„í—˜í•œ ë¬¸ì ì´ìŠ¤ì¼€ì´í”„
        std::vector<std::pair<std::string, std::string>> replacements = {
            {"'", "''"},
            {"\"", "\\\""},
            {";", "\\;"},
            {"--", ""},
            {"/*", ""},
            {"*/", ""},
            {"xp_", ""},
            {"sp_", ""}
        };
        
        for (const auto& [from, to] : replacements) {
            size_t pos = 0;
            while ((pos = sanitized.find(from, pos)) != std::string::npos) {
                sanitized.replace(pos, from.length(), to);
                pos += to.length();
            }
        }
        
        return sanitized;
    }
    
private:
    bool isReservedNick(const std::string& nick) {
        static const std::set<std::string> reserved = {
            "server", "admin", "root", "operator", "chanserv", 
            "nickserv", "hostserv", "botserv", "memoserv",
            "logbot", "logcaster"
        };
        
        std::string lower = nick;
        std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
        
        return reserved.count(lower) > 0;
    }
};
```

### 2.2 ëª…ë ¹ì–´ ì¸ì ì…˜ ë°©ì§€
```cpp
class CommandSanitizer {
private:
    struct CommandContext {
        std::string command;
        std::vector<std::string> allowedParams;
        std::function<bool(const std::string&)> validator;
    };
    
    std::unordered_map<std::string, CommandContext> commandWhitelist_;
    
public:
    CommandSanitizer() {
        // í—ˆìš©ëœ ëª…ë ¹ì–´ì™€ íŒŒë¼ë¯¸í„° ì •ì˜
        commandWhitelist_["LOGQUERY"] = {
            "LOGQUERY",
            {"COUNT", "SEARCH", "FILTER", "RECENT"},
            [](const std::string& param) {
                // ì¶”ê°€ ê²€ì¦ ë¡œì§
                return param.length() < 1000;
            }
        };
        
        commandWhitelist_["LOGFILTER"] = {
            "LOGFILTER",
            {"ADD", "REMOVE", "LIST"},
            [](const std::string& param) {
                // ì •ê·œì‹ ê²€ì¦
                try {
                    std::regex test(param);
                    return true;
                } catch (...) {
                    return false;
                }
            }
        };
    }
    
    bool isCommandAllowed(const std::string& command, 
                         const std::vector<std::string>& params) {
        auto it = commandWhitelist_.find(command);
        if (it == commandWhitelist_.end()) {
            return false;  // í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ì—†ëŠ” ëª…ë ¹ì–´
        }
        
        const auto& context = it->second;
        
        // íŒŒë¼ë¯¸í„° ê²€ì¦
        if (!params.empty()) {
            const auto& firstParam = params[0];
            
            // í—ˆìš©ëœ íŒŒë¼ë¯¸í„°ì¸ì§€ í™•ì¸
            if (std::find(context.allowedParams.begin(), 
                         context.allowedParams.end(), 
                         firstParam) == context.allowedParams.end()) {
                return false;
            }
            
            // ì¶”ê°€ ê²€ì¦
            if (context.validator && params.size() > 1) {
                for (size_t i = 1; i < params.size(); ++i) {
                    if (!context.validator(params[i])) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    // ì…¸ ëª…ë ¹ì–´ ì‹¤í–‰ ë°©ì§€
    std::string sanitizeForShell(const std::string& input) {
        static const std::regex dangerousChars(R"([;&|`$(){}[\]<>!#~*?'"\\\n\r])");
        
        // ìœ„í—˜í•œ ë¬¸ìë¥¼ ì œê±°í•˜ê±°ë‚˜ ì´ìŠ¤ì¼€ì´í”„
        return std::regex_replace(input, dangerousChars, "");
    }
};
```

## 3. ì¸ì¦ê³¼ ê¶Œí•œ ê´€ë¦¬

### 3.1 ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ
```cpp
class AuthenticationManager {
private:
    struct UserAccount {
        std::string username;
        std::string passwordHash;  // bcrypt/scrypt í•´ì‹œ
        std::vector<std::string> privileges;
        std::chrono::system_clock::time_point lastLogin;
        int failedAttempts = 0;
        bool locked = false;
    };
    
    std::unordered_map<std::string, UserAccount> accounts_;
    std::shared_mutex accountMutex_;
    
    // ì„¸ì…˜ ê´€ë¦¬
    struct Session {
        std::string username;
        std::string token;
        std::chrono::steady_clock::time_point expiry;
        std::set<std::string> permissions;
    };
    
    std::unordered_map<std::string, Session> sessions_;
    std::shared_mutex sessionMutex_;
    
public:
    // ë¹„ë°€ë²ˆí˜¸ ê¸°ë°˜ ì¸ì¦
    std::optional<std::string> authenticate(const std::string& username, 
                                           const std::string& password) {
        std::unique_lock lock(accountMutex_);
        
        auto it = accounts_.find(username);
        if (it == accounts_.end()) {
            // íƒ€ì´ë° ê³µê²© ë°©ì§€ë¥¼ ìœ„í•´ ê°€ì§œ í•´ì‹œ ê²€ì¦
            bcrypt_checkpw(password.c_str(), "$2b$10$fake.hash.to.prevent.timing");
            return std::nullopt;
        }
        
        auto& account = it->second;
        
        // ê³„ì • ì ê¸ˆ í™•ì¸
        if (account.locked) {
            logWarning("Login attempt for locked account: {}", username);
            return std::nullopt;
        }
        
        // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
        if (!verifyPassword(password, account.passwordHash)) {
            account.failedAttempts++;
            
            if (account.failedAttempts >= 5) {
                account.locked = true;
                logWarning("Account locked due to failed attempts: {}", username);
            }
            
            return std::nullopt;
        }
        
        // ì„±ê³µì ì¸ ë¡œê·¸ì¸
        account.failedAttempts = 0;
        account.lastLogin = std::chrono::system_clock::now();
        
        // ì„¸ì…˜ í† í° ìƒì„±
        std::string token = generateSecureToken();
        
        {
            std::unique_lock sessionLock(sessionMutex_);
            sessions_[token] = {
                username,
                token,
                std::chrono::steady_clock::now() + std::chrono::hours(24),
                std::set<std::string>(account.privileges.begin(), 
                                     account.privileges.end())
            };
        }
        
        return token;
    }
    
    // í† í° ê¸°ë°˜ ì¸ì¦
    bool validateToken(const std::string& token) {
        std::shared_lock lock(sessionMutex_);
        
        auto it = sessions_.find(token);
        if (it == sessions_.end()) {
            return false;
        }
        
        // ë§Œë£Œ í™•ì¸
        if (std::chrono::steady_clock::now() > it->second.expiry) {
            return false;
        }
        
        return true;
    }
    
    // ê¶Œí•œ í™•ì¸
    bool hasPermission(const std::string& token, const std::string& permission) {
        std::shared_lock lock(sessionMutex_);
        
        auto it = sessions_.find(token);
        if (it == sessions_.end()) {
            return false;
        }
        
        return it->second.permissions.count(permission) > 0 ||
               it->second.permissions.count("admin") > 0;
    }
    
private:
    bool verifyPassword(const std::string& password, const std::string& hash) {
        return bcrypt_checkpw(password.c_str(), hash.c_str()) == 0;
    }
    
    std::string generateSecureToken() {
        std::random_device rd;
        std::mt19937_64 gen(rd());
        std::uniform_int_distribution<uint64_t> dis;
        
        std::stringstream ss;
        for (int i = 0; i < 4; ++i) {
            ss << std::hex << dis(gen);
        }
        
        return ss.str();
    }
};
```

### 3.2 OAuth2/SASL í†µí•©
```cpp
class SASLAuthenticator {
private:
    enum class Mechanism {
        PLAIN,
        SCRAM_SHA_256,
        EXTERNAL  // í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œ
    };
    
public:
    // SASL í˜‘ìƒ ì‹œì‘
    void startAuthentication(IRCClient& client, const std::string& mechanism) {
        if (mechanism == "PLAIN") {
            client.send("AUTHENTICATE +");
            client.setState(ClientState::AUTHENTICATING_PLAIN);
        } else if (mechanism == "SCRAM-SHA-256") {
            startSCRAM(client);
        } else if (mechanism == "EXTERNAL") {
            if (client.hasTLSCert()) {
                authenticateExternal(client);
            } else {
                client.send("904 * :SASL authentication failed");
            }
        } else {
            client.send("908 * " + mechanism + " :Unknown SASL mechanism");
        }
    }
    
    // PLAIN ë©”ì»¤ë‹ˆì¦˜ ì²˜ë¦¬
    bool handlePlainAuth(IRCClient& client, const std::string& data) {
        // base64 ë””ì½”ë“œ
        std::string decoded = base64_decode(data);
        
        // PLAIN í˜•ì‹: authzid\0authcid\0passwd
        std::vector<std::string> parts;
        size_t pos = 0;
        
        while (pos < decoded.length()) {
            size_t nullPos = decoded.find('\0', pos);
            if (nullPos == std::string::npos) {
                parts.push_back(decoded.substr(pos));
                break;
            }
            parts.push_back(decoded.substr(pos, nullPos - pos));
            pos = nullPos + 1;
        }
        
        if (parts.size() != 3) {
            return false;
        }
        
        const std::string& authzid = parts[0];  // ê¶Œí•œ ID (ë³´í†µ ë¹„ì›€)
        const std::string& authcid = parts[1];  // ì¸ì¦ ID
        const std::string& password = parts[2];
        
        return authenticateUser(authcid, password);
    }
    
    // SCRAM-SHA-256 êµ¬í˜„
    void startSCRAM(IRCClient& client) {
        // í´ë¼ì´ì–¸íŠ¸ ì²« ë©”ì‹œì§€ ìƒì„±
        std::string clientNonce = generateNonce();
        std::string clientFirstMessage = "n,,n=" + client.getUsername() + 
                                        ",r=" + clientNonce;
        
        client.setSASLState("client-nonce", clientNonce);
        client.send("AUTHENTICATE " + base64_encode(clientFirstMessage));
    }
    
private:
    std::string generateNonce() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 255);
        
        std::string nonce;
        for (int i = 0; i < 32; ++i) {
            nonce += static_cast<char>(dis(gen));
        }
        
        return base64_encode(nonce);
    }
};
```

## 4. ì±„ë„ ë³´ì•ˆ

### 4.1 ì±„ë„ ê¶Œí•œ ê´€ë¦¬
```cpp
class ChannelSecurity {
private:
    struct ChannelPermissions {
        std::set<std::string> operators;      // @ ê¶Œí•œ
        std::set<std::string> voiced;         // + ê¶Œí•œ
        std::set<std::string> banned;         // ì°¨ë‹¨ëœ ì‚¬ìš©ì
        std::map<std::string, std::chrono::steady_clock::time_point> invites;
        
        // ì±„ë„ ëª¨ë“œ
        bool moderated = false;      // +m: voicedë§Œ ë°œì–¸ ê°€ëŠ¥
        bool inviteOnly = false;     // +i: ì´ˆëŒ€ë§Œ ê°€ëŠ¥
        bool topicLocked = false;    // +t: opë§Œ í† í”½ ë³€ê²½
        bool noExternal = false;     // +n: ì±„ë„ ë©¤ë²„ë§Œ ë©”ì‹œì§€
        
        std::string key;             // +k: ì±„ë„ ë¹„ë°€ë²ˆí˜¸
        int userLimit = 0;           // +l: ì‚¬ìš©ì ìˆ˜ ì œí•œ
    };
    
    std::unordered_map<std::string, ChannelPermissions> channels_;
    std::shared_mutex channelMutex_;
    
public:
    // ì±„ë„ ì°¸ì—¬ ê¶Œí•œ í™•ì¸
    bool canJoinChannel(const std::string& channel, const IRCClient& client,
                       const std::string& key = "") {
        std::shared_lock lock(channelMutex_);
        
        auto it = channels_.find(channel);
        if (it == channels_.end()) {
            return true;  // ìƒˆ ì±„ë„
        }
        
        const auto& perms = it->second;
        
        // ì°¨ë‹¨ í™•ì¸
        if (perms.banned.count(client.getNickname()) > 0) {
            client.sendNumeric(474, channel + " :Cannot join channel (+b)");
            return false;
        }
        
        // ì´ˆëŒ€ ì „ìš©
        if (perms.inviteOnly) {
            auto inviteIt = perms.invites.find(client.getNickname());
            if (inviteIt == perms.invites.end() || 
                std::chrono::steady_clock::now() > inviteIt->second) {
                client.sendNumeric(473, channel + " :Cannot join channel (+i)");
                return false;
            }
        }
        
        // ë¹„ë°€ë²ˆí˜¸ í™•ì¸
        if (!perms.key.empty() && perms.key != key) {
            client.sendNumeric(475, channel + " :Cannot join channel (+k)");
            return false;
        }
        
        // ì‚¬ìš©ì ìˆ˜ ì œí•œ
        if (perms.userLimit > 0) {
            size_t currentUsers = getChannelUserCount(channel);
            if (currentUsers >= perms.userLimit) {
                client.sendNumeric(471, channel + " :Cannot join channel (+l)");
                return false;
            }
        }
        
        return true;
    }
    
    // ë©”ì‹œì§€ ì „ì†¡ ê¶Œí•œ
    bool canSendToChannel(const std::string& channel, const IRCClient& client) {
        std::shared_lock lock(channelMutex_);
        
        auto it = channels_.find(channel);
        if (it == channels_.end()) {
            return false;
        }
        
        const auto& perms = it->second;
        const std::string& nick = client.getNickname();
        
        // ìš´ì˜ìëŠ” í•­ìƒ ê°€ëŠ¥
        if (perms.operators.count(nick) > 0) {
            return true;
        }
        
        // ìŒì†Œê±° ëª¨ë“œ
        if (perms.moderated && perms.voiced.count(nick) == 0) {
            client.sendNumeric(404, channel + " :Cannot send to channel (+m)");
            return false;
        }
        
        // ì™¸ë¶€ ë©”ì‹œì§€ ê¸ˆì§€
        if (perms.noExternal && !client.isInChannel(channel)) {
            client.sendNumeric(404, channel + " :Cannot send to channel (+n)");
            return false;
        }
        
        return true;
    }
    
    // ê¶Œí•œ ë³€ê²½
    bool setChannelMode(const std::string& channel, const IRCClient& client,
                       char mode, bool add, const std::string& param = "") {
        if (!isOperator(channel, client.getNickname())) {
            client.sendNumeric(482, channel + " :You're not channel operator");
            return false;
        }
        
        std::unique_lock lock(channelMutex_);
        auto& perms = channels_[channel];
        
        switch (mode) {
        case 'o':  // ìš´ì˜ì ê¶Œí•œ
            if (add) {
                perms.operators.insert(param);
            } else {
                perms.operators.erase(param);
            }
            break;
            
        case 'v':  // ë°œì–¸ê¶Œ
            if (add) {
                perms.voiced.insert(param);
            } else {
                perms.voiced.erase(param);
            }
            break;
            
        case 'b':  // ì°¨ë‹¨
            if (add) {
                perms.banned.insert(param);
                // ì°¨ë‹¨ëœ ì‚¬ìš©ì ê°•ì œ í‡´ì¥
                kickBannedUser(channel, param);
            } else {
                perms.banned.erase(param);
            }
            break;
            
        case 'm':  // ìŒì†Œê±° ëª¨ë“œ
            perms.moderated = add;
            break;
            
        case 'i':  // ì´ˆëŒ€ ì „ìš©
            perms.inviteOnly = add;
            break;
            
        case 'k':  // ì±„ë„ í‚¤
            if (add) {
                perms.key = param;
            } else {
                perms.key.clear();
            }
            break;
            
        case 'l':  // ì‚¬ìš©ì ì œí•œ
            if (add) {
                perms.userLimit = std::stoi(param);
            } else {
                perms.userLimit = 0;
            }
            break;
            
        default:
            return false;
        }
        
        return true;
    }
};
```

## 5. ë¡œê·¸ ë³´ì•ˆ

### 5.1 ë¡œê·¸ ì ‘ê·¼ ì œì–´
```cpp
class LogAccessControl {
private:
    struct LogPermission {
        std::set<std::string> allowedUsers;
        std::set<std::string> allowedChannels;
        std::function<bool(const LogEntry&)> filter;
        std::chrono::system_clock::time_point expiry;
    };
    
    std::unordered_map<std::string, LogPermission> permissions_;
    std::shared_mutex permMutex_;
    
public:
    // ë¡œê·¸ ì¿¼ë¦¬ ê¶Œí•œ í™•ì¸
    bool canQueryLogs(const IRCClient& client, const QueryRequest& request) {
        std::shared_lock lock(permMutex_);
        
        // ê´€ë¦¬ìëŠ” ëª¨ë“  ê¶Œí•œ
        if (client.hasRole("admin")) {
            return true;
        }
        
        // ì¼ë°˜ ì‚¬ìš©ì ê¶Œí•œ í™•ì¸
        auto it = permissions_.find(client.getNickname());
        if (it == permissions_.end()) {
            return false;
        }
        
        const auto& perm = it->second;
        
        // ë§Œë£Œ í™•ì¸
        if (std::chrono::system_clock::now() > perm.expiry) {
            return false;
        }
        
        // ì±„ë„ ê¶Œí•œ í™•ì¸
        if (request.hasChannelFilter()) {
            const std::string& channel = request.getChannel();
            if (perm.allowedChannels.count(channel) == 0 &&
                perm.allowedChannels.count("*") == 0) {
                return false;
            }
        }
        
        return true;
    }
    
    // ë¡œê·¸ í•„í„°ë§
    std::vector<LogEntry> filterLogs(const std::vector<LogEntry>& logs,
                                    const IRCClient& client) {
        std::shared_lock lock(permMutex_);
        
        auto it = permissions_.find(client.getNickname());
        if (it == permissions_.end()) {
            return {};  // ê¶Œí•œ ì—†ìŒ
        }
        
        const auto& filter = it->second.filter;
        if (!filter) {
            return logs;  // í•„í„° ì—†ìŒ
        }
        
        std::vector<LogEntry> filtered;
        std::copy_if(logs.begin(), logs.end(), std::back_inserter(filtered),
                    filter);
        
        return filtered;
    }
    
    // ë¯¼ê°í•œ ì •ë³´ ë§ˆìŠ¤í‚¹
    LogEntry sanitizeLog(const LogEntry& log, const IRCClient& client) {
        LogEntry sanitized = log;
        
        // IP ì£¼ì†Œ ë§ˆìŠ¤í‚¹
        static const std::regex ipPattern(
            R"(\b(?:\d{1,3}\.){3}\d{1,3}\b)");
        sanitized.message = std::regex_replace(
            sanitized.message, ipPattern, "xxx.xxx.xxx.xxx");
        
        // ì´ë©”ì¼ ë§ˆìŠ¤í‚¹
        static const std::regex emailPattern(
            R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)");
        sanitized.message = std::regex_replace(
            sanitized.message, emailPattern, "****@****.***");
        
        // ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ë§ˆìŠ¤í‚¹
        static const std::regex ccPattern(
            R"(\b(?:\d[ -]*?){13,16}\b)");
        sanitized.message = std::regex_replace(
            sanitized.message, ccPattern, "****-****-****-****");
        
        // ì‚¬ìš©ì ì •ì˜ íŒ¨í„´
        if (client.hasSensitivePatterns()) {
            for (const auto& pattern : client.getSensitivePatterns()) {
                sanitized.message = std::regex_replace(
                    sanitized.message, pattern, "[REDACTED]");
            }
        }
        
        return sanitized;
    }
};
```

## 6. ëª¨ë‹ˆí„°ë§ê³¼ ê°ì‚¬

### 6.1 ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
```cpp
class SecurityAuditor {
private:
    struct SecurityEvent {
        std::chrono::system_clock::time_point timestamp;
        std::string eventType;
        std::string clientInfo;
        std::string details;
        SeverityLevel severity;
    };
    
    std::deque<SecurityEvent> events_;
    std::mutex eventMutex_;
    std::ofstream auditLog_;
    
    // ì´ìƒ íƒì§€
    struct AnomalyDetector {
        std::unordered_map<std::string, int> failedLogins;
        std::unordered_map<std::string, int> suspiciousQueries;
        std::unordered_map<std::string, std::chrono::steady_clock::time_point> lastSeen;
    } anomalyDetector_;
    
public:
    void logSecurityEvent(const std::string& type, const IRCClient& client,
                         const std::string& details, SeverityLevel severity) {
        SecurityEvent event{
            std::chrono::system_clock::now(),
            type,
            formatClientInfo(client),
            details,
            severity
        };
        
        {
            std::lock_guard lock(eventMutex_);
            events_.push_back(event);
            
            // ì˜¤ë˜ëœ ì´ë²¤íŠ¸ ì œê±°
            while (events_.size() > 10000) {
                events_.pop_front();
            }
        }
        
        // íŒŒì¼ì— ê¸°ë¡
        writeToAuditLog(event);
        
        // ì‹¬ê°í•œ ì´ë²¤íŠ¸ëŠ” ì¦‰ì‹œ ì•Œë¦¼
        if (severity >= SeverityLevel::HIGH) {
            alertAdmins(event);
        }
        
        // ì´ìƒ íƒì§€
        detectAnomalies(type, client);
    }
    
private:
    void detectAnomalies(const std::string& type, const IRCClient& client) {
        const std::string& clientId = client.getAddress();
        
        if (type == "FAILED_LOGIN") {
            anomalyDetector_.failedLogins[clientId]++;
            
            if (anomalyDetector_.failedLogins[clientId] > 10) {
                logSecurityEvent("BRUTE_FORCE_DETECTED", client,
                               "Multiple failed login attempts",
                               SeverityLevel::CRITICAL);
            }
        } else if (type == "SUSPICIOUS_QUERY") {
            anomalyDetector_.suspiciousQueries[clientId]++;
            
            if (anomalyDetector_.suspiciousQueries[clientId] > 50) {
                logSecurityEvent("QUERY_FLOOD_DETECTED", client,
                               "Excessive suspicious queries",
                               SeverityLevel::HIGH);
            }
        }
        
        // ì‹œê°„ ê¸°ë°˜ ì´ìƒ íƒì§€
        auto now = std::chrono::steady_clock::now();
        auto lastSeen = anomalyDetector_.lastSeen[clientId];
        
        if (lastSeen != std::chrono::steady_clock::time_point{}) {
            auto gap = std::chrono::duration_cast<std::chrono::hours>(
                now - lastSeen).count();
            
            if (gap > 24 * 30) {  // 30ì¼ ì´ìƒ ë¹„í™œì„± í›„ ì ‘ì†
                logSecurityEvent("DORMANT_ACCOUNT_ACCESS", client,
                               "Access after long inactivity",
                               SeverityLevel::MEDIUM);
            }
        }
        
        anomalyDetector_.lastSeen[clientId] = now;
    }
    
    std::string formatClientInfo(const IRCClient& client) {
        return fmt::format("{}@{} [{}]", 
                          client.getNickname(),
                          client.getHostname(),
                          client.getAddress());
    }
};
```

## ğŸ”¥ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë°©ë²•

### 1. ì·¨ì•½í•œ ì¸ì¦

#### [SEQUENCE: 126] í‰ë¬¸ ë¹„ë°€ë²ˆí˜¸ ì €ì¥
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: í‰ë¬¸ ë¹„ë°€ë²ˆí˜¸
struct User {
    std::string username;
    std::string password;  // í‰ë¬¸!
};

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í•´ì‹œëœ ë¹„ë°€ë²ˆí˜¸
struct User {
    std::string username;
    std::string passwordHash;  // bcrypt/scrypt/argon2
    
    bool verifyPassword(const std::string& password) {
        return bcrypt_checkpw(password.c_str(), passwordHash.c_str()) == 0;
    }
};
```

### 2. ë¶ˆì¶©ë¶„í•œ ì…ë ¥ ê²€ì¦

#### [SEQUENCE: 127] í¬ë§· ìŠ¤íŠ¸ë§ ì·¨ì•½ì 
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ì‚¬ìš©ì ì…ë ¥ì„ ì§ì ‘ í¬ë§·
void logMessage(const std::string& userInput) {
    fprintf(logFile, userInput.c_str());  // %s, %n ê³µê²© ê°€ëŠ¥
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì•ˆì „í•œ í¬ë§·
void logMessage(const std::string& userInput) {
    fprintf(logFile, "%s", userInput.c_str());
    // ë˜ëŠ” C++ ìŠ¤íŠ¸ë¦¼ ì‚¬ìš©
    logStream << userInput;
}
```

### 3. íƒ€ì´ë° ê³µê²©

#### [SEQUENCE: 128] ì¡°ê¸° ë°˜í™˜ìœ¼ë¡œ ì¸í•œ ì •ë³´ ëˆ„ì¶œ
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: íƒ€ì´ë° ì°¨ì´ë¡œ ì‚¬ìš©ì ì¡´ì¬ ì—¬ë¶€ ë…¸ì¶œ
bool authenticate(const std::string& user, const std::string& pass) {
    auto it = users.find(user);
    if (it == users.end()) {
        return false;  // ë¹ ë¥¸ ë°˜í™˜
    }
    return verifyPassword(pass, it->second.hash);  // ëŠë¦° í•´ì‹œ ê²€ì¦
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì¼ì •í•œ ì‹œê°„ ì†Œìš”
bool authenticate(const std::string& user, const std::string& pass) {
    auto it = users.find(user);
    std::string hash = (it != users.end()) ? it->second.hash : dummyHash;
    bool valid = verifyPassword(pass, hash);
    return (it != users.end()) && valid;
}
```

## ë§ˆë¬´ë¦¬

ì±„íŒ… ì„œë²„ ë³´ì•ˆì€ ë‹¤ì¸µ ë°©ì–´ ì „ëµì´ í•„ìš”í•©ë‹ˆë‹¤:

1. **ë„¤íŠ¸ì›Œí¬ ë ˆë²¨**: ì—°ê²° ì œí•œ, TLS ì•”í˜¸í™”
2. **ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨**: ì…ë ¥ ê²€ì¦, ëª…ë ¹ì–´ í•„í„°ë§
3. **ì¸ì¦/ê¶Œí•œ**: ê°•ë ¥í•œ ì¸ì¦, ì„¸ë°€í•œ ê¶Œí•œ ê´€ë¦¬
4. **ì±„ë„ ë³´ì•ˆ**: ì ‘ê·¼ ì œì–´, ë©”ì‹œì§€ í•„í„°ë§
5. **ë¡œê·¸ ë³´ì•ˆ**: ë¯¼ê° ì •ë³´ ë³´í˜¸, ì ‘ê·¼ ì œì–´
6. **ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ê°ì‚¬, ì´ìƒ íƒì§€

ì´ëŸ¬í•œ ë³´ì•ˆ ì¡°ì¹˜ë“¤ì€ LogCaster-IRCë¥¼ ì•ˆì „í•˜ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œìœ¼ë¡œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

## ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ê¸°ë³¸ ë³´ì•ˆ IRC ì„œë²„ (ê¸°ì´ˆ)
**ëª©í‘œ**: ê¸°ë³¸ì ì¸ ë³´ì•ˆ ê¸°ëŠ¥ì„ ê°–ì¶˜ IRC ì„œë²„

**êµ¬í˜„ ì‚¬í•­**:
- ì—°ê²° ìˆ˜ ì œí•œ
- ê¸°ë³¸ ì¸ì¦ ì‹œìŠ¤í…œ
- ì…ë ¥ ê²€ì¦
- ë¡œê¹… ì‹œìŠ¤í…œ

### í”„ë¡œì íŠ¸ 2: TLS ì§€ì› ì±„íŒ… ì„œë²„ (ì¤‘ê¸‰)
**ëª©í‘œ**: ì•”í˜¸í™”ëœ í†µì‹ ì„ ì§€ì›í•˜ëŠ” ì„œë²„

**êµ¬í˜„ ì‚¬í•­**:
- SSL/TLS í†µí•©
- ì¸ì¦ì„œ ê´€ë¦¬
- SASL ì¸ì¦
- ì±„ë„ ê¶Œí•œ ì‹œìŠ¤í…œ

### í”„ë¡œì íŠ¸ 3: ì—”í„°í”„ë¼ì´ì¦ˆ ë³´ì•ˆ ì‹œìŠ¤í…œ (ê³ ê¸‰)
**ëª©í‘œ**: ê¸°ì—…ìš© ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ëŠ” ì‹œìŠ¤í…œ

**êµ¬í˜„ ì‚¬í•­**:
- ë‹¤ì¤‘ ì¸ì¦ (MFA)
- ê°ì‚¬ ë¡œê¹…
- ì´ìƒ íƒì§€
- ìë™ ëŒ€ì‘ ì‹œìŠ¤í…œ

## í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ì´ˆ ë ˆë²¨ âœ…
- [ ] ê¸°ë³¸ ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ì´í•´
- [ ] ì…ë ¥ ê²€ì¦ êµ¬í˜„
- [ ] ë¹„ë°€ë²ˆí˜¸ í•´ì‹±
- [ ] ê¸°ë³¸ ë¡œê¹… ì‹œìŠ¤í…œ

### ì¤‘ê¸‰ ë ˆë²¨ ğŸ“š
- [ ] TLS/SSL êµ¬í˜„
- [ ] ì„¸ì…˜ ê´€ë¦¬
- [ ] ê¶Œí•œ ì‹œìŠ¤í…œ ì„¤ê³„
- [ ] Rate limiting êµ¬í˜„

### ê³ ê¸‰ ë ˆë²¨ ğŸš€
- [ ] ê³ ê¸‰ ì¸ì¦ ë©”ì»¤ë‹ˆì¦˜
- [ ] ì‹¤ì‹œê°„ ìœ„í˜‘ íƒì§€
- [ ] ìë™í™”ëœ ëŒ€ì‘
- [ ] í¬ë Œì‹ ë¡œê¹…

### ì „ë¬¸ê°€ ë ˆë²¨ ğŸ†
- [ ] ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì•„í‚¤í…ì²˜
- [ ] ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸ ìˆ˜í–‰
- [ ] ë³´ì•ˆ ê°ì‚¬ í”„ë¡œì„¸ìŠ¤
- [ ] ì¸ì‹œë˜íŠ¸ ëŒ€ì‘ ê³„íš

## ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì¶”ì²œ ë„ì„œ
- "Network Security Essentials" - William Stallings
- "Applied Cryptography" - Bruce Schneier
- "The Web Application Hacker's Handbook" - Stuttard & Pinto
- "Practical Cryptography" - Ferguson & Schneier

### ì˜¨ë¼ì¸ ë¦¬ì†ŒìŠ¤
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [SANS Security Resources](https://www.sans.org/security-resources/)
- [CVE Database](https://cve.mitre.org/)

### ì‹¤ìŠµ ë„êµ¬
- Wireshark - ë„¤íŠ¸ì›Œí¬ ë¶„ì„
- Metasploit - ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸
- OWASP ZAP - ì›¹ ë³´ì•ˆ í…ŒìŠ¤íŠ¸
- Burp Suite - ë³´ì•ˆ í…ŒìŠ¤íŒ…

---

*ğŸ’¡ íŒ: ë³´ì•ˆì€ ëì´ ì—†ëŠ” ê³¼ì •ì…ë‹ˆë‹¤. í•­ìƒ ìµœì‹  ìœ„í˜‘ê³¼ ëŒ€ì‘ ë°©ë²•ì„ í•™ìŠµí•˜ê³ , ì •ê¸°ì ìœ¼ë¡œ ì‹œìŠ¤í…œì„ ê°ì‚¬í•˜ì„¸ìš”.*