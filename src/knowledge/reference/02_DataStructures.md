# 6ë‹¨ê³„: ë°ì´í„° êµ¬ì¡°
*LogCaster í”„ë¡œì íŠ¸ë¥¼ ìœ„í•œ ì‚¬ì „ì§€ì‹ ë¬¸ì„œ*

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ë‚œì´ë„**: ğŸŸ¡ ì¤‘ê¸‰
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 6-8ì‹œê°„
- **ì „ì œ ì¡°ê±´**: 
  - C ê¸°ë³¸ ë¬¸ë²• (í¬ì¸í„°, êµ¬ì¡°ì²´)
  - ë©”ëª¨ë¦¬ ê´€ë¦¬ ê¸°ì´ˆ
  - C++ í´ë˜ìŠ¤ ê¸°ë³¸ ê°œë…
- **ì‹¤ìŠµ í™˜ê²½**: GCC/G++ ì»´íŒŒì¼ëŸ¬, C++11 ì´ìƒ

## ğŸ¯ ì´ ë¬¸ì„œì—ì„œ ë°°ìš¸ ë‚´ìš©

**"ë°ì´í„° êµ¬ì¡°? ê·¸ê²Œ ë­”ê°€ìš”? ì™œ ì¤‘ìš”í•œê°€ìš”?"**

ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”! ë°ì´í„° êµ¬ì¡°ë¥¼ **ì •ë¦¬ ë°©ë²•**ì— ë¹„ìœ í•´ë³´ê² ìŠµë‹ˆë‹¤:

ğŸ“š **ë°ì´í„° êµ¬ì¡° = ì •ë¦¬ì˜ ê¸°ìˆ **
- **ì±…ì¥ ì •ë¦¬**: ì¥ë¥´ë³„ë¡œ? ì €ìë³„ë¡œ? í¬ê¸°ë³„ë¡œ?
- **ì˜·ì¥ ì •ë¦¬**: ìƒ‰ê¹”ë³„ë¡œ? ì¢…ë¥˜ë³„ë¡œ? ê³„ì ˆë³„ë¡œ?
- **ë¡œê·¸ ì •ë¦¬**: ì‹œê°„ë³„ë¡œ? ì¤‘ìš”ë„ë³„ë¡œ? ì¶œì²˜ë³„ë¡œ?

ê°ê°ì˜ ì •ë¦¬ ë°©ë²•ë§ˆë‹¤ **ì°¾ëŠ” ì†ë„, ì¶”ê°€í•˜ëŠ” ì†ë„, ê´€ë¦¬ì˜ í¸ì˜ì„±**ì´ ë‹¤ë¦…ë‹ˆë‹¤!

ğŸ“ **ì´ ë¬¸ì„œì—ì„œ ë°°ìš¸ ê²ƒë“¤:**
- Cì–¸ì–´ë¡œ ì§ì ‘ ë§Œë“œëŠ” ê¸°ë³¸ ë°ì´í„° êµ¬ì¡° (ì—°ê²° ë¦¬ìŠ¤íŠ¸, ìŠ¤íƒ, í) ğŸ”§
- C++ê°€ ì œê³µí•˜ëŠ” í¸ë¦¬í•œ ì»¨í…Œì´ë„ˆë“¤ (vector, map, queue ë“±) ğŸ“¦  
- LogCasterì— íŠ¹í™”ëœ ê³ ì„±ëŠ¥ ë°ì´í„° êµ¬ì¡° ì„¤ê³„ ğŸš€
- "ì–¸ì œ ì–´ë–¤ êµ¬ì¡°ë¥¼ ì¨ì•¼ í•˜ëŠ”ì§€" íŒë‹¨í•˜ëŠ” ê¸°ì¤€ ğŸ¯

ğŸ’¡ **ì¹œê·¼í•œ í•™ìŠµ ë°©ì‹:**
- ëª¨ë“  ê°œë…ì„ ì¼ìƒìƒí™œ ì˜ˆì‹œë¡œ ì„¤ëª…í•©ë‹ˆë‹¤
- ê° êµ¬ì¡°ì˜ ì¥ë‹¨ì ì„ ì†”ì§í•˜ê²Œ ì•Œë ¤ë“œë¦½ë‹ˆë‹¤
- ì‹¤ì œ ì„±ëŠ¥ ì°¨ì´ë¥¼ ì²´ê°í•  ìˆ˜ ìˆëŠ” ì˜ˆì‹œë¥¼ ì œê³µí•©ë‹ˆë‹¤
- LogCaster í”„ë¡œì íŠ¸ì—ì„œ ì‹¤ì œë¡œ ì–´ë–»ê²Œ ì“°ì´ëŠ”ì§€ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤

---

## ğŸ“‹ 1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ (C)

### ğŸš‚ "ì—°ê²° ë¦¬ìŠ¤íŠ¸ = ê¸°ì°¨"

ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ **ê¸°ì°¨**ì— ë¹„ìœ í•´ë³´ê² ìŠµë‹ˆë‹¤!

ğŸš‚ **ê¸°ì°¨ì˜ íŠ¹ì§•:**
- ê° ì¹¸(ë…¸ë“œ)ë§ˆë‹¤ **ìŠ¹ê°(ë°ì´í„°)**ì´ íƒ€ê³  ìˆì–´ìš”
- ê° ì¹¸ì€ **ë‹¤ìŒ ì¹¸ì˜ ìœ„ì¹˜**ë¥¼ ì•Œê³  ìˆì–´ìš” (í¬ì¸í„°)
- ì¤‘ê°„ì— **ìƒˆ ì¹¸ì„ ë¼ì›Œë„£ê¸°** ì‰¬ì›Œìš” (ì‚½ì…)
- í•„ìš” ì—†ëŠ” ì¹¸ì„ **ë¶„ë¦¬í•˜ê¸°** ì‰¬ì›Œìš” (ì‚­ì œ)  
- í•˜ì§€ë§Œ 5ë²ˆì§¸ ì¹¸ì— ê°€ë ¤ë©´ 1â†’2â†’3â†’4â†’5 **ìˆœì„œëŒ€ë¡œ** ê°€ì•¼ í•´ìš”

### ğŸ” ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸: "ë‹¨ë°©í–¥ ê¸°ì°¨"

**íŠ¹ì§•:**
- **ë™ì  í¬ê¸°**: í•„ìš”í•œ ë§Œí¼ ì¹¸ì„ ëŠ˜ë¦¬ê±°ë‚˜ ì¤„ì¼ ìˆ˜ ìˆì–´ìš”
- **ë¹ ë¥¸ ì‚½ì…/ì‚­ì œ**: ì¤‘ê°„ì— ë¼ì›Œë„£ê±°ë‚˜ ë¹¼ëŠ” ê²Œ ì‰¬ì›Œìš”  
- **ìˆœì°¨ ì ‘ê·¼**: ì›í•˜ëŠ” ì¹¸ì— ê°€ë ¤ë©´ ì²˜ìŒë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ê°€ì•¼ í•´ìš”

**ğŸ¤” ì–¸ì œ ì‚¬ìš©í• ê¹Œìš”?**

**âœ… ì—°ê²° ë¦¬ìŠ¤íŠ¸ê°€ ì¢‹ì€ ê²½ìš°:**
- ë°ì´í„° ê°œìˆ˜ë¥¼ ë¯¸ë¦¬ ëª¨ë¥¼ ë•Œ (ë™ì  í¬ê¸°)
- ìì£¼ ì‚½ì…/ì‚­ì œê°€ ì¼ì–´ë‚  ë•Œ 
- ë©”ëª¨ë¦¬ë¥¼ ì•„ê»´ì•¼ í•  ë•Œ (í•„ìš”í•œ ë§Œí¼ë§Œ ì‚¬ìš©)
- ìˆœì„œëŒ€ë¡œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ

**âŒ ì—°ê²° ë¦¬ìŠ¤íŠ¸ê°€ ë‚˜ìœ ê²½ìš°:**
- íŠ¹ì • ìœ„ì¹˜ì˜ ë°ì´í„°ì— ë¹ ë¥´ê²Œ ì ‘ê·¼í•´ì•¼ í•  ë•Œ
- ë©”ëª¨ë¦¬ê°€ ì—°ì†ì ì´ì–´ì•¼ í•  ë•Œ (ìºì‹œ ì„±ëŠ¥)
- ì‘ì€ ë°ì´í„°ì—ì„œëŠ” í¬ì¸í„° ì˜¤ë²„í—¤ë“œê°€ ë¶€ë‹´ìŠ¤ëŸ¬ìš¸ ë•Œ

**ğŸ¯ LogCasterì—ì„œì˜ í™œìš© ì˜ˆì‹œ:**
```
ì‹¤ì‹œê°„ ë¡œê·¸ ìŠ¤íŠ¸ë¦¼: [ìƒˆ ë¡œê·¸] â†’ [ì´ì „ ë¡œê·¸] â†’ [ë” ì´ì „ ë¡œê·¸] â†’ ...
                     â†‘ ìƒˆë¡œ ë“¤ì–´ì˜¤ëŠ” ë¡œê·¸ë¥¼ ë§¨ ì•ì— ì¶”ê°€í•˜ê¸° ì‰¬ì›€!
                     
ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸: [ê²°ê³¼1] â†’ [ê²°ê³¼2] â†’ [ê²°ê³¼3] â†’ ...
                  â†‘ ê²€ìƒ‰ ì¡°ê±´ì— ë§ëŠ” ë¡œê·¸ë“¤ì„ í•˜ë‚˜ì”© ì—°ê²°
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ë¡œê·¸ ì—”íŠ¸ë¦¬ë¥¼ ìœ„í•œ ë…¸ë“œ êµ¬ì¡°ì²´
typedef struct LogNode {
    char message[256];           // ë¡œê·¸ ë©”ì‹œì§€
    time_t timestamp;            // íƒ€ì„ìŠ¤íƒ¬í”„
    char level[16];              // ë¡œê·¸ ë ˆë²¨ (INFO, WARNING, ERROR)
    char source[64];             // ë¡œê·¸ ì†ŒìŠ¤ (í´ë¼ì´ì–¸íŠ¸ IP)
    struct LogNode* next;        // ë‹¤ìŒ ë…¸ë“œ í¬ì¸í„°
} LogNode;

// ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°ì²´
// ê¸°ì°¨ì˜ ì‹œì‘ê³¼ ëì„ ì¶”ì í•˜ëŠ” ê°œë…
typedef struct LogList {
    LogNode* head;               // ğŸš‚ ì²« ë²ˆì§¸ ë…¸ë“œ (ê¸°ê´€ì°¨)
    LogNode* tail;               // ğŸšƒ ë§ˆì§€ë§‰ ë…¸ë“œ (ê¼¬ë¦¬ì¹¸)
    int count;                   // ğŸ”¢ ë…¸ë“œ ê°œìˆ˜ (ì´ ì¹¸ìˆ˜)
} LogList;

// ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
LogList* create_log_list() {
    LogList* list = malloc(sizeof(LogList));
    if (list == NULL) {
        return NULL;
    }
    
    list->head = NULL;
    list->tail = NULL;
    list->count = 0;
    
    return list;
}

// ë…¸ë“œ ìƒì„±
LogNode* create_log_node(const char* message, const char* level, const char* source) {
    LogNode* node = malloc(sizeof(LogNode));
    if (node == NULL) {
        return NULL;
    }
    
    // ë°ì´í„° ë³µì‚¬
    strncpy(node->message, message, sizeof(node->message) - 1);
    node->message[sizeof(node->message) - 1] = '\0';
    
    strncpy(node->level, level, sizeof(node->level) - 1);
    node->level[sizeof(node->level) - 1] = '\0';
    
    strncpy(node->source, source, sizeof(node->source) - 1);
    node->source[sizeof(node->source) - 1] = '\0';
    
    node->timestamp = time(NULL);
    node->next = NULL;
    
    return node;
}

// ë¦¬ìŠ¤íŠ¸ ì•ì— ì‚½ì… (ìµœì‹  ë¡œê·¸ê°€ ì•ì— ì˜¤ë„ë¡)
// ğŸƒ O(1) - í•­ìƒ ë¹ ë¦„!
int log_list_prepend(LogList* list, const char* message, const char* level, const char* source) {
    LogNode* new_node = create_log_node(message, level, source);
    if (new_node == NULL) {
        return -1;
    }
    
    // ìƒˆ ë…¸ë“œë¥¼ ë§¨ ì•ì— ì‚½ì…
    // [ğŸ†•][ğŸ“¦] â†’ [ğŸ†•][ğŸ“¦][ğŸ“¦]
    new_node->next = list->head;
    list->head = new_node;
    
    // ì²« ë²ˆì§¸ ë…¸ë“œë¼ë©´ tailë„ ì„¤ì •
    if (list->tail == NULL) {
        list->tail = new_node;
    }
    
    list->count++;
    return 0;
}

// ë¦¬ìŠ¤íŠ¸ ë’¤ì— ì‚½ì… (ì‹œê°„ ìˆœì„œëŒ€ë¡œ)
int log_list_append(LogList* list, const char* message, const char* level, const char* source) {
    LogNode* new_node = create_log_node(message, level, source);
    if (new_node == NULL) {
        return -1;
    }
    
    if (list->tail == NULL) {
        // ì²« ë²ˆì§¸ ë…¸ë“œ
        list->head = new_node;
        list->tail = new_node;
    } else {
        list->tail->next = new_node;
        list->tail = new_node;
    }
    
    list->count++;
    return 0;
}

// íŠ¹ì • ìœ„ì¹˜ì— ì‚½ì…
int log_list_insert_at(LogList* list, int index, const char* message, 
                      const char* level, const char* source) {
    if (index < 0 || index > list->count) {
        return -1;  // ì˜ëª»ëœ ì¸ë±ìŠ¤
    }
    
    if (index == 0) {
        return log_list_prepend(list, message, level, source);
    }
    
    if (index == list->count) {
        return log_list_append(list, message, level, source);
    }
    
    LogNode* new_node = create_log_node(message, level, source);
    if (new_node == NULL) {
        return -1;
    }
    
    // ì‚½ì… ìœ„ì¹˜ ì´ì „ ë…¸ë“œ ì°¾ê¸°
    LogNode* current = list->head;
    for (int i = 0; i < index - 1; i++) {
        current = current->next;
    }
    
    new_node->next = current->next;
    current->next = new_node;
    
    list->count++;
    return 0;
}

// ì²« ë²ˆì§¸ ë…¸ë“œ ì œê±°
LogNode* log_list_remove_first(LogList* list) {
    if (list->head == NULL) {
        return NULL;
    }
    
    LogNode* removed = list->head;
    list->head = removed->next;
    
    if (list->head == NULL) {
        list->tail = NULL;  // ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆìŒ
    }
    
    removed->next = NULL;  // ì—°ê²° ëŠê¸°
    list->count--;
    
    return removed;
}

// ë§ˆì§€ë§‰ ë…¸ë“œ ì œê±°
LogNode* log_list_remove_last(LogList* list) {
    if (list->head == NULL) {
        return NULL;
    }
    
    if (list->head == list->tail) {
        // ë…¸ë“œê°€ í•˜ë‚˜ë¿
        LogNode* removed = list->head;
        list->head = NULL;
        list->tail = NULL;
        list->count--;
        return removed;
    }
    
    // ë§ˆì§€ë§‰ ì´ì „ ë…¸ë“œ ì°¾ê¸°
    LogNode* current = list->head;
    while (current->next != list->tail) {
        current = current->next;
    }
    
    LogNode* removed = list->tail;
    current->next = NULL;
    list->tail = current;
    
    list->count--;
    return removed;
}

// íŠ¹ì • ì¡°ê±´ìœ¼ë¡œ ê²€ìƒ‰
LogNode* log_list_find(LogList* list, const char* keyword) {
    LogNode* current = list->head;
    
    while (current != NULL) {
        if (strstr(current->message, keyword) != NULL ||
            strstr(current->level, keyword) != NULL ||
            strstr(current->source, keyword) != NULL) {
            return current;
        }
        current = current->next;
    }
    
    return NULL;
}

// ëª¨ë“  ë§¤ì¹­ ê²°ê³¼ ì°¾ê¸°
int log_list_find_all(LogList* list, const char* keyword, LogNode** results, int max_results) {
    LogNode* current = list->head;
    int found_count = 0;
    
    while (current != NULL && found_count < max_results) {
        if (strstr(current->message, keyword) != NULL ||
            strstr(current->level, keyword) != NULL ||
            strstr(current->source, keyword) != NULL) {
            
            // ê²°ê³¼ ë³µì‚¬ (ì›ë³¸ ë³´í˜¸)
            results[found_count] = malloc(sizeof(LogNode));
            if (results[found_count] != NULL) {
                memcpy(results[found_count], current, sizeof(LogNode));
                results[found_count]->next = NULL;
                found_count++;
            }
        }
        current = current->next;
    }
    
    return found_count;
}

// ì‹œê°„ ë²”ìœ„ë¡œ ê²€ìƒ‰
int log_list_find_by_time_range(LogList* list, time_t start_time, time_t end_time,
                                LogNode** results, int max_results) {
    LogNode* current = list->head;
    int found_count = 0;
    
    while (current != NULL && found_count < max_results) {
        if (current->timestamp >= start_time && current->timestamp <= end_time) {
            results[found_count] = malloc(sizeof(LogNode));
            if (results[found_count] != NULL) {
                memcpy(results[found_count], current, sizeof(LogNode));
                results[found_count]->next = NULL;
                found_count++;
            }
        }
        current = current->next;
    }
    
    return found_count;
}

// ë¦¬ìŠ¤íŠ¸ ì¶œë ¥
void log_list_print(LogList* list) {
    printf("=== Log List (%d entries) ===\n", list->count);
    
    LogNode* current = list->head;
    int index = 0;
    
    while (current != NULL) {
        printf("[%d] %s | %s | %s | %s", 
               index++,
               current->level,
               current->source,
               ctime(&current->timestamp),  // ìë™ìœ¼ë¡œ \n í¬í•¨
               current->message);
        current = current->next;
    }
}

// ë©”ëª¨ë¦¬ ì •ë¦¬
void destroy_log_list(LogList* list) {
    if (list == NULL) return;
    
    LogNode* current = list->head;
    while (current != NULL) {
        LogNode* next = current->next;
        free(current);
        current = next;
    }
    
    free(list);
}

// ë…¸ë“œ ë©”ëª¨ë¦¬ í•´ì œ
void destroy_log_node(LogNode* node) {
    if (node != NULL) {
        free(node);
    }
}
```

### ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Doubly Linked List)

ì–‘ë°©í–¥ íƒìƒ‰ì´ ê°€ëŠ¥í•œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤.

```c
// ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë…¸ë“œ
typedef struct DoubleLogNode {
    char message[256];
    time_t timestamp;
    char level[16];
    char source[64];
    struct DoubleLogNode* next;    // ë‹¤ìŒ ë…¸ë“œ
    struct DoubleLogNode* prev;    // ì´ì „ ë…¸ë“œ
} DoubleLogNode;

typedef struct DoubleLogList {
    DoubleLogNode* head;
    DoubleLogNode* tail;
    int count;
} DoubleLogList;

// ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
DoubleLogList* create_double_log_list() {
    DoubleLogList* list = malloc(sizeof(DoubleLogList));
    if (list == NULL) return NULL;
    
    list->head = NULL;
    list->tail = NULL;
    list->count = 0;
    
    return list;
}

// ë…¸ë“œ ìƒì„±
DoubleLogNode* create_double_log_node(const char* message, const char* level, const char* source) {
    DoubleLogNode* node = malloc(sizeof(DoubleLogNode));
    if (node == NULL) return NULL;
    
    strncpy(node->message, message, sizeof(node->message) - 1);
    node->message[sizeof(node->message) - 1] = '\0';
    
    strncpy(node->level, level, sizeof(node->level) - 1);
    node->level[sizeof(node->level) - 1] = '\0';
    
    strncpy(node->source, source, sizeof(node->source) - 1);
    node->source[sizeof(node->source) - 1] = '\0';
    
    node->timestamp = time(NULL);
    node->next = NULL;
    node->prev = NULL;
    
    return node;
}

// ì•ì— ì‚½ì…
int double_list_prepend(DoubleLogList* list, const char* message, 
                       const char* level, const char* source) {
    DoubleLogNode* new_node = create_double_log_node(message, level, source);
    if (new_node == NULL) return -1;
    
    if (list->head == NULL) {
        // ì²« ë²ˆì§¸ ë…¸ë“œ
        list->head = new_node;
        list->tail = new_node;
    } else {
        new_node->next = list->head;
        list->head->prev = new_node;
        list->head = new_node;
    }
    
    list->count++;
    return 0;
}

// ë’¤ì— ì‚½ì…
int double_list_append(DoubleLogList* list, const char* message,
                      const char* level, const char* source) {
    DoubleLogNode* new_node = create_double_log_node(message, level, source);
    if (new_node == NULL) return -1;
    
    if (list->tail == NULL) {
        // ì²« ë²ˆì§¸ ë…¸ë“œ
        list->head = new_node;
        list->tail = new_node;
    } else {
        list->tail->next = new_node;
        new_node->prev = list->tail;
        list->tail = new_node;
    }
    
    list->count++;
    return 0;
}

// íŠ¹ì • ë…¸ë“œ ì œê±°
int double_list_remove_node(DoubleLogList* list, DoubleLogNode* node) {
    if (node == NULL) return -1;
    
    if (node->prev != NULL) {
        node->prev->next = node->next;
    } else {
        list->head = node->next;
    }
    
    if (node->next != NULL) {
        node->next->prev = node->prev;
    } else {
        list->tail = node->prev;
    }
    
    free(node);
    list->count--;
    
    return 0;
}

// ì—­ë°©í–¥ ì¶œë ¥
void double_list_print_reverse(DoubleLogList* list) {
    printf("=== Log List (Reverse Order) ===\n");
    
    DoubleLogNode* current = list->tail;
    int index = list->count - 1;
    
    while (current != NULL) {
        printf("[%d] %s | %s | %s", 
               index--,
               current->level,
               current->source,
               current->message);
        current = current->prev;
    }
}
```

---

## ğŸ—‚ï¸ 2. STL ì»¨í…Œì´ë„ˆ (C++)

### ğŸ "STL = í”„ë¡œê·¸ë˜ë¨¸ë¥¼ ìœ„í•œ ì„ ë¬¼ìƒì"

**STL(Standard Template Library)**ì„ **ì™„ë²½í•œ ë„êµ¬ìƒì**ì— ë¹„ìœ í•´ë³´ê² ìŠµë‹ˆë‹¤!

ğŸ§° **STL = ë§ŒëŠ¥ ë„êµ¬ìƒì**
- ì´ë¯¸ **ì˜ ë§Œë“¤ì–´ì§„ ë„êµ¬ë“¤**ì´ ë“¤ì–´ìˆì–´ìš”
- **í…ŒìŠ¤íŠ¸ë„ ì™„ë£Œ**ë˜ì–´ì„œ ì•ˆì „í•´ìš”
- **ì„±ëŠ¥ë„ ìµœì í™”**ë˜ì–´ ìˆì–´ìš”
- ë°”í€´ë¥¼ ë‹¤ì‹œ ë°œëª…í•  í•„ìš”ê°€ ì—†ì–´ìš”!

**ğŸ¤” "Cë¡œ ì§ì ‘ ë§Œë“¤ê¸° vs STL ì‚¬ìš©í•˜ê¸°"**

| ì¸¡ë©´ | C ì§ì ‘ êµ¬í˜„ | C++ STL |
|------|------------|---------|
| **ê°œë°œ ì‹œê°„** | â³ ì˜¤ë˜ ê±¸ë¦¼ (ë©°ì¹ ~ì£¼) | âš¡ ì¦‰ì‹œ ì‚¬ìš© (ëª‡ ë¶„) |
| **ë²„ê·¸ ìœ„í—˜** | ğŸ› ë†’ìŒ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜, ë¡œì§ ì˜¤ë¥˜) | ğŸ›¡ï¸ ë‚®ìŒ (ì² ì €íˆ í…ŒìŠ¤íŠ¸ë¨) |
| **ì„±ëŠ¥** | ğŸ¯ íŠ¹í™” ìµœì í™” ê°€ëŠ¥ | ğŸƒ ì¼ë°˜ì ìœ¼ë¡œ ìµœì í™”ë¨ |
| **ìœ ì§€ë³´ìˆ˜** | ğŸ”§ ì§ì ‘ ê´€ë¦¬í•´ì•¼ í•¨ | ğŸ¤– ìë™ ê´€ë¦¬ |
| **í•™ìŠµ íš¨ê³¼** | ğŸ“š ë‚´ë¶€ êµ¬ì¡° ê¹Šì´ ì´í•´ | ğŸš€ ë¹ ë¥¸ ê°œë°œ ì§‘ì¤‘ |
| **ì½”ë“œ ê¸¸ì´** | ğŸ“œ ê¸¸ê³  ë³µì¡ | ğŸ“ ì§§ê³  ëª…í™• |

**ğŸ’¡ ì‹¤ë¬´ì—ì„œì˜ ì„ íƒ ê¸°ì¤€:**
- **í•™ìŠµ ëª©ì **: Cë¡œ ì§ì ‘ êµ¬í˜„í•´ë³´ê¸° (ì´í•´ë„ ì¦ì§„)
- **ì‹¤ì œ í”„ë¡œì íŠ¸**: STL ì‚¬ìš©í•˜ê¸° (ìƒì‚°ì„±ê³¼ ì•ˆì •ì„±)
- **íŠ¹ìˆ˜í•œ ìš”êµ¬ì‚¬í•­**: í•˜ì´ë¸Œë¦¬ë“œ (STL ê¸°ë°˜ + ì»¤ìŠ¤í…€ ìµœì í™”)

### ğŸ“Š `std::vector`: "ë§ˆë²•ì˜ ì‹ ì¶• ê°€ë°©"

`vector`ë¥¼ **í•´ë¦¬í¬í„°ì˜ ì‹ ì¶• ê°€ë°©**ì— ë¹„ìœ í•´ë³´ê² ìŠµë‹ˆë‹¤!

ğŸ’ **vector = ì‹ ì¶• ê°€ë°©**
- **ìë™ìœ¼ë¡œ í¬ê¸° ì¡°ì ˆ**: ë¬¼ê±´ì´ ë§ì•„ì§€ë©´ ê°€ë°©ì´ ì»¤ì ¸ìš”!
- **ë¹ ë¥¸ ì ‘ê·¼**: "5ë²ˆì§¸ ë¬¼ê±´ ì£¼ì„¸ìš”!" â†’ ì¦‰ì‹œ!
- **ì—°ì†ëœ ê³µê°„**: ë¬¼ê±´ë“¤ì´ ë‚˜ë€íˆ ì •ë ¬ë˜ì–´ ìˆì–´ìš”
- **ë¿Œë¦¼ ëì—ì„œ ì¶”ê°€/ì œê±°**: ê°€ë°© ëì—ì„œ ë„£ê³  ë¹¼ëŠ” ê²Œ ì œì¼ ë¹¨ë¼ìš”

ğŸ” **ì–¸ì œ vectorë¥¼ ì‚¬ìš©í•˜ë‚˜ìš”?**
- **ë¹ ë¥¸ ëœë¤ ì ‘ê·¼**ì´ í•„ìš”í•  ë•Œ: "10ë²ˆì§¸ ë¡œê·¸ë¥¼ ë°”ë¡œ ë³´ì—¬ì¤˜!"
- **ìˆœì„œëŒ€ë¡œ ì €ì¥**í•˜ê³  ì‹¶ì„ ë•Œ: ì‹œê°„ ìˆœì„œëŒ€ë¡œ ë¡œê·¸ ì €ì¥
- **ìì£¼ ì¡°íšŒ**í•˜ì§€ë§Œ **ê°€ë” ì¶”ê°€**í•˜ëŠ” ë°ì´í„°: ì„¤ì •ê°’, ì‚¬ìš©ì ëª©ë¡ ë“±

**ğŸš€ ì„±ëŠ¥ ë¹„êµ ì‹¤í—˜:**

```cpp
#include <vector>
#include <list>
#include <chrono>
#include <iostream>

void performance_comparison() {
    const int SIZE = 1000000;
    
    // 1. ìˆœì°¨ ì ‘ê·¼ ì„±ëŠ¥ ë¹„êµ
    std::vector<int> vec(SIZE, 1);
    std::list<int> lst(SIZE, 1);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // Vector: ì¸ë±ìŠ¤ ì ‘ê·¼
    long long sum1 = 0;
    for (int i = 0; i < SIZE; ++i) {
        sum1 += vec[i];  // O(1) ì ‘ê·¼
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // List: ë°˜ë³µì ì ‘ê·¼
    long long sum2 = 0;
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        sum2 += *it;  // O(1) ì ‘ê·¼ (í•˜ì§€ë§Œ ìºì‹œ ë¯¸ìŠ¤)
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto vec_time = std::chrono::duration_cast<std::chrono::microseconds>(end1 - start).count();
    auto list_time = std::chrono::duration_cast<std::chrono::microseconds>(end2 - end1).count();
    
    std::cout << "Vector ìˆœíšŒ: " << vec_time << " ë§ˆì´í¬ë¡œì´ˆ\n";
    std::cout << "List ìˆœíšŒ: " << list_time << " ë§ˆì´í¬ë¡œì´ˆ\n";
    std::cout << "Vectorì´ " << (double)list_time / vec_time << "ë°° ë¹ ë¦„!\n";
}
```

**ğŸ“Š ì¼ë°˜ì ì¸ ê²°ê³¼:**
```
Vector ìˆœíšŒ: 750 ë§ˆì´í¬ë¡œì´ˆ
List ìˆœíšŒ: 3200 ë§ˆì´í¬ë¡œì´ˆ
Vectorì´ 4.3ë°° ë¹ ë¦„!
```

**ğŸ¤” ì™œ vectorê°€ ë” ë¹ ë¥¼ê¹Œìš”?**
1. **ë©”ëª¨ë¦¬ ì§€ì—­ì„±**: ë°ì´í„°ê°€ ì—°ì†ì ìœ¼ë¡œ ë°°ì¹˜ë˜ì–´ CPU ìºì‹œ íš¨ìœ¨ ì¦ê°€
2. **ì»´íŒŒì¼ëŸ¬ ìµœì í™”**: ë²¡í„°í™”(SIMD) ê°™ì€ ìµœì í™” ê°€ëŠ¥
3. **ê°„ë‹¨í•œ ì£¼ì†Œ ê³„ì‚°**: `ì‹œì‘ì£¼ì†Œ + (ì¸ë±ìŠ¤ Ã— í¬ê¸°)`ë¡œ ë°”ë¡œ ê³„ì‚°

```cpp
#include <vector>
#include <string>
#include <chrono>
#include <algorithm>
#include <iostream>

class LogEntry {
private:
    std::string message_;
    std::chrono::system_clock::time_point timestamp_;
    std::string level_;
    std::string source_;

public:
    LogEntry(const std::string& message, const std::string& level, const std::string& source)
        : message_(message), level_(level), source_(source),
          timestamp_(std::chrono::system_clock::now()) {}
    
    // Getter ë©”ì„œë“œë“¤
    const std::string& getMessage() const { return message_; }
    const std::string& getLevel() const { return level_; }
    const std::string& getSource() const { return source_; }
    const std::chrono::system_clock::time_point& getTimestamp() const { return timestamp_; }
    
    // ì¶œë ¥ìš©
    std::string toString() const {
        auto time_t = std::chrono::system_clock::to_time_t(timestamp_);
        return "[" + level_ + "] " + source_ + " - " + message_ + " (" + std::ctime(&time_t) + ")";
    }
    
    // ë¹„êµ ì—°ì‚°ì (ì •ë ¬ìš©)
    bool operator<(const LogEntry& other) const {
        return timestamp_ < other.timestamp_;
    }
};

class VectorLogStorage {
private:
    std::vector<LogEntry> logs_;

public:
    // ë¡œê·¸ ì¶”ê°€
    void addLog(const std::string& message, const std::string& level, const std::string& source) {
        logs_.emplace_back(message, level, source);
    }
    
    // í¬ê¸° ì¡°íšŒ
    size_t size() const {
        return logs_.size();
    }
    
    // ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼
    const LogEntry& operator[](size_t index) const {
        return logs_[index];
    }
    
    LogEntry& operator[](size_t index) {
        return logs_[index];
    }
    
    // ì•ˆì „í•œ ì ‘ê·¼
    const LogEntry& at(size_t index) const {
        return logs_.at(index);
    }
    
    // ë²”ìœ„ ê¸°ë°˜ forë¬¸ ì§€ì›
    auto begin() const { return logs_.begin(); }
    auto end() const { return logs_.end(); }
    auto begin() { return logs_.begin(); }
    auto end() { return logs_.end(); }
    
    // ìµœê·¼ Nê°œ ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
    std::vector<LogEntry> getRecentLogs(size_t count) const {
        if (count >= logs_.size()) {
            return logs_;
        }
        
        return std::vector<LogEntry>(logs_.end() - count, logs_.end());
    }
    
    // í‚¤ì›Œë“œë¡œ ê²€ìƒ‰
    std::vector<LogEntry> searchByKeyword(const std::string& keyword) const {
        std::vector<LogEntry> results;
        
        for (const auto& log : logs_) {
            if (log.getMessage().find(keyword) != std::string::npos ||
                log.getLevel().find(keyword) != std::string::npos ||
                log.getSource().find(keyword) != std::string::npos) {
                results.push_back(log);
            }
        }
        
        return results;
    }
    
    // ë ˆë²¨ë³„ í•„í„°ë§
    std::vector<LogEntry> filterByLevel(const std::string& level) const {
        std::vector<LogEntry> results;
        
        std::copy_if(logs_.begin(), logs_.end(), std::back_inserter(results),
                     [&level](const LogEntry& log) {
                         return log.getLevel() == level;
                     });
        
        return results;
    }
    
    // ì‹œê°„ ë²”ìœ„ë¡œ í•„í„°ë§
    std::vector<LogEntry> filterByTimeRange(
        const std::chrono::system_clock::time_point& start,
        const std::chrono::system_clock::time_point& end) const {
        
        std::vector<LogEntry> results;
        
        std::copy_if(logs_.begin(), logs_.end(), std::back_inserter(results),
                     [&start, &end](const LogEntry& log) {
                         auto timestamp = log.getTimestamp();
                         return timestamp >= start && timestamp <= end;
                     });
        
        return results;
    }
    
    // ì •ë ¬
    void sortByTimestamp() {
        std::sort(logs_.begin(), logs_.end());
    }
    
    // ë©”ëª¨ë¦¬ ìµœì í™”
    void shrinkToFit() {
        logs_.shrink_to_fit();
    }
    
    // ìš©ëŸ‰ ì˜ˆì•½
    void reserve(size_t capacity) {
        logs_.reserve(capacity);
    }
    
    // ë¡œê·¸ ì œí•œ (ì˜¤ë˜ëœ ë¡œê·¸ ì‚­ì œ)
    void limitSize(size_t maxSize) {
        if (logs_.size() > maxSize) {
            logs_.erase(logs_.begin(), logs_.begin() + (logs_.size() - maxSize));
        }
    }
    
    // í†µê³„ ì •ë³´
    struct Statistics {
        size_t totalLogs = 0;
        size_t errorCount = 0;
        size_t warningCount = 0;
        size_t infoCount = 0;
        std::string mostActiveSource;
    };
    
    Statistics getStatistics() const {
        Statistics stats;
        stats.totalLogs = logs_.size();
        
        std::map<std::string, size_t> sourceCounts;
        
        for (const auto& log : logs_) {
            const std::string& level = log.getLevel();
            if (level == "ERROR") stats.errorCount++;
            else if (level == "WARNING") stats.warningCount++;
            else if (level == "INFO") stats.infoCount++;
            
            sourceCounts[log.getSource()]++;
        }
        
        // ê°€ì¥ í™œë°œí•œ ì†ŒìŠ¤ ì°¾ê¸°
        auto maxSource = std::max_element(sourceCounts.begin(), sourceCounts.end(),
                                        [](const auto& a, const auto& b) {
                                            return a.second < b.second;
                                        });
        
        if (maxSource != sourceCounts.end()) {
            stats.mostActiveSource = maxSource->first;
        }
        
        return stats;
    }
    
    // ëª¨ë“  ë¡œê·¸ ì¶œë ¥
    void printAll() const {
        std::cout << "=== All Logs (" << logs_.size() << " entries) ===" << std::endl;
        for (size_t i = 0; i < logs_.size(); ++i) {
            std::cout << "[" << i << "] " << logs_[i].toString();
        }
    }
};
```

### std::deque - ì–‘ë‹¨ í

ì–‘ìª½ ëì—ì„œ íš¨ìœ¨ì ì¸ ì‚½ì…/ì‚­ì œê°€ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤.

```cpp
#include <deque>
#include <mutex>

class CircularLogBuffer {
private:
    std::deque<LogEntry> buffer_;
    size_t maxSize_;
    mutable std::mutex mutex_;

public:
    CircularLogBuffer(size_t maxSize = 1000) : maxSize_(maxSize) {}
    
    // ë¡œê·¸ ì¶”ê°€ (ìµœëŒ€ í¬ê¸° ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ ë¡œê·¸ ì œê±°)
    void addLog(const std::string& message, const std::string& level, const std::string& source) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        buffer_.emplace_back(message, level, source);
        
        if (buffer_.size() > maxSize_) {
            buffer_.pop_front();  // ê°€ì¥ ì˜¤ë˜ëœ ë¡œê·¸ ì œê±°
        }
    }
    
    // ìµœì‹  ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
    LogEntry getLatestLog() const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (buffer_.empty()) {
            throw std::runtime_error("Buffer is empty");
        }
        
        return buffer_.back();
    }
    
    // ê°€ì¥ ì˜¤ë˜ëœ ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
    LogEntry getOldestLog() const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        if (buffer_.empty()) {
            throw std::runtime_error("Buffer is empty");
        }
        
        return buffer_.front();
    }
    
    // ìµœê·¼ Nê°œ ë¡œê·¸
    std::vector<LogEntry> getRecentLogs(size_t count) const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        std::vector<LogEntry> result;
        
        size_t startIndex = (count >= buffer_.size()) ? 0 : buffer_.size() - count;
        
        for (size_t i = startIndex; i < buffer_.size(); ++i) {
            result.push_back(buffer_[i]);
        }
        
        return result;
    }
    
    // ë²„í¼ ìƒíƒœ ì •ë³´
    struct BufferInfo {
        size_t currentSize;
        size_t maxSize;
        bool isFull;
        double utilization;
    };
    
    BufferInfo getBufferInfo() const {
        std::lock_guard<std::mutex> lock(mutex_);
        
        BufferInfo info;
        info.currentSize = buffer_.size();
        info.maxSize = maxSize_;
        info.isFull = (buffer_.size() == maxSize_);
        info.utilization = static_cast<double>(buffer_.size()) / maxSize_;
        
        return info;
    }
    
    // í¬ê¸° ì¡°ì •
    void resize(size_t newMaxSize) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        maxSize_ = newMaxSize;
        
        while (buffer_.size() > maxSize_) {
            buffer_.pop_front();
        }
    }
    
    // ë²„í¼ ë¹„ìš°ê¸°
    void clear() {
        std::lock_guard<std::mutex> lock(mutex_);
        buffer_.clear();
    }
};
```

### ğŸ—ºï¸ `std::map`: "ë˜‘ë˜‘í•œ ì „í™”ë²ˆí˜¸ë¶€"

`map`ì„ **ì „í™”ë²ˆí˜¸ë¶€**ì— ë¹„ìœ í•´ë³´ê² ìŠµë‹ˆë‹¤!

ğŸ“ **map = ì „í™”ë²ˆí˜¸ë¶€**
- **í‚¤(ì´ë¦„) â†’ ê°’(ì „í™”ë²ˆí˜¸)**: "ê¹€ì² ìˆ˜" â†’ "010-1234-5678"
- **ìë™ ì •ë ¬**: ì´ë¦„ì´ ê°€ë‚˜ë‹¤ìˆœìœ¼ë¡œ ìë™ ì •ë ¬ë¼ìš”
- **ë¹ ë¥¸ ê²€ìƒ‰**: ì´ë¦„ë§Œ ì•Œë©´ ì „í™”ë²ˆí˜¸ë¥¼ ë¹ ë¥´ê²Œ ì°¾ì•„ìš”
- **ì¤‘ë³µ ë¶ˆê°€**: ê°™ì€ ì´ë¦„ì€ í•˜ë‚˜ë§Œ ë“±ë¡í•  ìˆ˜ ìˆì–´ìš”

ğŸ” **ì–¸ì œ mapì„ ì‚¬ìš©í•˜ë‚˜ìš”?**
- **í‚¤ë¡œ ë¹ ë¥´ê²Œ ì°¾ê¸°**: "ERROR ë¡œê·¸ë§Œ ë³´ì—¬ì¤˜!"
- **ë¶„ë¥˜ë³„ ì €ì¥**: IPì£¼ì†Œë³„ ì ‘ì† íšŸìˆ˜, ì‚¬ìš©ìë³„ ë¡œê·¸ ë“±
- **ìë™ ì •ë ¬**: í‚¤ê°€ ìë™ìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆìœ¼ë©´ ì¢‹ì„ ë•Œ

```cpp
// ğŸ—ºï¸ map ì‚¬ìš© ì˜ˆì‹œ
std::map<std::string, int> errorCount;  // ì—ëŸ¬ ì¢…ë¥˜ë³„ ê°œìˆ˜

// ì¶”ê°€ (ìë™ìœ¼ë¡œ ì •ë ¬ë¨)
errorCount["NetworkError"] = 5;      // ğŸŒ ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ 5ê°œ
errorCount["DatabaseError"] = 3;     // ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì—ëŸ¬ 3ê°œ  
errorCount["AuthError"] = 8;         // ğŸ” ì¸ì¦ ì—ëŸ¬ 8ê°œ

// ê²€ìƒ‰ (ë¹ ë¦„!)
cout << "Auth ì—ëŸ¬: " << errorCount["AuthError"] << "ê°œ" << endl;

// ìˆœíšŒ (ìë™ìœ¼ë¡œ ì•ŒíŒŒë²³ ìˆœì„œë¡œ!)
for (const auto& pair : errorCount) {
    cout << pair.first << ": " << pair.second << "ê°œ" << endl;
}
// ì¶œë ¥: AuthError: 8ê°œ, DatabaseError: 3ê°œ, NetworkError: 5ê°œ
```

```cpp
#include <map>
#include <unordered_map>

class LogIndex {
private:
    std::vector<LogEntry> logs_;
    std::map<std::string, std::vector<size_t>> levelIndex_;     // ë ˆë²¨ë³„ ì¸ë±ìŠ¤
    std::map<std::string, std::vector<size_t>> sourceIndex_;    // ì†ŒìŠ¤ë³„ ì¸ë±ìŠ¤
    std::unordered_map<std::string, std::vector<size_t>> keywordIndex_;  // í‚¤ì›Œë“œë³„ ì¸ë±ìŠ¤

public:
    // ë¡œê·¸ ì¶”ê°€ ë° ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
    void addLog(const std::string& message, const std::string& level, const std::string& source) {
        size_t index = logs_.size();
        logs_.emplace_back(message, level, source);
        
        // ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
        levelIndex_[level].push_back(index);
        sourceIndex_[source].push_back(index);
        
        // ë©”ì‹œì§€ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ ë° ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
        updateKeywordIndex(message, index);
    }
    
private:
    void updateKeywordIndex(const std::string& message, size_t index) {
        // ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ (ê³µë°±ìœ¼ë¡œ ë¶„ë¦¬)
        std::istringstream iss(message);
        std::string word;
        
        while (iss >> word) {
            // íŠ¹ìˆ˜ ë¬¸ì ì œê±° ë° ì†Œë¬¸ì ë³€í™˜
            std::string cleanWord;
            for (char c : word) {
                if (std::isalnum(c)) {
                    cleanWord += std::tolower(c);
                }
            }
            
            if (!cleanWord.empty() && cleanWord.length() > 2) {  // 3ê¸€ì ì´ìƒë§Œ
                keywordIndex_[cleanWord].push_back(index);
            }
        }
    }

public:
    // ë ˆë²¨ë³„ ê²€ìƒ‰
    std::vector<LogEntry> getLogsByLevel(const std::string& level) const {
        std::vector<LogEntry> results;
        
        auto it = levelIndex_.find(level);
        if (it != levelIndex_.end()) {
            for (size_t index : it->second) {
                results.push_back(logs_[index]);
            }
        }
        
        return results;
    }
    
    // ì†ŒìŠ¤ë³„ ê²€ìƒ‰
    std::vector<LogEntry> getLogsBySource(const std::string& source) const {
        std::vector<LogEntry> results;
        
        auto it = sourceIndex_.find(source);
        if (it != sourceIndex_.end()) {
            for (size_t index : it->second) {
                results.push_back(logs_[index]);
            }
        }
        
        return results;
    }
    
    // í‚¤ì›Œë“œë³„ ê²€ìƒ‰ (ë¹ ë¥¸ ê²€ìƒ‰)
    std::vector<LogEntry> getLogsByKeyword(const std::string& keyword) const {
        std::vector<LogEntry> results;
        
        std::string cleanKeyword;
        for (char c : keyword) {
            if (std::isalnum(c)) {
                cleanKeyword += std::tolower(c);
            }
        }
        
        auto it = keywordIndex_.find(cleanKeyword);
        if (it != keywordIndex_.end()) {
            for (size_t index : it->second) {
                results.push_back(logs_[index]);
            }
        }
        
        return results;
    }
    
    // ë³µí•© ê²€ìƒ‰ (AND ì¡°ê±´)
    std::vector<LogEntry> searchLogs(const std::string& level = "", 
                                   const std::string& source = "",
                                   const std::string& keyword = "") const {
        std::set<size_t> resultIndices;
        bool firstCondition = true;
        
        // ë ˆë²¨ ì¡°ê±´
        if (!level.empty()) {
            auto it = levelIndex_.find(level);
            if (it != levelIndex_.end()) {
                if (firstCondition) {
                    resultIndices.insert(it->second.begin(), it->second.end());
                    firstCondition = false;
                } else {
                    std::set<size_t> levelSet(it->second.begin(), it->second.end());
                    std::set<size_t> intersection;
                    std::set_intersection(resultIndices.begin(), resultIndices.end(),
                                        levelSet.begin(), levelSet.end(),
                                        std::inserter(intersection, intersection.begin()));
                    resultIndices = intersection;
                }
            } else {
                return {};  // ì¡°ê±´ì— ë§ëŠ” ë¡œê·¸ ì—†ìŒ
            }
        }
        
        // ì†ŒìŠ¤ ì¡°ê±´
        if (!source.empty()) {
            auto it = sourceIndex_.find(source);
            if (it != sourceIndex_.end()) {
                if (firstCondition) {
                    resultIndices.insert(it->second.begin(), it->second.end());
                    firstCondition = false;
                } else {
                    std::set<size_t> sourceSet(it->second.begin(), it->second.end());
                    std::set<size_t> intersection;
                    std::set_intersection(resultIndices.begin(), resultIndices.end(),
                                        sourceSet.begin(), sourceSet.end(),
                                        std::inserter(intersection, intersection.begin()));
                    resultIndices = intersection;
                }
            } else {
                return {};
            }
        }
        
        // í‚¤ì›Œë“œ ì¡°ê±´
        if (!keyword.empty()) {
            std::string cleanKeyword;
            for (char c : keyword) {
                if (std::isalnum(c)) {
                    cleanKeyword += std::tolower(c);
                }
            }
            
            auto it = keywordIndex_.find(cleanKeyword);
            if (it != keywordIndex_.end()) {
                if (firstCondition) {
                    resultIndices.insert(it->second.begin(), it->second.end());
                } else {
                    std::set<size_t> keywordSet(it->second.begin(), it->second.end());
                    std::set<size_t> intersection;
                    std::set_intersection(resultIndices.begin(), resultIndices.end(),
                                        keywordSet.begin(), keywordSet.end(),
                                        std::inserter(intersection, intersection.begin()));
                    resultIndices = intersection;
                }
            } else {
                return {};
            }
        }
        
        // ê²°ê³¼ êµ¬ì„±
        std::vector<LogEntry> results;
        for (size_t index : resultIndices) {
            results.push_back(logs_[index]);
        }
        
        return results;
    }
    
    // í†µê³„ ì •ë³´
    void printIndexStatistics() const {
        std::cout << "=== Index Statistics ===" << std::endl;
        std::cout << "Total logs: " << logs_.size() << std::endl;
        std::cout << "Indexed levels: " << levelIndex_.size() << std::endl;
        std::cout << "Indexed sources: " << sourceIndex_.size() << std::endl;
        std::cout << "Indexed keywords: " << keywordIndex_.size() << std::endl;
        
        std::cout << "\nLevel distribution:" << std::endl;
        for (const auto& pair : levelIndex_) {
            std::cout << "  " << pair.first << ": " << pair.second.size() << " logs" << std::endl;
        }
        
        std::cout << "\nSource distribution:" << std::endl;
        for (const auto& pair : sourceIndex_) {
            std::cout << "  " << pair.first << ": " << pair.second.size() << " logs" << std::endl;
        }
    }
};
```

---

## ğŸ“¦ 3. ë²„í¼ì™€ íì˜ ê°œë…

### ì›í˜• ë²„í¼ (Circular Buffer)

ê³ ì • í¬ê¸°ì˜ íš¨ìœ¨ì ì¸ ë²„í¼ êµ¬ì¡°ì…ë‹ˆë‹¤.

```cpp
template<typename T>
class CircularBuffer {
private:
    std::vector<T> buffer_;
    size_t head_;
    size_t tail_;
    size_t size_;
    size_t capacity_;
    bool full_;

public:
    explicit CircularBuffer(size_t capacity) 
        : buffer_(capacity), head_(0), tail_(0), size_(0), capacity_(capacity), full_(false) {}
    
    // ìš”ì†Œ ì¶”ê°€
    void push(const T& item) {
        buffer_[tail_] = item;
        
        if (full_) {
            head_ = (head_ + 1) % capacity_;
        } else {
            size_++;
        }
        
        tail_ = (tail_ + 1) % capacity_;
        full_ = (tail_ == head_);
    }
    
    // ìš”ì†Œ ì œê±°
    T pop() {
        if (empty()) {
            throw std::runtime_error("Buffer is empty");
        }
        
        T item = buffer_[head_];
        head_ = (head_ + 1) % capacity_;
        full_ = false;
        size_--;
        
        return item;
    }
    
    // ìƒíƒœ í™•ì¸
    bool empty() const { return !full_ && (head_ == tail_); }
    bool isFull() const { return full_; }
    size_t size() const { return size_; }
    size_t capacity() const { return capacity_; }
    
    // ì²« ë²ˆì§¸/ë§ˆì§€ë§‰ ìš”ì†Œ í™•ì¸ (ì œê±°í•˜ì§€ ì•ŠìŒ)
    const T& front() const {
        if (empty()) throw std::runtime_error("Buffer is empty");
        return buffer_[head_];
    }
    
    const T& back() const {
        if (empty()) throw std::runtime_error("Buffer is empty");
        size_t lastIndex = (tail_ == 0) ? capacity_ - 1 : tail_ - 1;
        return buffer_[lastIndex];
    }
    
    // ëª¨ë“  ìš”ì†Œì— ì ‘ê·¼ (ì¸ë±ìŠ¤ ê¸°ë°˜)
    const T& at(size_t index) const {
        if (index >= size_) throw std::out_of_range("Index out of range");
        size_t realIndex = (head_ + index) % capacity_;
        return buffer_[realIndex];
    }
    
    // ë°˜ë³µì ì§€ì›ì„ ìœ„í•œ í´ë˜ìŠ¤
    class iterator {
    private:
        const CircularBuffer* buffer_;
        size_t index_;
        
    public:
        iterator(const CircularBuffer* buffer, size_t index) 
            : buffer_(buffer), index_(index) {}
        
        const T& operator*() const {
            return buffer_->at(index_);
        }
        
        iterator& operator++() {
            ++index_;
            return *this;
        }
        
        bool operator!=(const iterator& other) const {
            return index_ != other.index_;
        }
    };
    
    iterator begin() const { return iterator(this, 0); }
    iterator end() const { return iterator(this, size_); }
};
```

### ìš°ì„ ìˆœìœ„ í (Priority Queue)

ë¡œê·¸ì˜ ì¤‘ìš”ë„ì— ë”°ë¼ ì²˜ë¦¬ ìˆœì„œë¥¼ ê²°ì •í•˜ëŠ” íì…ë‹ˆë‹¤.

```cpp
#include <queue>
#include <functional>

class PriorityLogEntry {
public:
    LogEntry logEntry;
    int priority;  // ë†’ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ
    
    PriorityLogEntry(const LogEntry& entry, int prio) 
        : logEntry(entry), priority(prio) {}
    
    // ìš°ì„ ìˆœìœ„ íë¥¼ ìœ„í•œ ë¹„êµ ì—°ì‚°ì (ë‚®ì€ ìš°ì„ ìˆœìœ„ê°€ topì´ ë˜ë„ë¡)
    bool operator<(const PriorityLogEntry& other) const {
        return priority < other.priority;
    }
};

class PriorityLogQueue {
private:
    std::priority_queue<PriorityLogEntry> queue_;
    
    // ë¡œê·¸ ë ˆë²¨ì— ë”°ë¥¸ ìš°ì„ ìˆœìœ„ ê²°ì •
    int getPriorityByLevel(const std::string& level) {
        if (level == "CRITICAL") return 5;
        if (level == "ERROR") return 4;
        if (level == "WARNING") return 3;
        if (level == "INFO") return 2;
        if (level == "DEBUG") return 1;
        return 0;
    }
    
public:
    // ë¡œê·¸ ì¶”ê°€
    void addLog(const LogEntry& logEntry) {
        int priority = getPriorityByLevel(logEntry.getLevel());
        queue_.emplace(logEntry, priority);
    }
    
    // ì»¤ìŠ¤í…€ ìš°ì„ ìˆœìœ„ë¡œ ë¡œê·¸ ì¶”ê°€
    void addLog(const LogEntry& logEntry, int customPriority) {
        queue_.emplace(logEntry, customPriority);
    }
    
    // ê°€ì¥ ë†’ì€ ìš°ì„ ìˆœìœ„ ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
    LogEntry getHighestPriorityLog() {
        if (queue_.empty()) {
            throw std::runtime_error("Queue is empty");
        }
        
        PriorityLogEntry topEntry = queue_.top();
        queue_.pop();
        return topEntry.logEntry;
    }
    
    // í ìƒíƒœ í™•ì¸
    bool empty() const { return queue_.empty(); }
    size_t size() const { return queue_.size(); }
    
    // ìµœê³  ìš°ì„ ìˆœìœ„ ë¡œê·¸ í™•ì¸ (ì œê±°í•˜ì§€ ì•ŠìŒ)
    const LogEntry& top() const {
        if (queue_.empty()) {
            throw std::runtime_error("Queue is empty");
        }
        return queue_.top().logEntry;
    }
    
    // ëª¨ë“  ë¡œê·¸ ì²˜ë¦¬
    void processAllLogs() {
        while (!queue_.empty()) {
            LogEntry log = getHighestPriorityLog();
            
            // ë¡œê·¸ ì²˜ë¦¬ (ì˜ˆ: íŒŒì¼ì— ì“°ê¸°, ë„¤íŠ¸ì›Œí¬ ì „ì†¡ ë“±)
            std::cout << "Processing: " << log.toString() << std::endl;
        }
    }
};
```

---

## ğŸ—ï¸ 4. LogCaster íŠ¹í™” ë°ì´í„° êµ¬ì¡°

### ì‹œê°„ ê¸°ë°˜ ë¡œê·¸ íŒŒí‹°ì…˜

ì‹œê°„ëŒ€ë³„ë¡œ ë¡œê·¸ë¥¼ ë¶„í• í•˜ì—¬ íš¨ìœ¨ì ì¸ ê²€ìƒ‰ì„ ì§€ì›í•©ë‹ˆë‹¤.

```cpp
#include <chrono>
#include <map>

class TimePartitionedLogStorage {
private:
    // ì‹œê°„ íŒŒí‹°ì…˜ (1ì‹œê°„ ë‹¨ìœ„)
    std::map<std::chrono::hours, std::vector<LogEntry>> partitions_;
    std::chrono::hours partitionSize_;
    
    // íŒŒí‹°ì…˜ í‚¤ ê³„ì‚°
    std::chrono::hours getPartitionKey(const std::chrono::system_clock::time_point& timestamp) const {
        auto duration = timestamp.time_since_epoch();
        auto hours = std::chrono::duration_cast<std::chrono::hours>(duration);
        return std::chrono::hours(hours.count() / partitionSize_.count() * partitionSize_.count());
    }

public:
    TimePartitionedLogStorage(std::chrono::hours partitionSize = std::chrono::hours(1))
        : partitionSize_(partitionSize) {}
    
    // ë¡œê·¸ ì¶”ê°€
    void addLog(const LogEntry& logEntry) {
        auto partitionKey = getPartitionKey(logEntry.getTimestamp());
        partitions_[partitionKey].push_back(logEntry);
    }
    
    // ì‹œê°„ ë²”ìœ„ë¡œ ê²€ìƒ‰
    std::vector<LogEntry> getLogsByTimeRange(
        const std::chrono::system_clock::time_point& start,
        const std::chrono::system_clock::time_point& end) const {
        
        std::vector<LogEntry> results;
        
        auto startPartition = getPartitionKey(start);
        auto endPartition = getPartitionKey(end);
        
        // ê´€ë ¨ íŒŒí‹°ì…˜ë“¤ì„ ìˆœíšŒ
        for (auto it = partitions_.lower_bound(startPartition);
             it != partitions_.end() && it->first <= endPartition; ++it) {
            
            for (const auto& log : it->second) {
                auto timestamp = log.getTimestamp();
                if (timestamp >= start && timestamp <= end) {
                    results.push_back(log);
                }
            }
        }
        
        return results;
    }
    
    // íŠ¹ì • ì‹œê°„ëŒ€ì˜ ë¡œê·¸ë“¤
    std::vector<LogEntry> getLogsInHour(const std::chrono::system_clock::time_point& time) const {
        auto partitionKey = getPartitionKey(time);
        
        auto it = partitions_.find(partitionKey);
        if (it != partitions_.end()) {
            return it->second;
        }
        
        return {};
    }
    
    // íŒŒí‹°ì…˜ í†µê³„
    struct PartitionStats {
        size_t totalPartitions;
        size_t totalLogs;
        size_t avgLogsPerPartition;
        std::chrono::hours oldestPartition;
        std::chrono::hours newestPartition;
    };
    
    PartitionStats getPartitionStats() const {
        PartitionStats stats{};
        stats.totalPartitions = partitions_.size();
        
        if (!partitions_.empty()) {
            stats.oldestPartition = partitions_.begin()->first;
            stats.newestPartition = partitions_.rbegin()->first;
            
            for (const auto& partition : partitions_) {
                stats.totalLogs += partition.second.size();
            }
            
            stats.avgLogsPerPartition = stats.totalLogs / stats.totalPartitions;
        }
        
        return stats;
    }
    
    // ì˜¤ë˜ëœ íŒŒí‹°ì…˜ ì •ë¦¬
    void cleanupOldPartitions(const std::chrono::system_clock::time_point& cutoffTime) {
        auto cutoffPartition = getPartitionKey(cutoffTime);
        
        auto it = partitions_.begin();
        while (it != partitions_.end()) {
            if (it->first < cutoffPartition) {
                it = partitions_.erase(it);
            } else {
                break;
            }
        }
    }
};
```

### ë©€í‹°ë ˆë²¨ ìºì‹œ

ìì£¼ ê²€ìƒ‰ë˜ëŠ” ë¡œê·¸ë¥¼ ì—¬ëŸ¬ ë‹¨ê³„ì˜ ìºì‹œì— ì €ì¥í•©ë‹ˆë‹¤.

```cpp
template<typename K, typename V>
class LRUCache {
private:
    struct Node {
        K key;
        V value;
        Node* prev;
        Node* next;
        
        Node(const K& k, const V& v) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    size_t capacity_;
    std::unordered_map<K, Node*> cache_;
    Node* head_;
    Node* tail_;
    
    void addToHead(Node* node) {
        node->prev = head_;
        node->next = head_->next;
        head_->next->prev = node;
        head_->next = node;
    }
    
    void removeNode(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void moveToHead(Node* node) {
        removeNode(node);
        addToHead(node);
    }
    
    Node* removeTail() {
        Node* lastNode = tail_->prev;
        removeNode(lastNode);
        return lastNode;
    }

public:
    explicit LRUCache(size_t capacity) : capacity_(capacity) {
        head_ = new Node(K{}, V{});
        tail_ = new Node(K{}, V{});
        head_->next = tail_;
        tail_->prev = head_;
    }
    
    ~LRUCache() {
        auto current = head_;
        while (current) {
            auto next = current->next;
            delete current;
            current = next;
        }
    }
    
    std::optional<V> get(const K& key) {
        auto it = cache_.find(key);
        if (it == cache_.end()) {
            return std::nullopt;
        }
        
        Node* node = it->second;
        moveToHead(node);
        return node->value;
    }
    
    void put(const K& key, const V& value) {
        auto it = cache_.find(key);
        
        if (it == cache_.end()) {
            Node* newNode = new Node(key, value);
            
            if (cache_.size() >= capacity_) {
                Node* tail = removeTail();
                cache_.erase(tail->key);
                delete tail;
            }
            
            cache_[key] = newNode;
            addToHead(newNode);
        } else {
            Node* node = it->second;
            node->value = value;
            moveToHead(node);
        }
    }
};

class MultiLevelLogCache {
private:
    LRUCache<std::string, std::vector<LogEntry>> searchCache_;   // ê²€ìƒ‰ ê²°ê³¼ ìºì‹œ
    LRUCache<std::string, LogEntry> singleLogCache_;            // ë‹¨ì¼ ë¡œê·¸ ìºì‹œ
    LRUCache<std::string, size_t> countCache_;                  // ê°œìˆ˜ ìºì‹œ
    
public:
    MultiLevelLogCache() 
        : searchCache_(100), singleLogCache_(1000), countCache_(50) {}
    
    // ê²€ìƒ‰ ê²°ê³¼ ìºì‹±
    std::optional<std::vector<LogEntry>> getCachedSearch(const std::string& query) {
        return searchCache_.get(query);
    }
    
    void cacheSearchResult(const std::string& query, const std::vector<LogEntry>& results) {
        searchCache_.put(query, results);
    }
    
    // ë‹¨ì¼ ë¡œê·¸ ìºì‹±
    std::optional<LogEntry> getCachedLog(const std::string& logId) {
        return singleLogCache_.get(logId);
    }
    
    void cacheLog(const std::string& logId, const LogEntry& log) {
        singleLogCache_.put(logId, log);
    }
    
    // ê°œìˆ˜ ìºì‹±
    std::optional<size_t> getCachedCount(const std::string& query) {
        return countCache_.get(query);
    }
    
    void cacheCount(const std::string& query, size_t count) {
        countCache_.put(query, count);
    }
};
```

---

## âœ… 5. ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„

ì´ ë¬¸ì„œë¥¼ ì™„ì „íˆ ì´í•´í–ˆë‹¤ë©´:

1. **Cì˜ ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬í˜„**ì„ í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
2. **C++ì˜ STL ì»¨í…Œì´ë„ˆ**ë¥¼ ì ì ˆíˆ ì„ íƒí•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
3. **ë²„í¼ì™€ íì˜ ê°œë…**ì„ ì´í•´í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
4. **LogCasterì— íŠ¹í™”ëœ ë°ì´í„° êµ¬ì¡°**ë¥¼ ì„¤ê³„í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
5. **ì„±ëŠ¥ê³¼ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**ì„ ê³ ë ¤í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ì„ íƒí•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤

### ğŸ¯ í™•ì¸ ë¬¸ì œ

1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì™€ ë°°ì—´ì˜ ì¥ë‹¨ì ì€ ë¬´ì—‡ì´ë©°, LogCasterì—ì„œ ì–¸ì œ ì–´ë–¤ ê²ƒì„ ì‚¬ìš©í•´ì•¼ í• ê¹Œìš”?

2. std::vectorì™€ std::dequeì˜ ì°¨ì´ì ì€ ë¬´ì—‡ì´ê³ , ì–´ë–¤ ìƒí™©ì—ì„œ ì–´ë–¤ ê²ƒì„ ì„ íƒí•´ì•¼ í• ê¹Œìš”?

3. ëŒ€ìš©ëŸ‰ ë¡œê·¸ ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰í•˜ê¸° ìœ„í•œ ì¸ë±ì‹± ì „ëµì€ ë¬´ì—‡ì¸ê°€ìš”?

ë‹¤ìŒ ë¬¸ì„œì—ì„œëŠ” **I/O ë©€í‹°í”Œë ‰ì‹±**ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤!

## ğŸš¨ ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
**ë¬¸ì œ**: ë…¸ë“œë¥¼ ì‚­ì œí•  ë•Œ ë©”ëª¨ë¦¬ í•´ì œë¥¼ ìŠìŒ
```c
// âŒ ì˜ëª»ëœ ì½”ë“œ
void remove_node(LogList* list, LogNode* node) {
    // ë¦¬ìŠ¤íŠ¸ì—ì„œ ë…¸ë“œë§Œ ì œê±°í•˜ê³  ë©”ëª¨ë¦¬ëŠ” í•´ì œí•˜ì§€ ì•ŠìŒ
    if (node->prev) node->prev->next = node->next;
    if (node->next) node->next->prev = node->prev;
    // free(node) ëˆ„ë½!
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ
void remove_node(LogList* list, LogNode* node) {
    if (node->prev) node->prev->next = node->next;
    if (node->next) node->next->prev = node->prev;
    free(node);  // ë°˜ë“œì‹œ ë©”ëª¨ë¦¬ í•´ì œ
    list->count--;
}
```

### 2. STL ì»¨í…Œì´ë„ˆ ì˜ëª»ëœ ë°˜ë³µì ì‚¬ìš©
**ë¬¸ì œ**: ì»¨í…Œì´ë„ˆ ìˆ˜ì • ì¤‘ ë°˜ë³µì ë¬´íš¨í™”
```cpp
// âŒ ìœ„í—˜í•œ ì½”ë“œ
std::vector<LogEntry> logs;
for (auto it = logs.begin(); it != logs.end(); ++it) {
    if (it->getLevel() == "DEBUG") {
        logs.erase(it);  // ë°˜ë³µì ë¬´íš¨í™”!
    }
}

// âœ… ì•ˆì „í•œ ì½”ë“œ
std::vector<LogEntry> logs;
for (auto it = logs.begin(); it != logs.end(); ) {
    if (it->getLevel() == "DEBUG") {
        it = logs.erase(it);  // eraseëŠ” ë‹¤ìŒ ìœ íš¨í•œ ë°˜ë³µì ë°˜í™˜
    } else {
        ++it;
    }
}

// âœ… ë” ë‚˜ì€ ë°©ë²• (C++11)
logs.erase(std::remove_if(logs.begin(), logs.end(),
    [](const LogEntry& log) { return log.getLevel() == "DEBUG"; }),
    logs.end());
```

### 3. ì›í˜• ë²„í¼ ì˜¤ë²„í”Œë¡œìš°
**ë¬¸ì œ**: ë²„í¼ê°€ ê°€ë“ ì°¬ ìƒíƒœ ì²˜ë¦¬ ì‹¤íŒ¨
```c
// âŒ ìœ„í—˜í•œ ì½”ë“œ
void circular_buffer_push(CircularBuffer* buf, void* data) {
    memcpy(buf->data[buf->tail], data, buf->item_size);
    buf->tail = (buf->tail + 1) % buf->capacity;
    // ë²„í¼ê°€ ê°€ë“ ì°¼ì„ ë•Œ head ì—…ë°ì´íŠ¸ ëˆ„ë½!
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ
void circular_buffer_push(CircularBuffer* buf, void* data) {
    memcpy(buf->data[buf->tail], data, buf->item_size);
    
    if (buf->is_full) {
        buf->head = (buf->head + 1) % buf->capacity;
    }
    
    buf->tail = (buf->tail + 1) % buf->capacity;
    buf->is_full = (buf->tail == buf->head);
}
```

### 4. map/unordered_map í‚¤ ì¡´ì¬ í™•ì¸
**ë¬¸ì œ**: ì—†ëŠ” í‚¤ì— ì ‘ê·¼í•˜ì—¬ ì˜ë„ì¹˜ ì•Šì€ ì‚½ì…
```cpp
// âŒ ì˜ëª»ëœ ì½”ë“œ
std::map<std::string, int> logCounts;
if (logCounts["ERROR"] > 0) {  // "ERROR" í‚¤ê°€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ìƒì„±ë¨
    // ...
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ
std::map<std::string, int> logCounts;
if (logCounts.find("ERROR") != logCounts.end() && logCounts["ERROR"] > 0) {
    // ...
}

// âœ… C++20ì˜ contains ì‚¬ìš©
if (logCounts.contains("ERROR") && logCounts["ERROR"] > 0) {
    // ...
}
```

## ğŸ’¡ ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ë¡œê·¸ ë¶„ì„ê¸° êµ¬í˜„
```c
// ë‹¤ìŒ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì„¸ìš”:
// 1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ ë¡œê·¸ ì €ì¥ì†Œ
// 2. í•´ì‹œ í…Œì´ë¸” ê¸°ë°˜ ë¹ ë¥¸ ê²€ìƒ‰
// 3. ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•œ ì¤‘ìš” ë¡œê·¸ ì²˜ë¦¬

typedef struct LogAnalyzer {
    LogList* allLogs;           // ëª¨ë“  ë¡œê·¸ ì €ì¥
    HashTable* indexByKeyword;  // í‚¤ì›Œë“œ ì¸ë±ìŠ¤
    PriorityQueue* criticalLogs; // ì¤‘ìš” ë¡œê·¸ í
} LogAnalyzer;

// êµ¬í˜„í•´ì•¼ í•  í•¨ìˆ˜ë“¤
LogAnalyzer* create_analyzer();
void analyze_log(LogAnalyzer* analyzer, const char* logLine);
LogEntry** search_logs(LogAnalyzer* analyzer, const char* keyword);
LogEntry* get_next_critical_log(LogAnalyzer* analyzer);
void print_statistics(LogAnalyzer* analyzer);
```

### í”„ë¡œì íŠ¸ 2: ì‹¤ì‹œê°„ ë¡œê·¸ ëª¨ë‹ˆí„° (C++)
```cpp
// ë‹¤ìŒ í´ë˜ìŠ¤ë¥¼ ì™„ì„±í•˜ì„¸ìš”:
class RealtimeLogMonitor {
private:
    CircularBuffer<LogEntry> recentLogs;      // ìµœê·¼ ë¡œê·¸
    std::map<std::string, size_t> errorCounts; // ì—ëŸ¬ í†µê³„
    TimePartitionedStorage partitions;         // ì‹œê°„ë³„ íŒŒí‹°ì…˜
    
public:
    // êµ¬í˜„í•´ì•¼ í•  ë©”ì„œë“œë“¤
    void processLog(const std::string& logLine);
    std::vector<LogEntry> getRecentErrors(size_t count);
    void generateHourlyReport();
    void alertOnThreshold(const std::string& errorType, size_t threshold);
};
```

### í”„ë¡œì íŠ¸ 3: ë¡œê·¸ ìºì‹œ ì‹œìŠ¤í…œ
```cpp
// LRU ìºì‹œë¥¼ ì´ìš©í•œ ë¡œê·¸ ìºì‹± ì‹œìŠ¤í…œ
template<typename K, typename V>
class LogCacheSystem {
    // êµ¬í˜„ ë‚´ìš©:
    // 1. LRU ìºì‹œ êµ¬í˜„
    // 2. ìºì‹œ íˆíŠ¸ìœ¨ ì¸¡ì •
    // 3. ìºì‹œ ì›Œë°ì—… ì „ëµ
    // 4. ë©€í‹°ìŠ¤ë ˆë“œ ì•ˆì „ì„±
};
```

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì±… ì¶”ì²œ
- "Introduction to Algorithms" - CLRS (ìë£Œêµ¬ì¡° ì´ë¡ )
- "The C++ Standard Library" - Nicolai Josuttis (STL ê¹Šì´ ìˆëŠ” í•™ìŠµ)
- "Algorithms in C" - Robert Sedgewick (C êµ¬í˜„)

### ì˜¨ë¼ì¸ ìë£Œ
- [cppreference.com - Containers](https://en.cppreference.com/w/cpp/container)
- [GeeksforGeeks - Data Structures](https://www.geeksforgeeks.org/data-structures/)
- [Visualgo - ìë£Œêµ¬ì¡° ì‹œê°í™”](https://visualgo.net/en)

## âœ… í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ì´ˆ (1-2ì£¼)
- [ ] ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì§ì ‘ êµ¬í˜„ (C)
- [ ] ë™ì  ë°°ì—´ êµ¬í˜„
- [ ] ìŠ¤íƒê³¼ í êµ¬í˜„
- [ ] ì‹œê°„ ë³µì¡ë„ ì´í•´

### ì¤‘ê¸‰ (3-4ì£¼)
- [ ] STL vector, list, deque í™œìš©
- [ ] mapê³¼ unordered_map ì°¨ì´ ì´í•´
- [ ] ì›í˜• ë²„í¼ êµ¬í˜„
- [ ] ìš°ì„ ìˆœìœ„ í í™œìš©

### ê³ ê¸‰ (5-6ì£¼)
- [ ] ì»¤ìŠ¤í…€ allocator ì‘ì„±
- [ ] í•´ì‹œ í…Œì´ë¸” ì§ì ‘ êµ¬í˜„
- [ ] B-íŠ¸ë¦¬ ì´í•´
- [ ] ë½í”„ë¦¬ ìë£Œêµ¬ì¡° ê¸°ì´ˆ

### ì „ë¬¸ê°€ (7-8ì£¼)
- [ ] ì‹œê°„/ê³µê°„ ë³µì¡ë„ ìµœì í™”
- [ ] ìºì‹œ ì¹œí™”ì  ìë£Œêµ¬ì¡°
- [ ] ë¶„ì‚° ìë£Œêµ¬ì¡°
- [ ] ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬

## ğŸ”„ ë‹¤ìŒ í•™ìŠµ ë‹¨ê³„

ì´ ë¬¸ì„œë¥¼ ì™„ë£Œí–ˆë‹¤ë©´ ë‹¤ìŒ ë¬¸ì„œë¡œ ì§„í–‰í•˜ì„¸ìš”:

1. **[03. OOP_CPP_Guide.md](03.%20OOP_CPP_Guide.md)** - C++ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°
   - í´ë˜ìŠ¤ì™€ ê°ì²´
   - ìƒì†ê³¼ ë‹¤í˜•ì„±
   - í…œí”Œë¦¿ í”„ë¡œê·¸ë˜ë°

2. **[07. Networking.md](07.%20Networking.md)** - ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë°
   - ì†Œì¼“ í”„ë¡œê·¸ë˜ë°
   - ë¹„ë™ê¸° I/O
   - í”„ë¡œí† ì½œ ì„¤ê³„

3. **[09. IOMultiplexing.md](09.%20IOMultiplexing.md)** - I/O ë©€í‹°í”Œë ‰ì‹±
   - select/poll/epoll
   - ì´ë²¤íŠ¸ ê¸°ë°˜ í”„ë¡œê·¸ë˜ë°
   - ê³ ì„±ëŠ¥ ì„œë²„ ì„¤ê³„

---

*ğŸ’¡ íŒ: ë°ì´í„° êµ¬ì¡° ì„ íƒì€ ì„±ëŠ¥ì— í° ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤. í•­ìƒ ìš©ë„ì— ë§ëŠ” ì ì ˆí•œ êµ¬ì¡°ë¥¼ ì„ íƒí•˜ì„¸ìš”!*