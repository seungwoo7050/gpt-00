## 프로젝트 목표 및 작업 가이드라인 (Project Goal & Working Guidelines)

**1. 핵심 목표 (Core Objective):**
이 프로젝트의 최종 목표는 `log-caster-gemini` 프로젝트의 전체 개발 역사를 단계별로 완벽하게 재구현할 수 있도록, 상세하고 포괄적인 `DevHistory` 문서 시리즈를 작성하는 것입니다. 각 문서는 독립적으로 이해 가능해야 하며, 제3자가 해당 MVP를 재현하는 데 필요한 모든 정보를 담고 있어야 합니다.

**2. 진실의 원천 (Single Source of Truth):**
*   `log-caster-c/src` 및 `LogCrafter-CPP/src` 디렉토리의 소스 코드가 **현재 상태의 유일한 진실의 원천**입니다.
*   `DevHistoryXX.md` 문서는 각 MVP 단계의 **설계 명세** 역할을 하며, 코드와 100% 동기화되어야 합니다.
*   `DEVELOPMENT_JOURNEY.md` 파일은 개발 타임라인과 각 MVP의 개괄적인 범위를 참고하기 위한 용도로만 사용합니다.

**3. 시퀀스 번호 부여 원칙 (Sequence Numbering Principles):**
*   **유일성 (Uniqueness):** 특정 MVP 내의 모든 시퀀스 번호는 유일해야 합니다. (예: `MVP4-21`은 MVP4 내에서 단 한 번만 사용될 수 있습니다.) 중복이 발견될 경우, 계획을 수립하여 유일한 번호로 재정렬합니다.
*   **역사성 (Historicity):** 기능이 여러 MVP에 걸쳐 수정될 때, 기존의 숫자 기반 시퀀스 주석(`// [SEQUENCE: 123]`)은 새로운 MVP 시퀀스 주석으로 대체(제거 후 추가)합니다. 하지만, 한번 작성된 **MVP 기반 시퀀스 주석(`// [SEQUENCE: MVPX-Y]`)은 수정하거나 삭제하지 않습니다.** 대신, 해당 기능에 대한 후속 MVP의 변경 사항이 생기면, 관련된 **새로운 MVP 시퀀스 주석을 기존 주석 아래에 추가**합니다. 이를 통해 코드의 변경 이력이 MVP 단위로 남게 됩니다.

**4. 핵심 작업 절차 (Core Workflow - 각 MVP에 반복):**
1.  **상세 설명 원칙 (Detailed Explanation Principle):** 각 `DevHistory` 문서 작성 시, 단순히 시퀀스 목록을 나열하는 것을 넘어, 해당 MVP의 핵심 기능들에 대한 **설계 목표, 기술적 선택 이유, 그리고 기대 효과 등을 설명하는 개요 단락을 반드시 포함**해야 합니다. 이는 코드의 '무엇'을 넘어 '왜'를 설명하기 위함입니다.
2.  **문서 검토 (Review Document):** 해당 MVP의 `DevHistoryXX.md` 파일을 읽고, 명시된 시퀀스 번호와 파일 목록을 파악합니다. 문서 자체의 논리적 오류(번호 중복 등)를 먼저 확인합니다.
3.  **코드 검증 (Verify Code):** `grep`을 사용하여 `src` 디렉토리 내에 해당 MVP의 시퀀스 번호가 문서와 일치하게 존재하는지 확인합니다.
4.  **불일치 해결 계획 수립 (Plan Discrepancy Resolution):** 문서와 코드 간의 불일치(누락, 중복, 오류)가 발견되면, 이를 해결하기 위한 **종합적인 계획을 먼저 수립하여 사용자에게 제시하고 승인**을 받습니다. 여기에는 시퀀스 번호 재정렬, 누락된 파일 내용 추가 등이 포함될 수 있습니다.
5.  **계획 실행 (Execute Plan):** 승인된 계획에 따라, 코드(`src`)와 문서(`DevHistoryXX.md`)를 모두 수정하여 동기화합니다.
6.  **문서-코드 주석 일치 (Comment Synchronization):** `DevHistory` 문서에 포함되는 모든 시퀀스 주석은, 대응하는 소스 코드의 주석과 **글자 하나까지 정확히 일치**해야 합니다. 범위 요약(`A~B`)은 허용되지 않습니다.
7.  **전체 내용 보존 (Preserve Full Content):** 파일 수정 시, 특정 부분만 변경하더라도 나머지 내용이 절대 유실되지 않도록 항상 **전체 내용을 보존하여 작업**합니다.

**5. 코드 수정 원칙 (Code Modification Principles):**
*   **코드 생성 (Code Generation):** 문서화 과정에서 MVP 기능 구현에 필요한 소스 파일(`.h` 또는 `.c`/`.cpp`)이 없는 경우, **새로운 파일을 직접 생성하는 것은 허용됩니다.**
*   **코드 보존 (Code Preservation):** 기존 코드를 수정하거나 리팩토링하는 것은 허용되지만, **기능하는 기존 코드를 삭제하는 것은 절대 금지됩니다.** 파일의 목적이 더 이상 유효하지 않다면, 명시적인 확인 없이 내용을 삭제하지 말고 사용 중단(deprecation)으로 표시하십시오.
*   **진실의 원천 (백업) (Source of Truth (Backup)):** 파일 손상 또는 의도치 않은 삭제 시, `/path/to/backup/log-caster-gemini`를 최종적인 복원 소스로 사용해야 합니다. (주: 이 경로는 실제 백업 위치에 맞게 수정해야 합니다.)

**6. 세션 재개 프로토콜 (Session Resumption Protocol):**
작업이 중단된 후 새로운 세션에서 재개할 경우, 다음 절차를 반드시 따르십시오.
1.  **목표 식별 (Identify Goal):** 사용자의 프롬프트(예: "DevHistoryRule.md문서를 읽고 X버전부터 작업을 이어나가세요.")를 통해 시작할 MVP 버전을 확인합니다.
2.  **규칙 내재화 (Internalize Rules):** 이 문서(`DevHistoryRule.md`)의 모든 규칙을 읽고 완전히 이해합니다.
3.  **상태 평가 (파일 분석) (Assess State (File Analysis)):** 작업 디렉토리 (`/home/woopinbells/Desktop/gpt-00/`)에서 대상 MVP 시퀀스(예: `grep -r "MVP-X-"`)에 대한 `grep` 검색을 수행하여 현재 버전과 관련된 모든 파일을 식별합니다.
4.  **상태 평가 (기록 검토) (Assess State (History Review)):** 해당 `DevHistoryXX.md` 파일(예: `DevHistory0X.md`)을 읽어 해당 버전의 개발 컨텍스트와 목표를 이해합니다.
5.  **계획 수립 (Formulate Plan):** 규칙, 파일 상태, 개발 기록을 바탕으로 작업을 계속하기 위한 계획을 수립합니다.
6.  **실행 (Execute):** 수립된 모든 코드 수정 및 보존 원칙을 준수하며 계획을 실행합니다.

**7. 프로덕션 고려사항 및 개선 제안 (Production Considerations & Improvement Notes):**
*   각 MVP 문서의 말미에는, 해당 기능들을 실제 프로덕션 환경에서 운영하기 위해 필요한 추가적인 고려사항을 구체적인 코드 예시와 함께 상세히 기술합니다.
*   코드 개선 제안 사항이 있을 경우, `#### 개선 제안 (Improvement Notes):` 섹션에 별도로 명시합니다.

**8. 최소 변경 및 즉시 검증 원칙 (Principle of Minimal Change & Immediate Verification):**
*   **8.1. `replace` 도구 사용 제한:** 파일 전체 또는 여러 줄에 걸친 광범위한 `replace` 작업은 원칙적으로 금지한다. `replace`는 반드시 **단일 행(single-line) 또는 매우 작은, 명확히 식별되는 코드 블록**을 대상으로만 사용해야 한다.
*   **8.2. `write_file` 기반 수정 절차:** 여러 줄 수정이 불가피할 경우, 다음 절차를 반드시 따른다:
    *   가. `read_file`로 수정할 파일의 **정확한 현재 내용**을 읽는다.
    *   나. 수정할 내용을 반영하여, **전체 파일에 대한 새로운 내용**을 메모리 상에서 생성한다.
    *   다. `write_file`을 사용하여 **파일 전체를 덮어쓴다.**
    *   라. **(가장 중요)** 작업 직후, `diff` 명령어를 사용하여 **작업본과 백업본의 차이를 즉시 확인**하고, 의도치 않은 코드 삭제가 없는지 검증한다. 만약 의도치 않은 변경이 발견되면 즉시 사용자에게 보고하고 복원한다.

**9. MVP 복구 및 재문서화 절차 (MVP Recovery & Redocumentation Procedure):**
기존 `DevHistory` 문서가 부정확하거나, 관련 소스 코드가 누락 또는 불완전한 MVP를 처음부터 재정비할 때 사용하는 절차이다. 이 절차는 코드로부터 문서를 재구성하여 100%의 정확성을 보장하는 것을 목표로 한다.

*   **9.1. 코드 우선 탐색 (Code-First Discovery):** `glob`과 `search_file_content`를 사용하여 해당 MVP의 주제(예: "네트워킹", "파싱")와 관련된 모든 소스 파일을 찾는다. 이것이 해당 MVP의 범위를 정의하는 가장 정확한 기준이 된다.
*   **9.2. 누락 코드 생성 (Generation of Missing Code):** 만약 MVP의 핵심 기능에 필수적인 소스 파일이 누락된 경우(예: MVP 1의 `server.h`), 프로젝트 아키텍처와 다른 문서를 참고하여 해당 파일을 직접 생성한다.
*   **9.3. 문서 재설계 및 상세화 (Redesign and Detail Documentation):** 탐색 및 생성된 모든 파일을 기반으로, `DevHistoryXX.md` 문서를 완전히 새로 작성한다. 각 기능 그룹에 대한 명확한 개요와 "왜"를 설명하는 상세한 설명을 포함해야 한다.
*   **9.4. 코드-문서 완전 동기화 (Full Code-Doc Sync):** 재설계된 문서를 기준으로, 관련된 모든 소스 코드 파일에 `MVPX-Y` 형식의 새롭고 일관된 시퀀스 번호를 부여한다. 이 과정에서 기존의 모든 낡은 주석은 제거되거나 새로운 주석으로 대체된다.

---

## 버전별 목표 및 채용 시장 관점 (Version Goals & Hiring Market Perspective)

이 프로젝트는 여러 MVP(Minimum Viable Product) 단계를 통해 점진적으로 완성됩니다. 각 단계는 명확한 기술적 목표와 함께, 채용 시장에서 어떤 수준의 역량을 보여주는지에 대한 가이드를 제공합니다.

*   **MVP 0: 인프라 및 기반 구축 (Infrastructure & Foundation)**
    *   **목표:** C/C++ 프로젝트에 필요한 핵심 인프라, 빌드 시스템, 개발 환경을 구축합니다.
    *   **주요 기능:** CMake/Makefile 빌드 시스템, 초기 프로젝트 구조 정의, 버전 관리(Git) 설정.
    *   **포트폴리오 가치:** 전문적인 C/C++ 프로젝트를 처음부터 설정하고 유지보수할 수 있는 기본적인 역량을 증명합니다.

*   **MVP 1: 기본 TCP 서버 (Basic TCP Server)**
    *   **목표:** C와 C++로 각각 기본적인 TCP 서버를 구축하여 로그 메시지를 수신하는 골격을 만듭니다.
    *   **주요 기능:** C 기반 TCP 서버(`socket`, `bind`, `listen`, `accept`), C++ 기반 TCP 서버(OOP 디자인), 기본적인 클라이언트 연결 처리.
    *   **포트폴리오 가치:** 시스템 프로그래밍의 기본인 네트워크 통신을 이해하고 C와 C++로 각각 구현할 수 있음을 보여줍니다.

*   **MVP 2: 동시성 처리 (Concurrency)**
    *   **목표:** 여러 클라이언트의 로그를 동시에 처리하기 위해 스레드 풀을 구현합니다.
    *   **주요 기능:** C 기반 스레드 풀 구현, 작업 큐, 뮤텍스/조건 변수를 이용한 동기화.
    *   **포트폴리오 가치:** 멀티스레딩 환경에서의 동시성 문제를 이해하고, 성능 향상을 위한 스레드 풀을 직접 설계하고 구현할 수 있음을 증명합니다.

*   **MVP 3: 쿼리 기능 강화 (Enhanced Querying)**
    *   **목표:** 수신된 로그를 필터링하고 검색할 수 있는 간단한 쿼리 파서를 구현합니다.
    *   **주요 기능:** 문자열 토큰화, 키워드 기반 검색, 간단한 쿼리 언어 정의 및 파싱.
    *   **포트폴리오 가치:** 데이터 처리의 핵심인 파싱과 검색 기능을 구현하는 능력을 보여줍니다.

*   **MVP 4: 데이터 영속성 (Persistence)**
    *   **목표:** 서버가 재시작되어도 로그가 보존되도록 파일 기반의 영속성 기능을 추가합니다.
    *   **주요 기능:** 로그 파일 쓰기/읽기, 데이터 형식 정의, 서버 시작 시 데이터 로딩.
    *   **포트폴리오 가치:** 데이터를 안정적으로 저장하고 관리하는 능력을 증명하며, 시스템의 신뢰성을 높이는 방법을 이해하고 있음을 보여줍니다.

*   **MVP 5: 보안 강화 (Security Hardening)**
    *   **목표:** 기본적인 보안 취약점을 해결하고 서버의 안정성을 높입니다.
    *   **주요 기능:** 버퍼 오버플로우 방지, 안전한 문자열 함수 사용, 입력 값 검증.
    *   **포트폴리오 가치:** 안정적이고 보안을 고려한 코드를 작성하는 능력을 보여주며, 프로덕션 환경을 고려하는 개발자임을 어필할 수 있습니다.

*   **MVP 6: IRC 프로토콜 통합 (IRC Protocol Integration)**
    *   **목표:** 로그 조회 및 서버 관리를 위해 표준화된 IRC 프로토콜을 통합합니다.
    *   **주요 기능:** IRC 명령어 파서, 채널 기반 로그 그룹화, 사용자 관리, 실시간 응답 처리.
    *   **포트폴리오 가치:** 표준 프로토콜을 이해하고 시스템에 통합하는 능력을 보여주며, C++ OOP 설계를 통해 확장성 있는 시스템을 구축하는 역량을 증명합니다.
