# 16. ë³´ì•ˆ ë° ìš´ì˜ ğŸ”’
## ì•ˆì „í•œ ì„œë²„ ìš´ì˜ì„ ìœ„í•œ í•„ìˆ˜ ê°€ì´ë“œ

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ë‚œì´ë„**: ê³ ê¸‰ (Advanced)
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 20-25ì‹œê°„
- **í•„ìš” ì„ ìˆ˜ ì§€ì‹**: 
  - C/C++ ì¤‘ê¸‰ ì´ìƒ
  - ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ê¸°ì´ˆ
  - ì•”í˜¸í™” ê°œë…
  - Docker/Kubernetes ê¸°ì´ˆ
- **ì‹¤ìŠµ í™˜ê²½**: Linux í”„ë¡œë•ì…˜ í™˜ê²½, OpenSSL, Docker

---

## ğŸ¯ ì´ ë¬¸ì„œì—ì„œ ë°°ìš¸ ë‚´ìš©

**"í”„ë¡œë•ì…˜ ì„œë²„ë¥¼ ì•ˆì „í•˜ê²Œ ì§€í‚¤ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?"** ğŸ°

ì •ë§ ì¤‘ìš”í•œ ì§ˆë¬¸ì´ì—ìš”! í”„ë¡œë•ì…˜ ì„œë²„ ìš´ì˜ì€ ë§ˆì¹˜ **ì€í–‰ì˜ ê¸ˆê³ **ë¥¼ ê´€ë¦¬í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ê³ ê°ì˜ ì†Œì¤‘í•œ ì •ë³´(ë¡œê·¸ ë°ì´í„°)ë¥¼ ë³´í˜¸í•˜ë©´ì„œë„, í•„ìš”í•œ ì‚¬ëŒë“¤ì´ ì–¸ì œë“  ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•´ì•¼ í•˜ì£ !

ë§ˆì¹˜ **ìµœì²¨ë‹¨ ë³´ì•ˆ ì‹œì„¤**ì²˜ëŸ¼, ì—¬ëŸ¬ ê²¹ì˜ ë³´ì•ˆ ì¥ì¹˜ - ì•”í˜¸í™”, ì ‘ê·¼ ì œì–´, ëª¨ë‹ˆí„°ë§ - ê°€ ëª¨ë‘ í•¨ê»˜ ì‘ë™í•´ì•¼ í•´ìš”. ğŸ›¡ï¸

ì´ ë¬¸ì„œëŠ” LogCasterë¥¼ ë³´ì•ˆì´ ê°•í™”ëœ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ìš´ì˜í•˜ê¸° ìœ„í•œ í•µì‹¬ ë³´ì•ˆ ê¸°ìˆ ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤. ë¡œê·¸ ë°ì´í„° ì•”í˜¸í™”, ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹, ì ‘ê·¼ ì œì–´, ê°ì‚¬ ë¡œê·¸, ì»¨í…Œì´ë„ˆí™” ë° ëª¨ë‹ˆí„°ë§ ë“± ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë³´ì•ˆ ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

---

## 1. ë¡œê·¸ ë°ì´í„° ì•”í˜¸í™”

**"ë¡œê·¸ì— ì¤‘ìš”í•œ ì •ë³´ê°€ ë“¤ì–´ìˆë‹¤ë©´?"** ğŸ”

ì¢‹ì€ ê´€ì°°ì´ì—ìš”! ë¡œê·¸ëŠ” ë§ˆì¹˜ **ì¼ê¸°ì¥**ê³¼ ê°™ì•„ì„œ, ë•Œë¡œëŠ” ë¹„ë°€ìŠ¤ëŸ¬ìš´ ë‚´ìš©ë„ ë“¤ì–´ìˆì–´ìš”. ê·¸ë˜ì„œ **ì•”í˜¸ë¡œ ì ê°€ë‘ëŠ”** ê²ƒì´ í•„ìš”í•˜ì£ !

ë¡œê·¸ì—ëŠ” ë¯¼ê°í•œ ì •ë³´ê°€ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì €ì¥ ì‹œ ì•”í˜¸í™”(encryption at rest)ì™€ ì „ì†¡ ì‹œ ì•”í˜¸í™”(encryption in transit)ê°€ í•„ìš”í•©ë‹ˆë‹¤.

### AES ì•”í˜¸í™”ë¥¼ ì‚¬ìš©í•œ ë¡œê·¸ ì €ì¥ - ë””ì§€í„¸ ê¸ˆê³  ğŸ’

```cpp
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/kdf.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <memory>
#include <cstring>

class EncryptedLogWriter {
private:
    std::string key_file_path_;
    std::string log_file_path_;
    std::vector<unsigned char> encryption_key_;
    
public:
    EncryptedLogWriter(const std::string& key_file, const std::string& log_file)
        : key_file_path_(key_file), log_file_path_(log_file) {
        
        if (!loadOrGenerateKey()) {
            throw std::runtime_error("Failed to initialize encryption key");
        }
    }
    
    bool writeEncryptedLog(const std::string& log_message) {
        try {
            // ë¡œê·¸ ë©”ì‹œì§€ ì•”í˜¸í™”
            std::vector<unsigned char> encrypted_data;
            std::vector<unsigned char> iv(AES_BLOCK_SIZE);
            
            if (!encryptMessage(log_message, encrypted_data, iv)) {
                std::cerr << "Failed to encrypt log message" << std::endl;
                return false;
            }
            
            // ì•”í˜¸í™”ëœ ë°ì´í„°ë¥¼ íŒŒì¼ì— ì €ì¥
            return writeEncryptedDataToFile(encrypted_data, iv);
            
        } catch (const std::exception& e) {
            std::cerr << "Encryption error: " << e.what() << std::endl;
            return false;
        }
    }
    
    std::string readAndDecryptLog(size_t entry_index) {
        try {
            std::vector<unsigned char> encrypted_data;
            std::vector<unsigned char> iv;
            
            if (!readEncryptedDataFromFile(entry_index, encrypted_data, iv)) {
                return "";
            }
            
            return decryptMessage(encrypted_data, iv);
            
        } catch (const std::exception& e) {
            std::cerr << "Decryption error: " << e.what() << std::endl;
            return "";
        }
    }

private:
    bool loadOrGenerateKey() {
        std::ifstream key_file(key_file_path_, std::ios::binary);
        
        if (key_file.is_open()) {
            // ê¸°ì¡´ í‚¤ ë¡œë“œ
            encryption_key_.resize(32); // AES-256
            key_file.read(reinterpret_cast<char*>(encryption_key_.data()), 32);
            key_file.close();
            return true;
        } else {
            // ìƒˆ í‚¤ ìƒì„±
            return generateNewKey();
        }
    }
    
    bool generateNewKey() {
        encryption_key_.resize(32); // AES-256 í‚¤ í¬ê¸°
        
        if (RAND_bytes(encryption_key_.data(), 32) != 1) {
            std::cerr << "Failed to generate random key" << std::endl;
            return false;
        }
        
        // í‚¤ë¥¼ íŒŒì¼ì— ì €ì¥ (ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” HSMì´ë‚˜ í‚¤ ê´€ë¦¬ ì„œë¹„ìŠ¤ ì‚¬ìš©)
        std::ofstream key_file(key_file_path_, std::ios::binary);
        if (!key_file.is_open()) {
            std::cerr << "Failed to create key file" << std::endl;
            return false;
        }
        
        key_file.write(reinterpret_cast<const char*>(encryption_key_.data()), 32);
        key_file.close();
        
        // í‚¤ íŒŒì¼ ê¶Œí•œ ì„¤ì • (Unix ê³„ì—´ì—ì„œ)
        #ifndef _WIN32
        chmod(key_file_path_.c_str(), 0600); // ì†Œìœ ìë§Œ ì½ê¸°/ì“°ê¸°
        #endif
        
        return true;
    }
    
    bool encryptMessage(const std::string& plaintext, 
                       std::vector<unsigned char>& encrypted_data,
                       std::vector<unsigned char>& iv) {
        
        // IV ìƒì„±
        if (RAND_bytes(iv.data(), AES_BLOCK_SIZE) != 1) {
            return false;
        }
        
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) return false;
        
        // ì•”í˜¸í™” ì´ˆê¸°í™”
        if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, 
                              encryption_key_.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }
        
        // ì¶œë ¥ ë²„í¼ í¬ê¸° ê³„ì‚°
        int max_output_len = plaintext.length() + AES_BLOCK_SIZE;
        encrypted_data.resize(max_output_len);
        
        int len;
        int ciphertext_len = 0;
        
        // ì•”í˜¸í™” ìˆ˜í–‰
        if (EVP_EncryptUpdate(ctx, encrypted_data.data(), &len,
                             reinterpret_cast<const unsigned char*>(plaintext.c_str()),
                             plaintext.length()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }
        ciphertext_len = len;
        
        // ìµœì¢… ë¸”ë¡ ì²˜ë¦¬
        if (EVP_EncryptFinal_ex(ctx, encrypted_data.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }
        ciphertext_len += len;
        
        encrypted_data.resize(ciphertext_len);
        EVP_CIPHER_CTX_free(ctx);
        
        return true;
    }
    
    std::string decryptMessage(const std::vector<unsigned char>& encrypted_data,
                              const std::vector<unsigned char>& iv) {
        
        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) return "";
        
        // ë³µí˜¸í™” ì´ˆê¸°í™”
        if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,
                              encryption_key_.data(), iv.data()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return "";
        }
        
        std::vector<unsigned char> plaintext(encrypted_data.size() + AES_BLOCK_SIZE);
        int len;
        int plaintext_len = 0;
        
        // ë³µí˜¸í™” ìˆ˜í–‰
        if (EVP_DecryptUpdate(ctx, plaintext.data(), &len,
                             encrypted_data.data(), encrypted_data.size()) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return "";
        }
        plaintext_len = len;
        
        // ìµœì¢… ë¸”ë¡ ì²˜ë¦¬
        if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
            EVP_CIPHER_CTX_free(ctx);
            return "";
        }
        plaintext_len += len;
        
        EVP_CIPHER_CTX_free(ctx);
        
        return std::string(reinterpret_cast<char*>(plaintext.data()), plaintext_len);
    }
    
    bool writeEncryptedDataToFile(const std::vector<unsigned char>& encrypted_data,
                                 const std::vector<unsigned char>& iv) {
        
        std::ofstream file(log_file_path_, std::ios::binary | std::ios::app);
        if (!file.is_open()) return false;
        
        // í—¤ë”: IV í¬ê¸° + ë°ì´í„° í¬ê¸°
        uint32_t iv_size = iv.size();
        uint32_t data_size = encrypted_data.size();
        
        file.write(reinterpret_cast<const char*>(&iv_size), sizeof(iv_size));
        file.write(reinterpret_cast<const char*>(&data_size), sizeof(data_size));
        
        // IVì™€ ì•”í˜¸í™”ëœ ë°ì´í„° ì €ì¥
        file.write(reinterpret_cast<const char*>(iv.data()), iv.size());
        file.write(reinterpret_cast<const char*>(encrypted_data.data()), encrypted_data.size());
        
        file.close();
        return true;
    }
    
    bool readEncryptedDataFromFile(size_t entry_index,
                                  std::vector<unsigned char>& encrypted_data,
                                  std::vector<unsigned char>& iv) {
        
        std::ifstream file(log_file_path_, std::ios::binary);
        if (!file.is_open()) return false;
        
        // íŠ¹ì • ì—”íŠ¸ë¦¬ê¹Œì§€ ê±´ë„ˆë›°ê¸°
        for (size_t i = 0; i < entry_index; i++) {
            uint32_t iv_size, data_size;
            
            file.read(reinterpret_cast<char*>(&iv_size), sizeof(iv_size));
            file.read(reinterpret_cast<char*>(&data_size), sizeof(data_size));
            
            if (file.eof()) return false;
            
            file.seekg(iv_size + data_size, std::ios::cur);
        }
        
        // ëŒ€ìƒ ì—”íŠ¸ë¦¬ ì½ê¸°
        uint32_t iv_size, data_size;
        file.read(reinterpret_cast<char*>(&iv_size), sizeof(iv_size));
        file.read(reinterpret_cast<char*>(&data_size), sizeof(data_size));
        
        if (file.eof()) return false;
        
        iv.resize(iv_size);
        encrypted_data.resize(data_size);
        
        file.read(reinterpret_cast<char*>(iv.data()), iv_size);
        file.read(reinterpret_cast<char*>(encrypted_data.data()), data_size);
        
        file.close();
        return true;
    }
};
```

### TLSë¥¼ ì‚¬ìš©í•œ ë„¤íŠ¸ì›Œí¬ ë¡œê·¸ ì „ì†¡

```cpp
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

class SecureLogTransmitter {
private:
    SSL_CTX* ssl_ctx_;
    SSL* ssl_;
    int socket_fd_;
    bool connected_;

public:
    SecureLogTransmitter() : ssl_ctx_(nullptr), ssl_(nullptr), socket_fd_(-1), connected_(false) {
        SSL_load_error_strings();
        SSL_library_init();
        OpenSSL_add_all_algorithms();
    }
    
    ~SecureLogTransmitter() {
        disconnect();
        if (ssl_ctx_) {
            SSL_CTX_free(ssl_ctx_);
        }
    }
    
    bool connect(const std::string& hostname, int port, 
                const std::string& cert_file = "", 
                const std::string& key_file = "") {
        
        // SSL ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        ssl_ctx_ = SSL_CTX_new(TLS_client_method());
        if (!ssl_ctx_) {
            std::cerr << "Failed to create SSL context" << std::endl;
            return false;
        }
        
        // í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œ ì„¤ì • (ì„ íƒì )
        if (!cert_file.empty() && !key_file.empty()) {
            if (SSL_CTX_use_certificate_file(ssl_ctx_, cert_file.c_str(), SSL_FILETYPE_PEM) <= 0) {
                std::cerr << "Failed to load certificate file" << std::endl;
                return false;
            }
            
            if (SSL_CTX_use_PrivateKey_file(ssl_ctx_, key_file.c_str(), SSL_FILETYPE_PEM) <= 0) {
                std::cerr << "Failed to load private key file" << std::endl;
                return false;
            }
        }
        
        // ì†Œì¼“ ìƒì„±
        socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (socket_fd_ < 0) {
            std::cerr << "Failed to create socket" << std::endl;
            return false;
        }
        
        // ì„œë²„ì— ì—°ê²°
        struct sockaddr_in server_addr{};
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(port);
        inet_pton(AF_INET, hostname.c_str(), &server_addr.sin_addr);
        
        if (::connect(socket_fd_, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            std::cerr << "Failed to connect to server" << std::endl;
            close(socket_fd_);
            return false;
        }
        
        // SSL ì—°ê²° ì„¤ì •
        ssl_ = SSL_new(ssl_ctx_);
        SSL_set_fd(ssl_, socket_fd_);
        
        if (SSL_connect(ssl_) <= 0) {
            std::cerr << "SSL connection failed" << std::endl;
            ERR_print_errors_fp(stderr);
            return false;
        }
        
        connected_ = true;
        std::cout << "Secure connection established with " << hostname << ":" << port << std::endl;
        
        // ì„œë²„ ì¸ì¦ì„œ ê²€ì¦
        if (!verifyCertificate(hostname)) {
            std::cerr << "Certificate verification failed" << std::endl;
            disconnect();
            return false;
        }
        
        return true;
    }
    
    bool sendLog(const std::string& log_message) {
        if (!connected_ || !ssl_) {
            std::cerr << "Not connected to server" << std::endl;
            return false;
        }
        
        // ë©”ì‹œì§€ ê¸¸ì´ + ë©”ì‹œì§€ ì „ì†¡
        uint32_t message_length = log_message.length();
        
        if (SSL_write(ssl_, &message_length, sizeof(message_length)) <= 0) {
            std::cerr << "Failed to send message length" << std::endl;
            return false;
        }
        
        if (SSL_write(ssl_, log_message.c_str(), message_length) <= 0) {
            std::cerr << "Failed to send log message" << std::endl;
            return false;
        }
        
        return true;
    }
    
    void disconnect() {
        if (ssl_) {
            SSL_shutdown(ssl_);
            SSL_free(ssl_);
            ssl_ = nullptr;
        }
        
        if (socket_fd_ >= 0) {
            close(socket_fd_);
            socket_fd_ = -1;
        }
        
        connected_ = false;
    }

private:
    bool verifyCertificate(const std::string& expected_hostname) {
        X509* cert = SSL_get_peer_certificate(ssl_);
        if (!cert) {
            std::cerr << "No peer certificate" << std::endl;
            return false;
        }
        
        // ì¸ì¦ì„œ ê²€ì¦ (ê°„ì†Œí™”ëœ ì˜ˆì œ)
        long verify_result = SSL_get_verify_result(ssl_);
        if (verify_result != X509_V_OK) {
            std::cerr << "Certificate verification failed: " << verify_result << std::endl;
            X509_free(cert);
            return false;
        }
        
        // í˜¸ìŠ¤íŠ¸ëª… ê²€ì¦ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ ê²€ì¦ í•„ìš”)
        char* subject_name = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
        std::cout << "Server certificate subject: " << subject_name << std::endl;
        
        OPENSSL_free(subject_name);
        X509_free(cert);
        
        return true;
    }
};
```

---

## 2. ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹ê³¼ ë°ì´í„° ë³´í˜¸

ë¡œê·¸ì—ì„œ ê°œì¸ì •ë³´, íŒ¨ìŠ¤ì›Œë“œ, API í‚¤ ë“±ì˜ ë¯¼ê°í•œ ì •ë³´ë¥¼ ìë™ìœ¼ë¡œ ë§ˆìŠ¤í‚¹í•´ì•¼ í•©ë‹ˆë‹¤.

### ì •ê·œì‹ ê¸°ë°˜ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹

```cpp
#include <regex>
#include <unordered_map>
#include <string>

class SensitiveDataMasker {
private:
    struct MaskingRule {
        std::regex pattern;
        std::string replacement;
        std::string description;
        
        MaskingRule(const std::string& regex_pattern, 
                   const std::string& repl, 
                   const std::string& desc)
            : pattern(regex_pattern), replacement(repl), description(desc) {}
    };
    
    std::vector<MaskingRule> masking_rules_;

public:
    SensitiveDataMasker() {
        initializeDefaultRules();
    }
    
    std::string maskSensitiveData(const std::string& log_message) {
        std::string masked_message = log_message;
        
        for (const auto& rule : masking_rules_) {
            try {
                masked_message = std::regex_replace(masked_message, rule.pattern, rule.replacement);
            } catch (const std::regex_error& e) {
                std::cerr << "Regex error in rule '" << rule.description << "': " << e.what() << std::endl;
            }
        }
        
        return masked_message;
    }
    
    void addCustomRule(const std::string& pattern, 
                      const std::string& replacement,
                      const std::string& description) {
        try {
            masking_rules_.emplace_back(pattern, replacement, description);
            std::cout << "Added masking rule: " << description << std::endl;
        } catch (const std::regex_error& e) {
            std::cerr << "Invalid regex pattern: " << e.what() << std::endl;
        }
    }
    
    void listRules() {
        std::cout << "\n=== Active Masking Rules ===" << std::endl;
        for (size_t i = 0; i < masking_rules_.size(); i++) {
            std::cout << i + 1 << ". " << masking_rules_[i].description << std::endl;
        }
    }

private:
    void initializeDefaultRules() {
        // ì´ë©”ì¼ ì£¼ì†Œ ë§ˆìŠ¤í‚¹
        addCustomRule(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})",
                     "***@***.***", "Email addresses");
        
        // ì „í™”ë²ˆí˜¸ ë§ˆìŠ¤í‚¹ (ë‹¤ì–‘í•œ í˜•ì‹)
        addCustomRule(R"(\b\d{3}-\d{3,4}-\d{4}\b)",
                     "***-***-****", "Phone numbers (xxx-xxx-xxxx)");
        
        addCustomRule(R"(\b\d{3}\.\d{3,4}\.\d{4}\b)",
                     "***.***.****", "Phone numbers (xxx.xxx.xxxx)");
        
        // ì‹ ìš©ì¹´ë“œ ë²ˆí˜¸ ë§ˆìŠ¤í‚¹
        addCustomRule(R"(\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b)",
                     "****-****-****-****", "Credit card numbers");
        
        // ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸ ë§ˆìŠ¤í‚¹ (í•œêµ­)
        addCustomRule(R"(\b\d{6}-\d{7}\b)",
                     "******-*******", "Korean SSN");
        
        // IP ì£¼ì†Œ ë¶€ë¶„ ë§ˆìŠ¤í‚¹
        addCustomRule(R"(\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.)\d{1,3}\b)",
                     "$1***", "IP addresses");
        
        // íŒ¨ìŠ¤ì›Œë“œ í•„ë“œ ë§ˆìŠ¤í‚¹
        addCustomRule(R"((password|pwd|pass|secret|key)\s*[:=]\s*[\"']?([^\"'\s,}]+)[\"']?)",
                     "$1=***", "Password fields", std::regex_constants::icase);
        
        // API í‚¤ íŒ¨í„´ ë§ˆìŠ¤í‚¹
        addCustomRule(R"((api[_-]?key|access[_-]?token|bearer)\s*[:=]\s*[\"']?([A-Za-z0-9+/=]{20,})[\"']?)",
                     "$1=***", "API keys and tokens", std::regex_constants::icase);
        
        // URLì˜ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ì—ì„œ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹
        addCustomRule(R"(([?&](password|token|key|secret)=)[^&\s]+)",
                     "$1***", "URL query parameters");
        
        // JSON í•„ë“œì—ì„œ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹
        addCustomRule(R"(("(?:password|secret|token|key|credential)"\s*:\s*")[^"]+(")",
                     "$1***$2", "JSON sensitive fields", std::regex_constants::icase);
    }
    
    void addCustomRule(const std::string& pattern, 
                      const std::string& replacement,
                      const std::string& description,
                      std::regex_constants::syntax_option_type flags = std::regex_constants::ECMAScript) {
        try {
            masking_rules_.emplace_back(std::regex(pattern, flags), replacement, description);
        } catch (const std::regex_error& e) {
            std::cerr << "Failed to add rule '" << description << "': " << e.what() << std::endl;
        }
    }
};

// ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ ë§ˆìŠ¤í‚¹
class ContextAwareMasker {
private:
    SensitiveDataMasker base_masker_;
    std::unordered_map<std::string, std::vector<std::string>> context_patterns_;

public:
    ContextAwareMasker() {
        initializeContextPatterns();
    }
    
    std::string maskWithContext(const std::string& log_message, const std::string& context = "") {
        std::string masked = base_masker_.maskSensitiveData(log_message);
        
        // ì»¨í…ìŠ¤íŠ¸ë³„ ì¶”ê°€ ë§ˆìŠ¤í‚¹
        if (!context.empty() && context_patterns_.count(context)) {
            for (const auto& pattern : context_patterns_[context]) {
                try {
                    std::regex context_regex(pattern);
                    masked = std::regex_replace(masked, context_regex, "***");
                } catch (const std::regex_error& e) {
                    std::cerr << "Context regex error: " << e.what() << std::endl;
                }
            }
        }
        
        return masked;
    }
    
    void addContextPattern(const std::string& context, const std::string& pattern) {
        context_patterns_[context].push_back(pattern);
    }

private:
    void initializeContextPatterns() {
        // ë°ì´í„°ë² ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸
        context_patterns_["database"] = {
            R"(INSERT INTO \w+ \([^)]+\) VALUES \([^)]+\))", // INSERT ì¿¼ë¦¬ì˜ ê°’ë“¤
            R"(UPDATE \w+ SET [^W]+ WHERE)", // UPDATE ì¿¼ë¦¬ì˜ SET ì ˆ
        };
        
        // HTTP ì»¨í…ìŠ¤íŠ¸
        context_patterns_["http"] = {
            R"(Authorization: [^\r\n]+)", // Authorization í—¤ë”
            R"(Cookie: [^\r\n]+)", // Cookie í—¤ë”
        };
        
        // íŒŒì¼ ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸
        context_patterns_["filesystem"] = {
            R"(/home/[^/\s]+)", // ì‚¬ìš©ì í™ˆ ë””ë ‰í„°ë¦¬ ê²½ë¡œ
            R"(C:\\Users\\[^\\s]+)", // Windows ì‚¬ìš©ì ë””ë ‰í„°ë¦¬
        };
    }
};

// ì‚¬ìš© ì˜ˆì œ
int main() {
    ContextAwareMasker masker;
    
    // í…ŒìŠ¤íŠ¸ ë¡œê·¸ ë©”ì‹œì§€ë“¤
    std::vector<std::pair<std::string, std::string>> test_cases = {
        {"User login failed for email: john.doe@example.com", ""},
        {"Database query: INSERT INTO users (email, password) VALUES ('user@test.com', 'secret123')", "database"},
        {"HTTP request: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9", "http"},
        {"Credit card payment: 4532-1234-5678-9012 charged $99.99", ""},
        {"API call with key: api_key=abc123def456ghi789", ""},
        {"User data: {\"email\":\"test@example.com\",\"password\":\"mypassword\"}", ""},
        {"Phone verification: 010-1234-5678", ""},
        {"Access from IP: 192.168.1.100", ""}
    };
    
    std::cout << "=== Sensitive Data Masking Test ===" << std::endl;
    
    for (const auto& test_case : test_cases) {
        std::cout << "\nOriginal: " << test_case.first << std::endl;
        std::cout << "Masked:   " << masker.maskWithContext(test_case.first, test_case.second) << std::endl;
    }
    
    return 0;
}
```

---

## 3. ì ‘ê·¼ ì œì–´ì™€ ì¸ì¦

ë¡œê·¸ ì‹œìŠ¤í…œì— ëŒ€í•œ ì ‘ê·¼ì„ ì œì–´í•˜ê³  ì‚¬ìš©ìë¥¼ ì¸ì¦í•´ì•¼ í•©ë‹ˆë‹¤.

### ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (RBAC)

```cpp
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <vector>
#include <chrono>

enum class Permission {
    READ_LOGS,
    WRITE_LOGS,
    DELETE_LOGS,
    CONFIGURE_SYSTEM,
    MANAGE_USERS,
    VIEW_METRICS,
    EXPORT_LOGS
};

enum class LogLevel {
    DEBUG, INFO, WARN, ERROR, FATAL
};

class Role {
private:
    std::string name_;
    std::unordered_set<Permission> permissions_;
    std::unordered_set<std::string> allowed_log_categories_;
    LogLevel min_log_level_;

public:
    Role(const std::string& name, LogLevel min_level = LogLevel::DEBUG)
        : name_(name), min_log_level_(min_level) {}
    
    void addPermission(Permission perm) {
        permissions_.insert(perm);
    }
    
    void addLogCategory(const std::string& category) {
        allowed_log_categories_.insert(category);
    }
    
    bool hasPermission(Permission perm) const {
        return permissions_.count(perm) > 0;
    }
    
    bool canAccessLogCategory(const std::string& category) const {
        return allowed_log_categories_.empty() || allowed_log_categories_.count(category) > 0;
    }
    
    bool canAccessLogLevel(LogLevel level) const {
        return static_cast<int>(level) >= static_cast<int>(min_log_level_);
    }
    
    const std::string& getName() const { return name_; }
};

class User {
private:
    std::string username_;
    std::string password_hash_;
    std::vector<Role> roles_;
    std::chrono::system_clock::time_point last_login_;
    bool active_;

public:
    User(const std::string& username, const std::string& password_hash)
        : username_(username), password_hash_(password_hash), active_(true) {}
    
    void addRole(const Role& role) {
        roles_.push_back(role);
    }
    
    bool hasPermission(Permission perm) const {
        if (!active_) return false;
        
        for (const auto& role : roles_) {
            if (role.hasPermission(perm)) {
                return true;
            }
        }
        return false;
    }
    
    bool canAccessLog(const std::string& category, LogLevel level) const {
        if (!active_) return false;
        
        for (const auto& role : roles_) {
            if (role.canAccessLogCategory(category) && role.canAccessLogLevel(level)) {
                return true;
            }
        }
        return false;
    }
    
    void updateLastLogin() {
        last_login_ = std::chrono::system_clock::now();
    }
    
    const std::string& getUsername() const { return username_; }
    bool isActive() const { return active_; }
    void setActive(bool active) { active_ = active; }
    
    // ê°„ë‹¨í•œ íŒ¨ìŠ¤ì›Œë“œ ê²€ì¦ (ì‹¤ì œë¡œëŠ” bcrypt ë“± ì‚¬ìš©)
    bool verifyPassword(const std::string& password) const {
        return password_hash_ == std::to_string(std::hash<std::string>{}(password));
    }
};

class AccessControlManager {
private:
    std::unordered_map<std::string, User> users_;
    std::unordered_map<std::string, Role> roles_;
    std::unordered_map<std::string, std::chrono::system_clock::time_point> active_sessions_;

public:
    AccessControlManager() {
        initializeDefaultRoles();
        initializeDefaultUsers();
    }
    
    // ì‚¬ìš©ì ì¸ì¦
    std::string authenticate(const std::string& username, const std::string& password) {
        auto user_it = users_.find(username);
        if (user_it == users_.end() || !user_it->second.isActive()) {
            logSecurityEvent("Failed login attempt for user: " + username);
            return "";
        }
        
        if (!user_it->second.verifyPassword(password)) {
            logSecurityEvent("Invalid password for user: " + username);
            return "";
        }
        
        // ì„¸ì…˜ í† í° ìƒì„± (ê°„ì†Œí™”)
        std::string session_token = generateSessionToken(username);
        active_sessions_[session_token] = std::chrono::system_clock::now();
        
        user_it->second.updateLastLogin();
        logSecurityEvent("Successful login for user: " + username);
        
        return session_token;
    }
    
    // ê¶Œí•œ í™•ì¸
    bool authorize(const std::string& session_token, Permission permission) {
        User* user = getUserFromSession(session_token);
        if (!user) return false;
        
        bool authorized = user->hasPermission(permission);
        
        if (!authorized) {
            logSecurityEvent("Unauthorized access attempt by user: " + user->getUsername() +
                           " for permission: " + std::to_string(static_cast<int>(permission)));
        }
        
        return authorized;
    }
    
    // ë¡œê·¸ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    bool authorizeLogAccess(const std::string& session_token, 
                           const std::string& log_category, 
                           LogLevel log_level) {
        User* user = getUserFromSession(session_token);
        if (!user) return false;
        
        bool authorized = user->canAccessLog(log_category, log_level);
        
        if (!authorized) {
            logSecurityEvent("Unauthorized log access attempt by user: " + user->getUsername() +
                           " for category: " + log_category + 
                           " level: " + std::to_string(static_cast<int>(log_level)));
        }
        
        return authorized;
    }
    
    // ì„¸ì…˜ ë¬´íš¨í™”
    void logout(const std::string& session_token) {
        auto session_it = active_sessions_.find(session_token);
        if (session_it != active_sessions_.end()) {
            User* user = getUserFromSession(session_token);
            if (user) {
                logSecurityEvent("User logged out: " + user->getUsername());
            }
            active_sessions_.erase(session_it);
        }
    }
    
    // ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬
    void cleanupExpiredSessions() {
        auto now = std::chrono::system_clock::now();
        auto session_timeout = std::chrono::hours(24);
        
        for (auto it = active_sessions_.begin(); it != active_sessions_.end();) {
            if (now - it->second > session_timeout) {
                logSecurityEvent("Session expired: " + it->first);
                it = active_sessions_.erase(it);
            } else {
                ++it;
            }
        }
    }

private:
    void initializeDefaultRoles() {
        // ê´€ë¦¬ì ì—­í• 
        Role admin_role("admin");
        admin_role.addPermission(Permission::READ_LOGS);
        admin_role.addPermission(Permission::WRITE_LOGS);
        admin_role.addPermission(Permission::DELETE_LOGS);
        admin_role.addPermission(Permission::CONFIGURE_SYSTEM);
        admin_role.addPermission(Permission::MANAGE_USERS);
        admin_role.addPermission(Permission::VIEW_METRICS);
        admin_role.addPermission(Permission::EXPORT_LOGS);
        roles_["admin"] = admin_role;
        
        // ê°œë°œì ì—­í• 
        Role developer_role("developer", LogLevel::DEBUG);
        developer_role.addPermission(Permission::READ_LOGS);
        developer_role.addPermission(Permission::WRITE_LOGS);
        developer_role.addPermission(Permission::VIEW_METRICS);
        developer_role.addLogCategory("APPLICATION");
        developer_role.addLogCategory("DEBUG");
        roles_["developer"] = developer_role;
        
        // ìš´ì˜ì ì—­í• 
        Role operator_role("operator", LogLevel::INFO);
        operator_role.addPermission(Permission::READ_LOGS);
        operator_role.addPermission(Permission::VIEW_METRICS);
        operator_role.addLogCategory("SYSTEM");
        operator_role.addLogCategory("SECURITY");
        roles_["operator"] = operator_role;
        
        // ê°ì‚¬ì ì—­í• 
        Role auditor_role("auditor", LogLevel::WARN);
        auditor_role.addPermission(Permission::READ_LOGS);
        auditor_role.addPermission(Permission::EXPORT_LOGS);
        auditor_role.addLogCategory("SECURITY");
        auditor_role.addLogCategory("AUDIT");
        roles_["auditor"] = auditor_role;
    }
    
    void initializeDefaultUsers() {
        // ê¸°ë³¸ ê´€ë¦¬ì ê³„ì • (ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì´ˆê¸° ì„¤ì • í›„ ë³€ê²½)
        User admin("admin", std::to_string(std::hash<std::string>{}("admin123")));
        admin.addRole(roles_["admin"]);
        users_["admin"] = admin;
        
        // ê°œë°œì ê³„ì •
        User developer("developer", std::to_string(std::hash<std::string>{}("dev123")));
        developer.addRole(roles_["developer"]);
        users_["developer"] = developer;
        
        // ìš´ì˜ì ê³„ì •
        User operator_user("operator", std::to_string(std::hash<std::string>{}("ops123")));
        operator_user.addRole(roles_["operator"]);
        users_["operator"] = operator_user;
    }
    
    std::string generateSessionToken(const std::string& username) {
        // ì‹¤ì œë¡œëŠ” JWTë‚˜ ë” ì•ˆì „í•œ í† í° ìƒì„± ë°©ì‹ ì‚¬ìš©
        auto now = std::chrono::system_clock::now().time_since_epoch().count();
        return username + "_" + std::to_string(now);
    }
    
    User* getUserFromSession(const std::string& session_token) {
        if (active_sessions_.find(session_token) == active_sessions_.end()) {
            return nullptr;
        }
        
        // ì„¸ì…˜ í† í°ì—ì„œ ì‚¬ìš©ìëª… ì¶”ì¶œ (ê°„ì†Œí™”)
        size_t pos = session_token.find('_');
        if (pos == std::string::npos) return nullptr;
        
        std::string username = session_token.substr(0, pos);
        auto user_it = users_.find(username);
        
        return (user_it != users_.end()) ? &user_it->second : nullptr;
    }
    
    void logSecurityEvent(const std::string& event) {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        std::cout << "[SECURITY] " << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S")
                  << " " << event << std::endl;
    }
};
```

---

## 4. ê°ì‚¬ ë¡œê·¸ì™€ ì¶”ì ì„±

ì‹œìŠ¤í…œì˜ ëª¨ë“  ì¤‘ìš”í•œ í™œë™ì„ ì¶”ì í•˜ê³  ê°ì‚¬í•  ìˆ˜ ìˆë„ë¡ ë³„ë„ì˜ ê°ì‚¬ ë¡œê·¸ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

### ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ

```cpp
#include <nlohmann/json.hpp>
#include <fstream>
#include <mutex>
#include <thread>
#include <queue>

using json = nlohmann::json;

enum class AuditEventType {
    USER_LOGIN,
    USER_LOGOUT,
    LOG_ACCESS,
    LOG_EXPORT,
    CONFIGURATION_CHANGE,
    SYSTEM_START,
    SYSTEM_STOP,
    SECURITY_VIOLATION,
    DATA_MODIFICATION,
    PRIVILEGED_ACTION
};

struct AuditEvent {
    AuditEventType type;
    std::string user_id;
    std::string session_id;
    std::string resource;
    std::string action;
    std::string details;
    std::chrono::system_clock::time_point timestamp;
    std::string source_ip;
    std::string user_agent;
    bool success;
    
    AuditEvent(AuditEventType t, const std::string& user, const std::string& session)
        : type(t), user_id(user), session_id(session), 
          timestamp(std::chrono::system_clock::now()), success(true) {}
};

class AuditLogger {
private:
    std::queue<AuditEvent> audit_queue_;
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    std::thread processing_thread_;
    std::atomic<bool> running_{true};
    
    std::string audit_log_file_;
    EncryptedLogWriter encrypted_writer_;
    
    // ì„±ëŠ¥ í†µê³„
    std::atomic<int> events_processed_{0};
    std::atomic<int> events_failed_{0};

public:
    AuditLogger(const std::string& audit_file, const std::string& key_file)
        : audit_log_file_(audit_file)
        , encrypted_writer_(key_file, audit_file) {
        
        processing_thread_ = std::thread(&AuditLogger::processAuditEvents, this);
        
        // ì‹œìŠ¤í…œ ì‹œì‘ ì´ë²¤íŠ¸ ê¸°ë¡
        logSystemEvent(AuditEventType::SYSTEM_START, "system", "", "LogCaster audit system started");
    }
    
    ~AuditLogger() {
        logSystemEvent(AuditEventType::SYSTEM_STOP, "system", "", "LogCaster audit system stopping");
        
        running_ = false;
        queue_cv_.notify_all();
        
        if (processing_thread_.joinable()) {
            processing_thread_.join();
        }
    }
    
    // ì‚¬ìš©ì í™œë™ ê°ì‚¬
    void logUserActivity(AuditEventType type, const std::string& user_id, 
                        const std::string& session_id, const std::string& details,
                        bool success = true, const std::string& source_ip = "") {
        
        AuditEvent event(type, user_id, session_id);
        event.details = details;
        event.success = success;
        event.source_ip = source_ip;
        
        enqueueAuditEvent(event);
    }
    
    // ë¡œê·¸ ì ‘ê·¼ ê°ì‚¬
    void logLogAccess(const std::string& user_id, const std::string& session_id,
                     const std::string& log_category, const std::string& query_details,
                     int records_accessed, bool success = true) {
        
        AuditEvent event(AuditEventType::LOG_ACCESS, user_id, session_id);
        event.resource = log_category;
        event.action = "READ";
        event.success = success;
        
        json details = {
            {"query", query_details},
            {"records_accessed", records_accessed},
            {"category", log_category}
        };
        event.details = details.dump();
        
        enqueueAuditEvent(event);
    }
    
    // ì„¤ì • ë³€ê²½ ê°ì‚¬
    void logConfigurationChange(const std::string& user_id, const std::string& session_id,
                               const std::string& config_key, const std::string& old_value,
                               const std::string& new_value) {
        
        AuditEvent event(AuditEventType::CONFIGURATION_CHANGE, user_id, session_id);
        event.resource = config_key;
        event.action = "MODIFY";
        
        json details = {
            {"config_key", config_key},
            {"old_value", old_value},
            {"new_value", new_value}
        };
        event.details = details.dump();
        
        enqueueAuditEvent(event);
    }
    
    // ë³´ì•ˆ ìœ„ë°˜ ê°ì‚¬
    void logSecurityViolation(const std::string& user_id, const std::string& session_id,
                             const std::string& violation_type, const std::string& details,
                             const std::string& source_ip = "") {
        
        AuditEvent event(AuditEventType::SECURITY_VIOLATION, user_id, session_id);
        event.action = violation_type;
        event.details = details;
        event.success = false;
        event.source_ip = source_ip;
        
        enqueueAuditEvent(event);
    }
    
    // ë°ì´í„° ìˆ˜ì • ê°ì‚¬
    void logDataModification(const std::string& user_id, const std::string& session_id,
                            const std::string& table_or_resource, const std::string& operation,
                            const std::string& record_id, const json& changes) {
        
        AuditEvent event(AuditEventType::DATA_MODIFICATION, user_id, session_id);
        event.resource = table_or_resource;
        event.action = operation;
        
        json details = {
            {"operation", operation},
            {"record_id", record_id},
            {"changes", changes}
        };
        event.details = details.dump();
        
        enqueueAuditEvent(event);
    }
    
    // ê°ì‚¬ ë¡œê·¸ í†µê³„
    void printAuditStatistics() {
        std::cout << "\n=== Audit Log Statistics ===" << std::endl;
        std::cout << "Events processed: " << events_processed_ << std::endl;
        std::cout << "Events failed: " << events_failed_ << std::endl;
        std::cout << "Queue size: " << getQueueSize() << std::endl;
    }

private:
    void enqueueAuditEvent(const AuditEvent& event) {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        audit_queue_.push(event);
        queue_cv_.notify_one();
    }
    
    void processAuditEvents() {
        while (running_) {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            
            queue_cv_.wait(lock, [this] { 
                return !audit_queue_.empty() || !running_; 
            });
            
            while (!audit_queue_.empty()) {
                AuditEvent event = audit_queue_.front();
                audit_queue_.pop();
                lock.unlock();
                
                if (writeAuditEvent(event)) {
                    events_processed_++;
                } else {
                    events_failed_++;
                }
                
                lock.lock();
            }
        }
    }
    
    bool writeAuditEvent(const AuditEvent& event) {
        try {
            json audit_record = createAuditRecord(event);
            std::string audit_line = audit_record.dump();
            
            return encrypted_writer_.writeEncryptedLog(audit_line);
            
        } catch (const std::exception& e) {
            std::cerr << "Failed to write audit event: " << e.what() << std::endl;
            return false;
        }
    }
    
    json createAuditRecord(const AuditEvent& event) {
        auto time_t = std::chrono::system_clock::to_time_t(event.timestamp);
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            event.timestamp.time_since_epoch()) % 1000;
        
        std::stringstream timestamp_ss;
        timestamp_ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
        timestamp_ss << "." << std::setfill('0') << std::setw(3) << ms.count() << "Z";
        
        json audit_record = {
            {"timestamp", timestamp_ss.str()},
            {"event_type", eventTypeToString(event.type)},
            {"user_id", event.user_id},
            {"session_id", event.session_id},
            {"resource", event.resource},
            {"action", event.action},
            {"success", event.success},
            {"source_ip", event.source_ip},
            {"user_agent", event.user_agent},
            {"details", event.details.empty() ? json::object() : json::parse(event.details)},
            {"audit_id", generateAuditId()},
            {"system_info", {
                {"hostname", getHostname()},
                {"process_id", getCurrentPid()}
            }}
        };
        
        return audit_record;
    }
    
    std::string eventTypeToString(AuditEventType type) {
        switch (type) {
            case AuditEventType::USER_LOGIN: return "USER_LOGIN";
            case AuditEventType::USER_LOGOUT: return "USER_LOGOUT";
            case AuditEventType::LOG_ACCESS: return "LOG_ACCESS";
            case AuditEventType::LOG_EXPORT: return "LOG_EXPORT";
            case AuditEventType::CONFIGURATION_CHANGE: return "CONFIGURATION_CHANGE";
            case AuditEventType::SYSTEM_START: return "SYSTEM_START";
            case AuditEventType::SYSTEM_STOP: return "SYSTEM_STOP";
            case AuditEventType::SECURITY_VIOLATION: return "SECURITY_VIOLATION";
            case AuditEventType::DATA_MODIFICATION: return "DATA_MODIFICATION";
            case AuditEventType::PRIVILEGED_ACTION: return "PRIVILEGED_ACTION";
            default: return "UNKNOWN";
        }
    }
    
    std::string generateAuditId() {
        // UUID ìƒì„± (ê°„ì†Œí™”)
        auto now = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        return "audit_" + std::to_string(now);
    }
    
    void logSystemEvent(AuditEventType type, const std::string& user_id, 
                       const std::string& session_id, const std::string& details) {
        AuditEvent event(type, user_id, session_id);
        event.details = details;
        enqueueAuditEvent(event);
    }
    
    size_t getQueueSize() {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        return audit_queue_.size();
    }
    
    std::string getHostname() {
        char hostname[256];
        if (gethostname(hostname, sizeof(hostname)) == 0) {
            return std::string(hostname);
        }
        return "unknown";
    }
    
    int getCurrentPid() {
        #ifdef _WIN32
            return GetCurrentProcessId();
        #else
            return getpid();
        #endif
    }
};
```

---

## 5. ì»¨í…Œì´ë„ˆí™”ì™€ ìš´ì˜

### Dockerë¥¼ ì‚¬ìš©í•œ ì»¨í…Œì´ë„ˆí™”

```dockerfile
# Dockerfile
FROM ubuntu:22.04

# í•„ìš”í•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    libssl-dev \
    libcurl4-openssl-dev \
    nlohmann-json3-dev \
    && rm -rf /var/lib/apt/lists/*

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë””ë ‰í† ë¦¬ ìƒì„±
WORKDIR /app

# ì†ŒìŠ¤ ì½”ë“œ ë³µì‚¬
COPY src/ ./src/
COPY include/ ./include/
COPY CMakeLists.txt .

# ë¹Œë“œ
RUN mkdir build && cd build && \
    cmake .. -DCMAKE_BUILD_TYPE=Release && \
    make -j$(nproc)

# ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
RUN mkdir -p /var/log/logcaster

# ë³´ì•ˆì„ ìœ„í•œ ì‚¬ìš©ì ìƒì„±
RUN useradd -r -s /bin/false logcaster && \
    chown -R logcaster:logcaster /app /var/log/logcaster

# ì„¤ì • íŒŒì¼ ë³µì‚¬
COPY config/ ./config/

# í—¬ìŠ¤ì²´í¬ ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
COPY scripts/healthcheck.sh /healthcheck.sh
RUN chmod +x /healthcheck.sh

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080 8443

# í—¬ìŠ¤ì²´í¬ ì„¤ì •
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD /healthcheck.sh

# ì‚¬ìš©ì ë³€ê²½
USER logcaster

# ì‹œì‘ ëª…ë ¹ì–´
CMD ["./build/logcaster", "--config", "./config/production.conf"]
```

```bash
#!/bin/bash
# scripts/healthcheck.sh
# LogCaster í—¬ìŠ¤ì²´í¬ ìŠ¤í¬ë¦½íŠ¸

# HTTP í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ í™•ì¸
HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)

if [ "$HTTP_RESPONSE" != "200" ]; then
    echo "HTTP health check failed: $HTTP_RESPONSE"
    exit 1
fi

# ë¡œê·¸ íŒŒì¼ ì“°ê¸° ê¶Œí•œ í™•ì¸
if [ ! -w /var/log/logcaster ]; then
    echo "Log directory not writable"
    exit 1
fi

# í”„ë¡œì„¸ìŠ¤ í™•ì¸
if ! pgrep -x "logcaster" > /dev/null; then
    echo "LogCaster process not running"
    exit 1
fi

echo "Health check passed"
exit 0
```

### Docker Compose ì„¤ì •

```yaml
# docker-compose.yml
version: '3.8'

services:
  logcaster:
    build: .
    container_name: logcaster-server
    restart: unless-stopped
    ports:
      - "8080:8080"
      - "8443:8443"
    volumes:
      - logcaster-data:/var/log/logcaster
      - logcaster-config:/app/config
      - ./ssl:/app/ssl:ro
    environment:
      - LOG_LEVEL=INFO
      - MAX_CONNECTIONS=1000
      - ENCRYPTION_ENABLED=true
    networks:
      - logcaster-network
    depends_on:
      - redis
      - elasticsearch
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    user: "1000:1000"

  redis:
    image: redis:7-alpine
    container_name: logcaster-redis
    restart: unless-stopped
    volumes:
      - redis-data:/data
    networks:
      - logcaster-network
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}

  elasticsearch:
    image: elasticsearch:8.11.0
    container_name: logcaster-elasticsearch
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=true
      - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    networks:
      - logcaster-network
    ulimits:
      memlock:
        soft: -1
        hard: -1

  prometheus:
    image: prom/prometheus:latest
    container_name: logcaster-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    networks:
      - logcaster-network
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

  grafana:
    image: grafana/grafana:latest
    container_name: logcaster-grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    networks:
      - logcaster-network

volumes:
  logcaster-data:
  logcaster-config:
  redis-data:
  elasticsearch-data:
  prometheus-data:
  grafana-data:

networks:
  logcaster-network:
    driver: bridge
```

### ëª¨ë‹ˆí„°ë§ ì„¤ì •

```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

scrape_configs:
  - job_name: 'logcaster'
    static_configs:
      - targets: ['logcaster:8080']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']

  - job_name: 'elasticsearch'
    static_configs:
      - targets: ['elasticsearch:9200']

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093
```

---

## ğŸ”¥ 6. í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë°©ë²•

### 6.1 ì•”í˜¸í™” ê´€ë ¨ ì‹¤ìˆ˜

#### [SEQUENCE: 45] í‚¤ ê´€ë¦¬ ì†Œí™€
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: í•˜ë“œì½”ë”©ëœ í‚¤
const char* ENCRYPTION_KEY = "mysecretkey123";

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í™˜ê²½ë³€ìˆ˜ ë˜ëŠ” í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ
const char* key = getenv("LOGCRAFTER_ENCRYPTION_KEY");
if (!key) {
    // HSM ë˜ëŠ” í‚¤ ê´€ë¦¬ ì„œë¹„ìŠ¤ì—ì„œ ê°€ì ¸ì˜¤ê¸°
    key = loadKeyFromHSM();
}
```

### 6.2 ì ‘ê·¼ ì œì–´ ì‹¤ìˆ˜

#### [SEQUENCE: 46] ê¶Œí•œ ìƒìŠ¹ ìœ„í—˜
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ì„¸ì…˜ ê²€ì¦ë§Œìœ¼ë¡œ ê¶Œí•œ ë¶€ì—¬
bool checkPermission(const std::string& session) {
    return isValidSession(session);  // ê¶Œí•œ í™•ì¸ ì—†ìŒ
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ì„¸ì…˜ + ê¶Œí•œ ê²€ì¦
bool checkPermission(const std::string& session, Permission perm) {
    if (!isValidSession(session)) return false;
    User* user = getUserFromSession(session);
    return user && user->hasPermission(perm);
}
```

### 6.3 ê°ì‚¬ ë¡œê·¸ ì‹¤ìˆ˜

#### [SEQUENCE: 47] ê°ì‚¬ ë¡œê·¸ ëˆ„ë½
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ì˜ˆì™¸ ì‹œ ê°ì‚¬ ë¡œê·¸ ëˆ„ë½
void performSensitiveOperation() {
    try {
        // ì‘ì—… ìˆ˜í–‰
        doOperation();
        logAudit("Operation completed");
    } catch (...) {
        // ê°ì‚¬ ë¡œê·¸ ì—†ì´ ì˜ˆì™¸ ì²˜ë¦¬
        throw;
    }
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í•­ìƒ ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
void performSensitiveOperation() {
    bool success = false;
    try {
        doOperation();
        success = true;
    } catch (const std::exception& e) {
        logAudit("Operation failed", false, e.what());
        throw;
    }
    if (success) {
        logAudit("Operation completed", true);
    }
}
```

---

## 7. ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ê¸°ë³¸ ë³´ì•ˆ ë¡œê±° (ê¸°ì´ˆ)
**ëª©í‘œ**: ì•”í˜¸í™”ì™€ ê¸°ë³¸ ì¸ì¦ì„ ê°–ì¶˜ ë¡œê±°

**êµ¬í˜„ ì‚¬í•­**:
- AES-256 ë¡œê·¸ ì•”í˜¸í™”
- ê¸°ë³¸ ì‚¬ìš©ì ì¸ì¦
- ë¯¼ê° ë°ì´í„° ë§ˆìŠ¤í‚¹
- ê°„ë‹¨í•œ ê°ì‚¬ ë¡œê·¸

### í”„ë¡œì íŠ¸ 2: RBAC ë¡œê·¸ ì‹œìŠ¤í…œ (ì¤‘ê¸‰)
**ëª©í‘œ**: ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ë¥¼ ê°–ì¶˜ ë³´ì•ˆ ë¡œê±°

**êµ¬í˜„ ì‚¬í•­**:
- ë‹¤ì¤‘ ì—­í•  ì§€ì›
- ì„¸ë°€í•œ ê¶Œí•œ ê´€ë¦¬
- ì‹œê°„ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
- ìƒì„¸ ê°ì‚¬ ì¶”ì 

### í”„ë¡œì íŠ¸ 3: ì—”í„°í”„ë¼ì´ì¦ˆ ë³´ì•ˆ ë¡œê·¸ í”Œë«í¼ (ê³ ê¸‰)
**ëª©í‘œ**: ëŒ€ê·œëª¨ ì¡°ì§ìš© ì™„ì „í•œ ë³´ì•ˆ ë¡œê·¸ ì‹œìŠ¤í…œ

**êµ¬í”„ ì‚¬í•­**:
- PKI ê¸°ë°˜ ì¸ì¦
- ì—”ë“œíˆ¬ì—”ë“œ ì•”í˜¸í™”
- ì»´í”Œë¼ì´ì–¸ìŠ¤ ë¦¬í¬íŒ…
- ì‹¤ì‹œê°„ ìœ„í˜‘ íƒì§€

---

## 8. í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ì´ˆ ë ˆë²¨ âœ…
- [ ] ëŒ€ì¹­í‚¤ ì•”í˜¸í™” ì´í•´
- [ ] ê¸°ë³¸ ì¸ì¦/ì¸ê°€ êµ¬í˜„
- [ ] ë¡œê·¸ ë§ˆìŠ¤í‚¹ ê¸°ë²•
- [ ] Docker ê¸°ì´ˆ

### ì¤‘ê¸‰ ë ˆë²¨ ğŸ“š
- [ ] TLS/SSL í†µì‹  êµ¬í˜„
- [ ] RBAC ì„¤ê³„ ë° êµ¬í˜„
- [ ] ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ
- [ ] ì»¨í…Œì´ë„ˆ ë³´ì•ˆ

### ê³ ê¸‰ ë ˆë²¨ ğŸš€
- [ ] í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ (HSM)
- [ ] Zero Trust ì•„í‚¤í…ì²˜
- [ ] ì»´í”Œë¼ì´ì–¸ìŠ¤ ìë™í™”
- [ ] ì¹¨ì… íƒì§€ ì‹œìŠ¤í…œ

### ì „ë¬¸ê°€ ë ˆë²¨ ğŸ†
- [ ] í¬ë Œì‹ ë¶„ì„ ë„êµ¬
- [ ] ë³´ì•ˆ ìš´ì˜ ìë™í™”
- [ ] ëŒ€ê·œëª¨ ë³´ì•ˆ ì•„í‚¤í…ì²˜
- [ ] ì¾Œë¦¬ëŸ°í†°ì²˜ ì¢…í•©

---

## 9. ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì¶”ì²œ ë„ì„œ
- "Applied Cryptography" - Bruce Schneier
- "Security Engineering" - Ross Anderson
- "Zero Trust Networks" - Evan Gilman & Doug Barth

### ì˜¨ë¼ì¸ ë¦¬ì†ŒìŠ¤
- [OWASP Security Practices](https://owasp.org/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [CIS Controls](https://www.cisecurity.org/controls/)

### ì‹¤ìŠµ ë„êµ¬
- HashiCorp Vault (í‚¤ ê´€ë¦¬)
- ELK Stack + Security í”ŒëŸ¬ê·¸ì¸
- Falco (ì»¨í…Œì´ë„ˆ ë³´ì•ˆ)
- Open Policy Agent (OPA)

---

## 6. ë‹¤ìŒ ë‹¨ê³„ ì¤€ë¹„

ì´ ë³´ì•ˆ ë° ìš´ì˜ ê°€ì´ë“œë¥¼ ì™„ë£Œí–ˆë‹¤ë©´ LogCasterë¥¼ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ìš´ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **ë°ì´í„° ë³´ì•ˆ**: ì•”í˜¸í™”ì™€ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹ìœ¼ë¡œ ë°ì´í„° ë³´í˜¸
2. **ì ‘ê·¼ ì œì–´**: RBACë¥¼ í†µí•œ ì„¸ë°€í•œ ê¶Œí•œ ê´€ë¦¬
3. **ê°ì‚¬ ì¶”ì **: ëª¨ë“  í™œë™ì— ëŒ€í•œ ì™„ì „í•œ ê°ì‚¬ ë¡œê·¸
4. **ìš´ì˜ íš¨ìœ¨ì„±**: ì»¨í…Œì´ë„ˆí™”ì™€ ëª¨ë‹ˆí„°ë§ìœ¼ë¡œ ì•ˆì •ì  ìš´ì˜

### í™•ì¸ ë¬¸ì œ

1. ë¡œê·¸ ë°ì´í„°ë¥¼ ì•”í˜¸í™”í•  ë•Œ í‚¤ ê´€ë¦¬ëŠ” ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?
2. RBACì—ì„œ ìµœì†Œ ê¶Œí•œ ì›ì¹™ì„ ì–´ë–»ê²Œ ì ìš©í•´ì•¼ í• ê¹Œìš”?
3. ê°ì‚¬ ë¡œê·¸ ìì²´ì˜ ë¬´ê²°ì„±ì€ ì–´ë–»ê²Œ ë³´ì¥í• ê¹Œìš”?

---

*ğŸ’¡ íŒ: ë³´ì•ˆì€ í•œ ë²ˆ ì„¤ì •í•˜ê³  ëë‚˜ëŠ” ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ê³¼ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤!*