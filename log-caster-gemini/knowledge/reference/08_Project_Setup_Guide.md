# 4. í”„ë¡œì íŠ¸ ê°œë°œí™˜ê²½ ì¤€ë¹„í•˜ê¸° ğŸ› ï¸
## ì‹¤ì œ ê°œë°œì„ ìœ„í•œ ì²« ê±¸ìŒ

*LogCaster í”„ë¡œì íŠ¸ë¥¼ ìœ„í•œ ì‚¬ì „ì§€ì‹ ë¬¸ì„œ*

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´
- **ë‚œì´ë„**: ğŸŸ¡ ì¤‘ê¸‰ â†’ ğŸ”´ ê³ ê¸‰
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 10-12ì‹œê°„
- **ì „ì œ ì¡°ê±´**: 
  - ì´ì „ 3ê°œ ë¬¸ì„œì˜ ë‚´ìš© ìˆ™ì§€
  - Linux/macOS ê°œë°œ í™˜ê²½
  - ê¸°ë³¸ì ì¸ ë¹Œë“œ ë„êµ¬ ì‚¬ìš© ê²½í—˜
- **ì‹¤ìŠµ í™˜ê²½**: Linux/macOS, GCC/G++, CMake, Git

## ğŸ¯ ì´ ë¬¸ì„œì—ì„œ ë°°ìš¸ ë‚´ìš©

**"ë“œë””ì–´ ì‹¤ì œ í”„ë¡œì íŠ¸ë¥¼ ë§Œë“¤ì–´ë³¼ ì‹œê°„ì´ì—ìš”! ğŸ‰"**

ì§€ê¸ˆê¹Œì§€ C/C++ì˜ ê¸°ì´ˆ, ë©”ëª¨ë¦¬ ê´€ë¦¬, ë°ì´í„° êµ¬ì¡°, ê°ì²´ì§€í–¥ê¹Œì§€ ë°°ì› ë‹¤ë©´, ì´ì œ ì§„ì§œ ì‹¤ë ¥ì„ ë°œíœ˜í•  ë•Œì…ë‹ˆë‹¤! 

ğŸ§‘â€ğŸ’» **ê°œë°œìê°€ ë˜ëŠ” ì—¬ì •**ì„ ìƒê°í•´ë³´ì„¸ìš”:
- ì²« ë²ˆì§¸ ë‹¨ê³„: ì–¸ì–´ ë°°ìš°ê¸° âœ… (ì§€ê¸ˆê¹Œì§€ ì™„ë£Œ!)
- ë‘ ë²ˆì§¸ ë‹¨ê³„: **ì‹¤ì œ í”„ë¡œì íŠ¸ ë§Œë“¤ê¸°** ğŸ‘ˆ (ì§€ê¸ˆ ì—¬ê¸°!)
- ì„¸ ë²ˆì§¸ ë‹¨ê³„: í¬íŠ¸í´ë¦¬ì˜¤ ì™„ì„±í•˜ê¸°

ì´ ë¬¸ì„œì—ì„œëŠ” ê°œë°œí™˜ê²½ ì„¤ì •ë¶€í„° í…ŒìŠ¤íŠ¸ ë°©ë²•ë¡ , ë””ë²„ê¹… ê¸°ë²•, ê·¸ë¦¬ê³  ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œê¹Œì§€ ì‹¤ì œ í”„ë¡œì íŠ¸ ê°œë°œì— í•„ìš”í•œ ëª¨ë“  ì‹¤ìŠµ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ë§ˆì¹˜ **ìš”ë¦¬ë¥¼ ìœ„í•´ ì¬ë£Œì™€ ë„êµ¬ë¥¼ ì¤€ë¹„í•˜ëŠ” ê²ƒ**ì²˜ëŸ¼, í”„ë¡œì íŠ¸ë¥¼ ìœ„í•œ ëª¨ë“  ì¤€ë¹„ë¥¼ ì™„ë²½í•˜ê²Œ í•´ë³´ê² ìŠµë‹ˆë‹¤!

---

## ğŸ› ï¸ 1. ê°œë°œí™˜ê²½ ì„¤ì •

**"ì¢‹ì€ ë„êµ¬ê°€ ì¢‹ì€ ê²°ê³¼ë¥¼ ë§Œë“ ë‹¤! ğŸ”§"**

ê°œë°œí™˜ê²½ ì„¤ì •ì€ ë§ˆì¹˜ **ìš”ë¦¬í•  ë•Œ ì¹¼ê³¼ ë„ë§ˆë¥¼ ì¤€ë¹„í•˜ëŠ” ê²ƒ**ê³¼ ê°™ìŠµë‹ˆë‹¤. ì²˜ìŒì— ì œëŒ€ë¡œ ì¤€ë¹„í•´ë‘ë©´ ë‚˜ì¤‘ì— í›¨ì”¬ í¸í•˜ê²Œ ê°œë°œí•  ìˆ˜ ìˆì–´ìš”!

### í•„ìˆ˜ ë„êµ¬ ì„¤ì¹˜

#### Linux/macOS í™˜ê²½

**ë§ˆì¹˜ ê²Œì„ì—ì„œ ì•„ì´í…œì„ ëª¨ìœ¼ëŠ” ê²ƒì²˜ëŸ¼, í•˜ë‚˜ì”© ì„¤ì¹˜í•´ë´…ì‹œë‹¤! ğŸ®**

```bash
# ğŸ”§ 1. ì»´íŒŒì¼ëŸ¬ ì„¤ì¹˜ (ê°€ì¥ ì¤‘ìš”í•œ ë„êµ¬!)
## Ubuntu/Debian (ë¦¬ëˆ…ìŠ¤ ì‚¬ìš©ì)
sudo apt update  # íŒ¨í‚¤ì§€ ëª©ë¡ ì—…ë°ì´íŠ¸
sudo apt install build-essential gcc g++ clang cmake make
# build-essential: C/C++ ê°œë°œì— í•„ìš”í•œ ëª¨ë“  ê¸°ë³¸ ë„êµ¬ë“¤ì´ ë“¤ì–´ìˆì–´ìš”!

## macOS (Mac ì‚¬ìš©ì - Homebrew í•„ìš”)
brew install gcc cmake make
# Homebrewê°€ ì—†ë‹¤ë©´: /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# ğŸ› 2. ë””ë²„ê¹… ë„êµ¬ (ë²„ê·¸ë¥¼ ì¡ëŠ” ëª…íƒì • ë„êµ¬ë“¤!)
sudo apt install gdb valgrind  # Linux
brew install gdb               # macOS
# gdb: í”„ë¡œê·¸ë¨ ë‚´ë¶€ë¥¼ ë“¤ì—¬ë‹¤ë³´ëŠ” í˜„ë¯¸ê²½
# valgrind: ë©”ëª¨ë¦¬ ë¬¸ì œë¥¼ ì°¾ì•„ë‚´ëŠ” íƒì§€ê¸°

# âš¡ 3. ì„±ëŠ¥ ë¶„ì„ ë„êµ¬ (í”„ë¡œê·¸ë¨ì´ ì–¼ë§ˆë‚˜ ë¹ ë¥¸ì§€ ì¸¡ì •!)
sudo apt install perf linux-tools-generic  # Linux
brew install gperftools                     # macOS
# ë‚´ í”„ë¡œê·¸ë¨ì´ ì–´ë””ì„œ ëŠë ¤ì§€ëŠ”ì§€ ì°¾ì•„ë‚´ëŠ” ë„êµ¬

# ğŸŒ 4. ë„¤íŠ¸ì›Œí¬ ë¶„ì„ ë„êµ¬ (ì¸í„°ë„· í†µì‹  í™•ì¸!)
sudo apt install netcat-openbsd tcpdump wireshark
brew install netcat tcpdump wireshark
# netcat(nc): ê°„ë‹¨í•œ ë„¤íŠ¸ì›Œí¬ í…ŒìŠ¤íŠ¸ ë„êµ¬
# tcpdump: ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ë¶„ì„ê¸°

# ğŸ—ï¸ 5. ë¹Œë“œ ë„êµ¬ (í”„ë¡œì íŠ¸ë¥¼ ì¡°ë¦½í•˜ëŠ” ë„êµ¬!)
sudo apt install ninja-build pkg-config
brew install ninja pkg-config
# ninja: ë§¤ìš° ë¹ ë¥¸ ë¹Œë“œ ì‹œìŠ¤í…œ
# pkg-config: ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ë³´ ê´€ë¦¬

# ğŸ“ 6. ë²„ì „ ê´€ë¦¬ (ì½”ë“œì˜ ì—­ì‚¬ë¥¼ ê¸°ë¡!)
sudo apt install git
brew install git
# git: ì½”ë“œ ë³€ê²½ì‚¬í•­ì„ ì¶”ì í•˜ê³  ê´€ë¦¬í•˜ëŠ” í•„ìˆ˜ ë„êµ¬
```

#### ê°œë°œí™˜ê²½ ê²€ì¦

**"ì„¤ì¹˜ê°€ ëë‚¬ë‹¤ë©´ ì œëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•´ë´…ì‹œë‹¤! âœ…"**

ë§ˆì¹˜ **ìƒˆ ì°¨ë¥¼ ì‚° í›„ ì‹œë™ì„ ê±¸ì–´ë³´ëŠ” ê²ƒ**ì²˜ëŸ¼, ëª¨ë“  ë„êµ¬ê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•´ë³´ê² ìŠµë‹ˆë‹¤.

```bash
# ğŸ” ì»´íŒŒì¼ëŸ¬ ë²„ì „ í™•ì¸ (ìš°ë¦¬ì˜ ì£¼ìš” ë„êµ¬ë“¤ì´ ì¤€ë¹„ëë‚˜ìš”?)
gcc --version    # C ì»´íŒŒì¼ëŸ¬ í™•ì¸
g++ --version    # C++ ì»´íŒŒì¼ëŸ¬ í™•ì¸ 
clang --version  # ë˜ ë‹¤ë¥¸ ì»´íŒŒì¼ëŸ¬ í™•ì¸

# ğŸ“‹ CMake ë²„ì „ í™•ì¸ (3.10 ì´ìƒì´ì–´ì•¼ í•´ìš”!)
cmake --version
# ë§Œì•½ ë²„ì „ì´ ë‚®ë‹¤ë©´ ìµœì‹  ë²„ì „ì„ ì„¤ì¹˜í•˜ì„¸ìš”

# ğŸ§µ ìŠ¤ë ˆë“œ ì§€ì› í™•ì¸ (ë©€í‹°ìŠ¤ë ˆë”©ì´ ê°€ëŠ¥í•œì§€ í…ŒìŠ¤íŠ¸)
# ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ì–´ì„œ ì‹¤í–‰í•´ë´…ì‹œë‹¤
echo '#include <iostream>
#include <thread>
int main() { 
    std::cout << "ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! C++17ì´ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤!" << std::endl;
    std::cout << "ğŸ’» ì‚¬ìš© ê°€ëŠ¥í•œ í•˜ë“œì›¨ì–´ ìŠ¤ë ˆë“œ ìˆ˜: " << std::thread::hardware_concurrency() << std::endl; 
    return 0; 
}' > test_threads.cpp

# ì»´íŒŒì¼ ë° ì‹¤í–‰
g++ -std=c++17 -pthread test_threads.cpp -o test_threads
./test_threads

# í…ŒìŠ¤íŠ¸ íŒŒì¼ ì •ë¦¬
rm test_threads test_threads.cpp

# ğŸŠ ëª¨ë“  ì¶œë ¥ì´ ì •ìƒì´ë¼ë©´ ì¤€ë¹„ ì™„ë£Œ!
```

### IDE ì„¤ì •

**"ì½”ë”©ì„ ìœ„í•œ ìµœê³ ì˜ ì‘ì—… ê³µê°„ì„ ë§Œë“¤ì–´ë´…ì‹œë‹¤! ğŸ "**

IDE(í†µí•© ê°œë°œ í™˜ê²½)ëŠ” ê°œë°œìì˜ **ë””ì§€í„¸ ì±…ìƒ**ì´ì—ìš”. í¸ì•ˆí•˜ê³  íš¨ìœ¨ì ìœ¼ë¡œ ì„¤ì •í•´ë‘ë©´ ìƒì‚°ì„±ì´ í¬ê²Œ í–¥ìƒë©ë‹ˆë‹¤!

#### Visual Studio Code (ë¬´ë£Œì´ë©´ì„œ ê°•ë ¥í•œ ì„ íƒ! ğŸ’ª)
```json
// .vscode/settings.json
// ğŸ’¡ ì´ íŒŒì¼ì€ VSCodeì—ê²Œ "C++ í”„ë¡œì íŠ¸ë¥¼ ì–´ë–»ê²Œ ë‹¤ë¤„ì•¼ í•˜ëŠ”ì§€" ì•Œë ¤ì¤ë‹ˆë‹¤
{
    "C_Cpp.default.cppStandard": "c++17",  // ğŸš€ ìµœì‹  C++17 í‘œì¤€ ì‚¬ìš©
    "C_Cpp.default.cStandard": "c11",      // ğŸ“œ C11 í‘œì¤€ ì‚¬ìš©
    "C_Cpp.default.compilerPath": "/usr/bin/g++",  // ğŸ”§ ì»´íŒŒì¼ëŸ¬ ìœ„ì¹˜
    "C_Cpp.default.includePath": [  // ğŸ“ í—¤ë” íŒŒì¼ì„ ì–´ë””ì„œ ì°¾ì„ì§€
        "${workspaceFolder}/**",     // í”„ë¡œì íŠ¸ í´ë” ì „ì²´
        "/usr/include",              // ì‹œìŠ¤í…œ í—¤ë”ë“¤
        "/usr/local/include"         // ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤
    ],
    "C_Cpp.clang_format_style": "{ BasedOnStyle: Google, IndentWidth: 4, TabWidth: 4 }",  // ğŸ¨ ì½”ë“œ ìŠ¤íƒ€ì¼
    "editor.formatOnSave": true,    // ğŸ’¾ ì €ì¥í•  ë•Œ ìë™ìœ¼ë¡œ ì½”ë“œ ì •ë¦¬
    "files.associations": {         // ğŸ“„ íŒŒì¼ í™•ì¥ì ì—°ê²°
        "*.hpp": "cpp",
        "*.h": "c"
    }
}

// .vscode/tasks.json
// ğŸ› ï¸ ë¹Œë“œ ì‘ì—…ì„ ì‰½ê²Œ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ë‹¨ì¶•í‚¤ë¥¼ ë§Œë“­ë‹ˆë‹¤
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build LogCaster-C",        // ğŸ…² C ë²„ì „ ë¹Œë“œ
            "type": "shell",
            "command": "make",
            "args": ["-C", "logcaster-c"],       // logcaster-c í´ë”ì—ì„œ make ì‹¤í–‰
            "group": {
                "kind": "build",
                "isDefault": true                   // ê¸°ë³¸ ë¹Œë“œ ì‘ì—…ìœ¼ë¡œ ì„¤ì •
            },
            "presentation": {
                "echo": true,
                "reveal": "always",                 // í•­ìƒ í„°ë¯¸ë„ ì°½ ë³´ì—¬ì£¼ê¸°
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": "$gcc"               // ì»´íŒŒì¼ ì—ëŸ¬ë¥¼ ìë™ìœ¼ë¡œ íŒŒì‹±
        },
        {
            "label": "Build LogCaster-CPP",      // ğŸ…’++ C++ ë²„ì „ ë¹Œë“œ
            "type": "shell",
            "command": "cmake",
            "args": ["--build", "logcaster-cpp/build"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "always",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": "$gcc"
        }
    ]
}

// ğŸ’¡ ì‚¬ìš©ë²•: Ctrl+Shift+P â†’ "Tasks: Run Task" â†’ ì›í•˜ëŠ” ë¹Œë“œ ì„ íƒ!

// .vscode/launch.json
// ğŸ› ë””ë²„ê¹… ì„¤ì • - ë²„ê·¸ë¥¼ ì¡ëŠ” ë„êµ¬ ì„¤ì •
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug LogCaster-C",          // ğŸ…² C ë²„ì „ ë””ë²„ê¹…
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/logcaster-c/logcaster",  // ì‹¤í–‰í•  í”„ë¡œê·¸ë¨
            "args": ["--port", "9999"],           // í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¸ì
            "stopAtEntry": false,                  // main í•¨ìˆ˜ì—ì„œ ìë™ ë©ˆì¶¤ ì•ˆí•¨
            "cwd": "${workspaceFolder}/logcaster-c",  // ì‘ì—… ë””ë ‰í† ë¦¬
            "environment": [],
            "externalConsole": false,              // VSCode ë‚´ì¥ í„°ë¯¸ë„ ì‚¬ìš©
            "MIMode": "gdb",                       // ë””ë²„ê±° ì¢…ë¥˜
            "setupCommands": [                     // ë””ë²„ê¹… ì‹œì‘ ì „ ì‹¤í–‰í•  ëª…ë ¹ë“¤
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Build LogCaster-C", // ë””ë²„ê¹… ì „ì— ë¹Œë“œ ë¨¼ì € ì‹¤í–‰
            "miDebuggerPath": "/usr/bin/gdb"       // gdb ê²½ë¡œ
        },
        {
            "name": "Debug LogCaster-CPP",        // ğŸ…’++ C++ ë²„ì „ ë””ë²„ê¹…
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/logcaster-cpp/build/logcaster",
            "args": ["--port", "9999"],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}/logcaster-cpp",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "Build LogCaster-CPP"
        }
    ]
}

// ğŸ’¡ ì‚¬ìš©ë²•: F5 í‚¤ë¥¼ ëˆ„ë¥´ë©´ ë””ë²„ê¹… ì‹œì‘! ë¸Œë ˆì´í¬í¬ì¸íŠ¸ë¥¼ ì„¤ì •í•˜ê³  ë³€ìˆ˜ ê°’ì„ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.
```

### í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ êµ¬ì¡°

**"ì§‘ì„ ì§€ì„ ë•Œ ì„¤ê³„ë„ê°€ í•„ìš”í•˜ë“¯, í”„ë¡œì íŠ¸ë„ ì²´ê³„ì ì¸ êµ¬ì¡°ê°€ í•„ìš”í•´ìš”! ğŸ—ï¸"**

ì•„ë˜ëŠ” ìš°ë¦¬ê°€ ë§Œë“¤ LogCaster í”„ë¡œì íŠ¸ì˜ **ì²­ì‚¬ì§„**ì…ë‹ˆë‹¤. ë§ˆì¹˜ **ì•„íŒŒíŠ¸ í‰ë©´ë„**ë¥¼ ë³´ëŠ” ê²ƒì²˜ëŸ¼, ê° í´ë”ì™€ íŒŒì¼ì´ ì–´ë–¤ ì—­í• ì„ í•˜ëŠ”ì§€ ì´í•´í•´ë´…ì‹œë‹¤:

```
LogCaster/                      # ğŸ  ìš°ë¦¬ í”„ë¡œì íŠ¸ì˜ ë©”ì¸ í´ë”
â”œâ”€â”€ README.md                    # ğŸ“– í”„ë¡œì íŠ¸ ì„¤ëª…ì„œ (ê°€ì¥ ë¨¼ì € ì½ëŠ” íŒŒì¼!)
â”œâ”€â”€ .gitignore                   # ğŸš« Gitì— ì˜¬ë¦¬ì§€ ì•Šì„ íŒŒì¼ë“¤ ëª©ë¡
â”œâ”€â”€ docs/                        # ğŸ“š ë¬¸ì„œ ë³´ê´€í•¨
â”‚   â”œâ”€â”€ design.md               # ğŸ¨ ì„¤ê³„ ë¬¸ì„œ
â”‚   â”œâ”€â”€ api.md                  # ğŸ”Œ API ì‚¬ìš©ë²•
â”‚   â””â”€â”€ performance.md          # âš¡ ì„±ëŠ¥ ë¶„ì„ ê²°ê³¼
â”œâ”€â”€ scripts/                     # ğŸ¤– ìë™í™” ìŠ¤í¬ë¦½íŠ¸ë“¤
â”‚   â”œâ”€â”€ build.sh                # ğŸ”¨ ë¹Œë“œ ìë™í™”
â”‚   â”œâ”€â”€ test.sh                 # ğŸ§ª í…ŒìŠ¤íŠ¸ ìë™í™”
â”‚   â””â”€â”€ benchmark.sh            # ğŸ“Š ì„±ëŠ¥ ì¸¡ì • ìë™í™”
â”œâ”€â”€ logcaster-c/               # ğŸ…² C ì–¸ì–´ ë²„ì „
â”‚   â”œâ”€â”€ Makefile                # ğŸ”§ C í”„ë¡œì íŠ¸ ë¹Œë“œ ì„¤ì •
â”‚   â”œâ”€â”€ src/                    # ğŸ’» ì†ŒìŠ¤ ì½”ë“œë“¤
â”‚   â”‚   â”œâ”€â”€ main.c              # ğŸš€ í”„ë¡œê·¸ë¨ ì‹œì‘ì 
â”‚   â”‚   â”œâ”€â”€ server.c            # ğŸŒ ì„œë²„ í•µì‹¬ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ log_storage.c       # ğŸ’¾ ë¡œê·¸ ì €ì¥ ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ network.c           # ğŸ“¡ ë„¤íŠ¸ì›Œí¬ í†µì‹ 
â”‚   â”‚   â””â”€â”€ utils.c             # ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
â”‚   â”œâ”€â”€ include/                # ğŸ“„ í—¤ë” íŒŒì¼ë“¤ (í•¨ìˆ˜ ì„ ì–¸)
â”‚   â”‚   â”œâ”€â”€ server.h
â”‚   â”‚   â”œâ”€â”€ log_storage.h
â”‚   â”‚   â”œâ”€â”€ network.h
â”‚   â”‚   â””â”€â”€ utils.h
â”‚   â”œâ”€â”€ tests/                  # ğŸ§ª í…ŒìŠ¤íŠ¸ ì½”ë“œë“¤
â”‚   â”‚   â”œâ”€â”€ test_server.c       # ì„œë²„ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
â”‚   â”‚   â”œâ”€â”€ test_storage.c      # ì €ì¥ì†Œ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
â”‚   â”‚   â””â”€â”€ Makefile            # í…ŒìŠ¤íŠ¸ ë¹Œë“œ ì„¤ì •
â”‚   â””â”€â”€ examples/               # ğŸ“ ì‚¬ìš© ì˜ˆì œë“¤
â”‚       â”œâ”€â”€ client.c            # í´ë¼ì´ì–¸íŠ¸ ì˜ˆì œ
â”‚       â””â”€â”€ stress_test.c       # ë¶€í•˜ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ logcaster-cpp/             # ğŸ…’++ C++ ì–¸ì–´ ë²„ì „
â”‚   â”œâ”€â”€ CMakeLists.txt          # ğŸ”§ C++ í”„ë¡œì íŠ¸ ë¹Œë“œ ì„¤ì •
â”‚   â”œâ”€â”€ src/                    # ğŸ’» ì†ŒìŠ¤ ì½”ë“œë“¤
â”‚   â”‚   â”œâ”€â”€ main.cpp            # ğŸš€ í”„ë¡œê·¸ë¨ ì‹œì‘ì 
â”‚   â”‚   â”œâ”€â”€ Server.cpp          # ğŸŒ ì„œë²„ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ LogStorage.cpp      # ğŸ’¾ ë¡œê·¸ ì €ì¥ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ LogEntry.cpp        # ğŸ“ ë¡œê·¸ ì—”íŠ¸ë¦¬ í´ë˜ìŠ¤
â”‚   â”‚   â””â”€â”€ NetworkManager.cpp  # ğŸ“¡ ë„¤íŠ¸ì›Œí¬ ê´€ë¦¬ì í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ include/                # ğŸ“„ í—¤ë” íŒŒì¼ë“¤
â”‚   â”‚   â”œâ”€â”€ Server.hpp
â”‚   â”‚   â”œâ”€â”€ LogStorage.hpp
â”‚   â”‚   â”œâ”€â”€ LogEntry.hpp
â”‚   â”‚   â””â”€â”€ NetworkManager.hpp
â”‚   â”œâ”€â”€ tests/                  # ğŸ§ª í…ŒìŠ¤íŠ¸ ì½”ë“œë“¤
â”‚   â”‚   â”œâ”€â”€ test_server.cpp
â”‚   â”‚   â”œâ”€â”€ test_storage.cpp
â”‚   â”‚   â””â”€â”€ CMakeLists.txt
â”‚   â”œâ”€â”€ examples/               # ğŸ“ ì‚¬ìš© ì˜ˆì œë“¤
â”‚   â”‚   â”œâ”€â”€ client.cpp
â”‚   â”‚   â””â”€â”€ benchmark.cpp
â”‚   â””â”€â”€ build/                  # ğŸ—ï¸ ë¹Œë“œ ê²°ê³¼ë¬¼ë“¤ì´ ì €ì¥ë˜ëŠ” ê³³
â””â”€â”€ tools/                      # ğŸ› ï¸ ê°œë°œ ë„êµ¬ë“¤
    â”œâ”€â”€ log_generator.py        # ğŸ² í…ŒìŠ¤íŠ¸ìš© ë¡œê·¸ ìƒì„±ê¸°
    â”œâ”€â”€ performance_monitor.py  # ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë„êµ¬
    â””â”€â”€ client_simulator.py     # ğŸ­ í´ë¼ì´ì–¸íŠ¸ ì‹œë®¬ë ˆì´í„°
```

ğŸ’¡ **íŒ**: ì´ëŸ° êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ë©´ ì½”ë“œë¥¼ ì°¾ê¸° ì‰½ê³ , ë‹¤ë¥¸ ê°œë°œìë“¤ë„ í”„ë¡œì íŠ¸ë¥¼ ì´í•´í•˜ê¸° ì‰¬ì›Œì ¸ìš”!

---

## ğŸ§ª 2. í…ŒìŠ¤íŠ¸ ë°©ë²•ë¡ 

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

#### C í”„ë¡œì íŠ¸ìš© ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
```c
// tests/test_framework.h
#ifndef TEST_FRAMEWORK_H
#define TEST_FRAMEWORK_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// í…ŒìŠ¤íŠ¸ í†µê³„
static int tests_run = 0;
static int tests_passed = 0;
static int tests_failed = 0;

// ìƒ‰ìƒ ì¶œë ¥
#define COLOR_GREEN  "\x1b[32m"
#define COLOR_RED    "\x1b[31m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET  "\x1b[0m"

// í…ŒìŠ¤íŠ¸ ë§¤í¬ë¡œ
#define TEST_START(name) \
    do { \
        printf(COLOR_YELLOW "Running test: %s" COLOR_RESET "\n", name); \
        tests_run++; \
    } while(0)

#define ASSERT_EQ(expected, actual) \
    do { \
        if ((expected) == (actual)) { \
            printf(COLOR_GREEN "  âœ“ ASSERT_EQ passed" COLOR_RESET "\n"); \
        } else { \
            printf(COLOR_RED "  âœ— ASSERT_EQ failed: expected %d, got %d" COLOR_RESET "\n", \
                   (int)(expected), (int)(actual)); \
            tests_failed++; \
            return 0; \
        } \
    } while(0)

#define ASSERT_STR_EQ(expected, actual) \
    do { \
        if (strcmp((expected), (actual)) == 0) { \
            printf(COLOR_GREEN "  âœ“ ASSERT_STR_EQ passed" COLOR_RESET "\n"); \
        } else { \
            printf(COLOR_RED "  âœ— ASSERT_STR_EQ failed: expected '%s', got '%s'" COLOR_RESET "\n", \
                   (expected), (actual)); \
            tests_failed++; \
            return 0; \
        } \
    } while(0)

#define ASSERT_TRUE(condition) \
    do { \
        if (condition) { \
            printf(COLOR_GREEN "  âœ“ ASSERT_TRUE passed" COLOR_RESET "\n"); \
        } else { \
            printf(COLOR_RED "  âœ— ASSERT_TRUE failed" COLOR_RESET "\n"); \
            tests_failed++; \
            return 0; \
        } \
    } while(0)

#define TEST_END() \
    do { \
        tests_passed++; \
        printf(COLOR_GREEN "Test passed!" COLOR_RESET "\n\n"); \
        return 1; \
    } while(0)

// í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í•¨ìˆ˜
typedef int (*test_func_t)(void);

void run_test(const char* name, test_func_t test) {
    if (test()) {
        printf(COLOR_GREEN "âœ“ %s PASSED" COLOR_RESET "\n", name);
    } else {
        printf(COLOR_RED "âœ— %s FAILED" COLOR_RESET "\n", name);
    }
}

void print_test_summary(void) {
    printf("\n" COLOR_YELLOW "=== Test Summary ===" COLOR_RESET "\n");
    printf("Total tests: %d\n", tests_run);
    printf(COLOR_GREEN "Passed: %d" COLOR_RESET "\n", tests_passed);
    if (tests_failed > 0) {
        printf(COLOR_RED "Failed: %d" COLOR_RESET "\n", tests_failed);
    }
    printf("Success rate: %.1f%%\n", (double)tests_passed / tests_run * 100.0);
}

#endif // TEST_FRAMEWORK_H

// tests/test_log_storage.c
#include "test_framework.h"
#include "../include/log_storage.h"

int test_log_storage_create() {
    TEST_START("log_storage_create");
    
    LogStorage* storage = log_storage_create(100);
    ASSERT_TRUE(storage != NULL);
    ASSERT_EQ(0, log_storage_size(storage));
    ASSERT_EQ(100, log_storage_capacity(storage));
    
    log_storage_destroy(storage);
    TEST_END();
}

int test_log_storage_add() {
    TEST_START("log_storage_add");
    
    LogStorage* storage = log_storage_create(10);
    
    LogEntry entry = {"Test message", "INFO", "localhost", time(NULL)};
    int result = log_storage_add(storage, &entry);
    
    ASSERT_EQ(0, result);
    ASSERT_EQ(1, log_storage_size(storage));
    
    log_storage_destroy(storage);
    TEST_END();
}

int test_log_storage_search() {
    TEST_START("log_storage_search");
    
    LogStorage* storage = log_storage_create(100);
    
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì¶”ê°€
    LogEntry entries[] = {
        {"Error occurred", "ERROR", "server1", time(NULL)},
        {"Info message", "INFO", "server1", time(NULL)},
        {"Warning message", "WARNING", "server2", time(NULL)}
    };
    
    for (int i = 0; i < 3; i++) {
        log_storage_add(storage, &entries[i]);
    }
    
    // ê²€ìƒ‰ í…ŒìŠ¤íŠ¸
    LogEntry* results[10];
    int count = log_storage_search_by_level(storage, "ERROR", results, 10);
    
    ASSERT_EQ(1, count);
    ASSERT_STR_EQ("Error occurred", results[0]->message);
    
    log_storage_destroy(storage);
    TEST_END();
}

int main() {
    printf(COLOR_YELLOW "=== LogCaster Storage Tests ===" COLOR_RESET "\n\n");
    
    run_test("log_storage_create", test_log_storage_create);
    run_test("log_storage_add", test_log_storage_add);
    run_test("log_storage_search", test_log_storage_search);
    
    print_test_summary();
    
    return (tests_failed == 0) ? 0 : 1;
}
```

#### C++ í”„ë¡œì íŠ¸ìš© Google Test ì„¤ì •
```cmake
# tests/CMakeLists.txt
cmake_minimum_required(VERSION 3.10)

# Google Test ë‹¤ìš´ë¡œë“œ ë° ì„¤ì •
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/03597a01ee50bc33767dfd8bcf8dc8ab5db6b3b4.zip
)
FetchContent_MakeAvailable(googletest)

# í…ŒìŠ¤íŠ¸ ì‹¤í–‰íŒŒì¼ë“¤
add_executable(test_server test_server.cpp)
target_link_libraries(test_server 
    logcaster_lib 
    gtest_main 
    gmock_main
    pthread
)

add_executable(test_storage test_storage.cpp)
target_link_libraries(test_storage 
    logcaster_lib 
    gtest_main
    gmock_main
    pthread
)

# í…ŒìŠ¤íŠ¸ ë“±ë¡
include(GoogleTest)
gtest_discover_tests(test_server)
gtest_discover_tests(test_storage)
```

```cpp
// tests/test_storage.cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "../include/LogStorage.hpp"
#include "../include/LogEntry.hpp"

class LogStorageTest : public ::testing::Test {
protected:
    void SetUp() override {
        storage = std::make_unique<LogStorage>(100);
    }

    void TearDown() override {
        storage.reset();
    }

    std::unique_ptr<LogStorage> storage;
};

TEST_F(LogStorageTest, CreateEmpty) {
    EXPECT_EQ(0, storage->size());
    EXPECT_EQ(100, storage->capacity());
    EXPECT_TRUE(storage->empty());
}

TEST_F(LogStorageTest, AddSingleLog) {
    LogEntry entry("Test message", "INFO", "localhost");
    storage->addLog(entry);
    
    EXPECT_EQ(1, storage->size());
    EXPECT_FALSE(storage->empty());
}

TEST_F(LogStorageTest, SearchByLevel) {
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì¶”ê°€
    storage->addLog(LogEntry("Error 1", "ERROR", "server1"));
    storage->addLog(LogEntry("Info 1", "INFO", "server1"));
    storage->addLog(LogEntry("Error 2", "ERROR", "server2"));
    storage->addLog(LogEntry("Warning 1", "WARNING", "server1"));
    
    auto error_logs = storage->getLogsByLevel("ERROR");
    
    EXPECT_EQ(2, error_logs.size());
    EXPECT_EQ("Error 1", error_logs[0].getMessage());
    EXPECT_EQ("Error 2", error_logs[1].getMessage());
}

TEST_F(LogStorageTest, SearchByTimeRange) {
    auto now = std::chrono::system_clock::now();
    auto hour_ago = now - std::chrono::hours(1);
    auto hour_later = now + std::chrono::hours(1);
    
    // ì‹œê°„ì„ ì¡°ì‘í•œ ë¡œê·¸ ì—”íŠ¸ë¦¬ (í…ŒìŠ¤íŠ¸ìš© ìƒì„±ì í•„ìš”)
    LogEntry old_entry("Old message", "INFO", "server1");
    LogEntry recent_entry("Recent message", "INFO", "server1");
    
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹œê°„ ì„¤ì • ë©”ì„œë“œ í•„ìš”
    storage->addLog(old_entry);
    storage->addLog(recent_entry);
    
    auto recent_logs = storage->getLogsInRange(hour_ago, hour_later);
    
    // êµ¬í˜„ì— ë”°ë¼ ê²°ê³¼ ê²€ì¦
    EXPECT_GE(recent_logs.size(), 1);
}

// ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
TEST_F(LogStorageTest, PerformanceTest) {
    const int LOG_COUNT = 100000;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < LOG_COUNT; ++i) {
        storage->addLog(LogEntry("Message " + std::to_string(i), "INFO", "localhost"));
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Added " << LOG_COUNT << " logs in " << duration.count() << " ms" << std::endl;
    std::cout << "Rate: " << (LOG_COUNT * 1000.0 / duration.count()) << " logs/sec" << std::endl;
    
    EXPECT_LT(duration.count(), 1000);  // 1ì´ˆ ì´ë‚´ì— ì™„ë£Œë˜ì–´ì•¼ í•¨
}

// Mockì„ ì‚¬ìš©í•œ ë„¤íŠ¸ì›Œí¬ í…ŒìŠ¤íŠ¸
class MockNetworkManager {
public:
    MOCK_METHOD(bool, sendData, (const std::string& data), ());
    MOCK_METHOD(std::string, receiveData, (), ());
    MOCK_METHOD(bool, isConnected, (), (const));
};

TEST(NetworkTest, SendLogData) {
    MockNetworkManager mock_network;
    
    EXPECT_CALL(mock_network, sendData(::testing::_))
        .WillOnce(::testing::Return(true));
    
    std::string log_data = "Test log message";
    bool result = mock_network.sendData(log_data);
    
    EXPECT_TRUE(result);
}
```

### í†µí•© í…ŒìŠ¤íŠ¸

```bash
#!/bin/bash
# scripts/integration_test.sh

set -e  # ì˜¤ë¥˜ ì‹œ ìŠ¤í¬ë¦½íŠ¸ ì¢…ë£Œ

echo "=== LogCaster Integration Test ==="

# 1. ì„œë²„ ë¹Œë“œ
echo "Building LogCaster server..."
cd logcaster-c
make clean && make
cd ..

# 2. í…ŒìŠ¤íŠ¸ìš© ë¡œê·¸ íŒŒì¼ ìƒì„±
echo "Generating test logs..."
python3 tools/log_generator.py --count 1000 --output test_logs.txt

# 3. ì„œë²„ ì‹œì‘ (ë°±ê·¸ë¼ìš´ë“œ)
echo "Starting LogCaster server..."
./logcaster-c/logcaster --port 9999 --daemon &
SERVER_PID=$!

# ì„œë²„ ì‹œì‘ ëŒ€ê¸°
sleep 2

# 4. ì„œë²„ ìƒíƒœ í™•ì¸
if ! kill -0 $SERVER_PID 2>/dev/null; then
    echo "âŒ Server failed to start"
    exit 1
fi

echo "âœ… Server started with PID: $SERVER_PID"

# 5. í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í…ŒìŠ¤íŠ¸
echo "Testing client connections..."

# ë‹¨ì¼ í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
echo "Test message 1" | nc localhost 9999
if [ $? -eq 0 ]; then
    echo "âœ… Single client test passed"
else
    echo "âŒ Single client test failed"
    kill $SERVER_PID
    exit 1
fi

# ë‹¤ì¤‘ í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
echo "Testing multiple clients..."
for i in {1..10}; do
    echo "Message from client $i" | nc localhost 9999 &
done
wait

echo "âœ… Multiple client test completed"

# 6. ëŒ€ìš©ëŸ‰ ë°ì´í„° í…ŒìŠ¤íŠ¸
echo "Testing bulk data transfer..."
cat test_logs.txt | nc localhost 9999

echo "âœ… Bulk data test completed"

# 7. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
echo "Running performance test..."
python3 tools/client_simulator.py --host localhost --port 9999 --clients 50 --messages 100

# 8. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê²€ì‚¬ (Valgrind ìˆëŠ” ê²½ìš°)
if command -v valgrind &> /dev/null; then
    echo "Running memory leak test..."
    kill $SERVER_PID
    sleep 1
    
    valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \
        ./logcaster-c/logcaster --port 9998 &
    VALGRIND_PID=$!
    
    sleep 3
    echo "Test message for valgrind" | nc localhost 9998
    sleep 2
    
    kill $VALGRIND_PID
    wait $VALGRIND_PID 2>/dev/null || true
else
    echo "Valgrind not available, skipping memory test"
    kill $SERVER_PID
fi

# 9. ì •ë¦¬
rm -f test_logs.txt

echo "=== Integration Test Completed ==="
```

---

## ğŸš€ 3. ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ

### Phase 1: ê¸°ë³¸ êµ¬ì¡° êµ¬í˜„ (1-2ì£¼)

#### LogCaster-C ê¸°ë³¸ êµ¬í˜„
```c
// include/server.h
#ifndef SERVER_H
#define SERVER_H

#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include "log_storage.h"

typedef struct {
    int port;
    int server_fd;
    int max_clients;
    LogStorage* storage;
    pthread_t* worker_threads;
    int thread_count;
    volatile int running;
} LogServer;

// ì„œë²„ ìƒì„± ë° ê´€ë¦¬
LogServer* server_create(int port, int max_clients);
int server_start(LogServer* server);
void server_stop(LogServer* server);
void server_destroy(LogServer* server);

// í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
void* client_handler(void* arg);

#endif

// src/server.c (ê¸°ë³¸ êµ¬í˜„)
#include "server.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

LogServer* server_create(int port, int max_clients) {
    LogServer* server = malloc(sizeof(LogServer));
    if (!server) return NULL;
    
    server->port = port;
    server->max_clients = max_clients;
    server->server_fd = -1;
    server->storage = log_storage_create(10000);  // 1ë§Œ ê°œ ë¡œê·¸ ì €ì¥
    server->thread_count = 4;  // ê¸°ë³¸ 4ê°œ ì›Œì»¤ ìŠ¤ë ˆë“œ
    server->worker_threads = malloc(sizeof(pthread_t) * server->thread_count);
    server->running = 0;
    
    if (!server->storage || !server->worker_threads) {
        server_destroy(server);
        return NULL;
    }
    
    return server;
}

int server_start(LogServer* server) {
    // 1. ì†Œì¼“ ìƒì„±
    server->server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server->server_fd < 0) {
        perror("socket creation failed");
        return -1;
    }
    
    // 2. ì†Œì¼“ ì˜µì…˜ ì„¤ì •
    int opt = 1;
    setsockopt(server->server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // 3. ì£¼ì†Œ ë°”ì¸ë”©
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(server->port);
    
    if (bind(server->server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server->server_fd);
        return -1;
    }
    
    // 4. ë¦¬ìŠ¤ë‹ ì‹œì‘
    if (listen(server->server_fd, server->max_clients) < 0) {
        perror("listen failed");
        close(server->server_fd);
        return -1;
    }
    
    server->running = 1;
    printf("LogCaster server started on port %d\n", server->port);
    
    // 5. ë©”ì¸ ì„œë²„ ë£¨í”„
    while (server->running) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_fd = accept(server->server_fd, (struct sockaddr*)&client_addr, &client_len);
        if (client_fd < 0) {
            if (server->running) {
                perror("accept failed");
            }
            continue;
        }
        
        // í´ë¼ì´ì–¸íŠ¸ ì •ë³´ êµ¬ì¡°ì²´ ìƒì„±
        ClientInfo* client_info = malloc(sizeof(ClientInfo));
        client_info->fd = client_fd;
        client_info->addr = client_addr;
        client_info->server = server;
        
        // ìƒˆ ìŠ¤ë ˆë“œì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
        pthread_t client_thread;
        pthread_create(&client_thread, NULL, client_handler, client_info);
        pthread_detach(client_thread);  // ìë™ ì •ë¦¬
    }
    
    return 0;
}

typedef struct {
    int fd;
    struct sockaddr_in addr;
    LogServer* server;
} ClientInfo;

void* client_handler(void* arg) {
    ClientInfo* client = (ClientInfo*)arg;
    char buffer[1024];
    char client_ip[INET_ADDRSTRLEN];
    
    inet_ntop(AF_INET, &client->addr.sin_addr, client_ip, INET_ADDRSTRLEN);
    printf("Client connected: %s:%d\n", client_ip, ntohs(client->addr.sin_port));
    
    while (1) {
        ssize_t bytes = recv(client->fd, buffer, sizeof(buffer) - 1, 0);
        if (bytes <= 0) break;
        
        buffer[bytes] = '\0';
        
        // ë¡œê·¸ ì—”íŠ¸ë¦¬ ìƒì„± ë° ì €ì¥
        LogEntry entry;
        strncpy(entry.message, buffer, sizeof(entry.message) - 1);
        strncpy(entry.level, "INFO", sizeof(entry.level) - 1);  // ê¸°ë³¸ ë ˆë²¨
        strncpy(entry.source, client_ip, sizeof(entry.source) - 1);
        entry.timestamp = time(NULL);
        
        log_storage_add(client->server->storage, &entry);
        
        // ì‘ë‹µ ì „ì†¡
        send(client->fd, "ACK\n", 4, 0);
    }
    
    printf("Client disconnected: %s:%d\n", client_ip, ntohs(client->addr.sin_port));
    close(client->fd);
    free(client);
    return NULL;
}
```

#### LogCaster-CPP ê¸°ë³¸ êµ¬í˜„
```cpp
// include/Server.hpp
#pragma once

#include <memory>
#include <thread>
#include <atomic>
#include <vector>
#include "LogStorage.hpp"
#include "NetworkManager.hpp"

class Server {
private:
    int port_;
    std::unique_ptr<LogStorage> storage_;
    std::unique_ptr<NetworkManager> network_manager_;
    std::vector<std::thread> worker_threads_;
    std::atomic<bool> running_{false};
    
public:
    explicit Server(int port);
    ~Server();
    
    // ë³µì‚¬/ì´ë™ ì œì–´
    Server(const Server&) = delete;
    Server& operator=(const Server&) = delete;
    Server(Server&&) = default;
    Server& operator=(Server&&) = default;
    
    bool start();
    void stop();
    bool isRunning() const { return running_.load(); }
    
    // í†µê³„ ì •ë³´
    size_t getLogCount() const;
    void printStats() const;
    
private:
    void serverLoop();
    void handleClient(int client_fd, const std::string& client_address);
};

// src/Server.cpp (ê¸°ë³¸ êµ¬í˜„)
#include "Server.hpp"
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

Server::Server(int port) 
    : port_(port),
      storage_(std::make_unique<LogStorage>(10000)),
      network_manager_(std::make_unique<NetworkManager>()) {
}

Server::~Server() {
    stop();
}

bool Server::start() {
    if (running_.exchange(true)) {
        return false;  // ì´ë¯¸ ì‹¤í–‰ ì¤‘
    }
    
    if (!network_manager_->bind(port_)) {
        running_ = false;
        return false;
    }
    
    if (!network_manager_->listen(128)) {
        running_ = false;
        return false;
    }
    
    std::cout << "LogCaster C++ server started on port " << port_ << std::endl;
    
    // ì›Œì»¤ ìŠ¤ë ˆë“œ ì‹œì‘
    size_t thread_count = std::thread::hardware_concurrency();
    worker_threads_.reserve(thread_count);
    
    for (size_t i = 0; i < thread_count; ++i) {
        worker_threads_.emplace_back(&Server::serverLoop, this);
    }
    
    return true;
}

void Server::stop() {
    running_ = false;
    
    // ëª¨ë“  ì›Œì»¤ ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸°
    for (auto& thread : worker_threads_) {
        if (thread.joinable()) {
            thread.join();
        }
    }
    
    worker_threads_.clear();
    network_manager_->close();
}

void Server::serverLoop() {
    while (running_) {
        auto client_info = network_manager_->acceptClient(1000);  // 1ì´ˆ íƒ€ì„ì•„ì›ƒ
        
        if (client_info.has_value()) {
            auto [client_fd, client_address] = client_info.value();
            
            // ìƒˆ ìŠ¤ë ˆë“œì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
            std::thread client_thread(&Server::handleClient, this, client_fd, client_address);
            client_thread.detach();
        }
    }
}

void Server::handleClient(int client_fd, const std::string& client_address) {
    std::cout << "Client connected: " << client_address << std::endl;
    
    char buffer[1024];
    while (running_) {
        ssize_t bytes = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
        if (bytes <= 0) break;
        
        buffer[bytes] = '\0';
        
        // ë¡œê·¸ ì—”íŠ¸ë¦¬ ìƒì„± ë° ì €ì¥
        LogEntry entry(std::string(buffer), "INFO", client_address);
        storage_->addLog(std::move(entry));
        
        // ì‘ë‹µ ì „ì†¡
        const char* ack = "ACK\n";
        send(client_fd, ack, strlen(ack), 0);
    }
    
    std::cout << "Client disconnected: " << client_address << std::endl;
    close(client_fd);
}

size_t Server::getLogCount() const {
    return storage_->size();
}

void Server::printStats() const {
    std::cout << "=== Server Statistics ===" << std::endl;
    std::cout << "Total logs: " << getLogCount() << std::endl;
    std::cout << "Server running: " << (running_ ? "Yes" : "No") << std::endl;
    std::cout << "Worker threads: " << worker_threads_.size() << std::endl;
}
```

### Phase 2: ê³ ê¸‰ ê¸°ëŠ¥ êµ¬í˜„ (2-3ì£¼)

```cpp
// ë¡œê·¸ ì¡°íšŒ ì„œë²„ ì¶”ê°€
class QueryServer {
private:
    std::shared_ptr<LogStorage> storage_;
    int query_port_;
    std::thread query_thread_;
    std::atomic<bool> running_{false};
    
public:
    QueryServer(std::shared_ptr<LogStorage> storage, int port)
        : storage_(storage), query_port_(port) {}
    
    void start() {
        running_ = true;
        query_thread_ = std::thread(&QueryServer::queryLoop, this);
    }
    
    void stop() {
        running_ = false;
        if (query_thread_.joinable()) {
            query_thread_.join();
        }
    }
    
private:
    void queryLoop() {
        // select() ê¸°ë°˜ ì¿¼ë¦¬ ì„œë²„ êµ¬í˜„
        // í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ê²€ìƒ‰ ìš”ì²­ ìˆ˜ì‹ 
        // ê²°ê³¼ë¥¼ JSON í˜•íƒœë¡œ ë°˜í™˜
    }
    
    void handleQuery(int client_fd, const std::string& query) {
        // ì¿¼ë¦¬ íŒŒì‹± ë° ì‹¤í–‰
        // ì˜ˆ: "level:ERROR", "source:192.168.1.100", "time:2024-01-01~2024-01-02"
    }
};
```

### Phase 3: ì„±ëŠ¥ ìµœì í™” (1-2ì£¼)

```cpp
// ê³ ì„±ëŠ¥ ë²„ì „ êµ¬í˜„
class HighPerformanceServer {
private:
    std::unique_ptr<EpollNetworkManager> network_;
    std::unique_ptr<LockFreeLogBuffer> buffer_;
    std::unique_ptr<MemoryPool> memory_pool_;
    
public:
    // epoll() ê¸°ë°˜ ë„¤íŠ¸ì›Œí‚¹
    // Lock-free ë°ì´í„° êµ¬ì¡°
    // ë©”ëª¨ë¦¬ í’€ í™œìš©
    // SIMD ìµœì í™” (ê°€ëŠ¥í•œ ê²½ìš°)
};
```

---

## ğŸ› 4. ë””ë²„ê¹… ë„êµ¬ì™€ ê¸°ë²•

### GDB ë””ë²„ê¹…

```bash
# ë””ë²„ê·¸ ë¹Œë“œ
gcc -g -O0 -DDEBUG src/*.c -o logcaster_debug

# GDB ì‹œì‘
gdb ./logcaster_debug

# ê¸°ë³¸ GDB ëª…ë ¹ì–´
(gdb) break main          # main í•¨ìˆ˜ì— ë¸Œë ˆì´í¬í¬ì¸íŠ¸
(gdb) break server.c:45   # íŠ¹ì • íŒŒì¼ì˜ 45ë²ˆì§¸ ì¤„
(gdb) run --port 9999     # í”„ë¡œê·¸ë¨ ì‹¤í–‰
(gdb) bt                  # ë°±íŠ¸ë ˆì´ìŠ¤ ì¶œë ¥
(gdb) print variable_name # ë³€ìˆ˜ ê°’ ì¶œë ¥
(gdb) step                # í•œ ì¤„ì”© ì‹¤í–‰
(gdb) continue            # ê³„ì† ì‹¤í–‰
(gdb) info threads        # ìŠ¤ë ˆë“œ ì •ë³´
(gdb) thread 2            # ìŠ¤ë ˆë“œ 2ë¡œ ì „í™˜
(gdb) watch variable      # ë³€ìˆ˜ ë³€ê²½ ê°ì‹œ

# ê³ ê¸‰ ëª…ë ¹ì–´
(gdb) set follow-fork-mode child    # ìì‹ í”„ë¡œì„¸ìŠ¤ ì¶”ì 
(gdb) set scheduler-locking on      # ìŠ¤ë ˆë“œ ì ê¸ˆ
(gdb) call function_name()          # í•¨ìˆ˜ ì§ì ‘ í˜¸ì¶œ
```

### Valgrind ë©”ëª¨ë¦¬ ë¶„ì„

```bash
# ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê²€ì‚¬
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file=valgrind_log.txt \
         ./logcaster --port 9999

# ìŠ¤ë ˆë“œ ì—ëŸ¬ ê²€ì‚¬
valgrind --tool=helgrind ./logcaster --port 9999

# ìºì‹œ ì„±ëŠ¥ ë¶„ì„
valgrind --tool=cachegrind ./logcaster --port 9999
callgrind_annotate cachegrind.out.*
```

### AddressSanitizer ì‚¬ìš©

```bash
# ì»´íŒŒì¼ ì‹œ AddressSanitizer í™œì„±í™”
gcc -fsanitize=address -g -O1 src/*.c -o logcaster_asan

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
export ASAN_OPTIONS=verbosity=3:halt_on_error=1:detect_leaks=1

# ì‹¤í–‰
./logcaster_asan --port 9999
```

### ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§

```bash
# perf ì‚¬ìš© (Linux)
perf record -g ./logcaster --port 9999
perf report

# gprof ì‚¬ìš©
gcc -pg src/*.c -o logcaster_prof
./logcaster_prof --port 9999
# í”„ë¡œê·¸ë¨ ì¢…ë£Œ í›„
gprof logcaster_prof gmon.out > analysis.txt

# htopìœ¼ë¡œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
htop -p $(pgrep logcaster)
```

---

## ğŸ“Š 5. ë²¤ì¹˜ë§ˆí¬ì™€ ì„±ëŠ¥ ì¸¡ì •

### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸

```python
#!/usr/bin/env python3
# tools/benchmark.py

import socket
import threading
import time
import argparse
import statistics
from concurrent.futures import ThreadPoolExecutor, as_completed

class LogCasterBenchmark:
    def __init__(self, host='localhost', port=9999):
        self.host = host
        self.port = port
        self.results = []
        
    def send_log_message(self, message):
        """ë‹¨ì¼ ë¡œê·¸ ë©”ì‹œì§€ ì „ì†¡ ë° ì‘ë‹µ ì‹œê°„ ì¸¡ì •"""
        start_time = time.perf_counter()
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(5.0)
                sock.connect((self.host, self.port))
                
                # ë©”ì‹œì§€ ì „ì†¡
                sock.send(message.encode('utf-8'))
                
                # ì‘ë‹µ ìˆ˜ì‹ 
                response = sock.recv(1024)
                
                end_time = time.perf_counter()
                return end_time - start_time, len(response) > 0
                
        except Exception as e:
            return None, False
    
    def connection_throughput_test(self, num_connections=100, messages_per_connection=10):
        """ì—°ê²° ì²˜ë¦¬ëŸ‰ í…ŒìŠ¤íŠ¸"""
        print(f"Connection throughput test: {num_connections} connections, {messages_per_connection} messages each")
        
        def worker(connection_id):
            times = []
            for i in range(messages_per_connection):
                message = f"Benchmark message {connection_id}-{i} " + "x" * 100
                duration, success = self.send_log_message(message)
                if success and duration:
                    times.append(duration)
            return times
        
        start_time = time.perf_counter()
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = [executor.submit(worker, i) for i in range(num_connections)]
            
            all_times = []
            for future in as_completed(futures):
                times = future.result()
                all_times.extend(times)
        
        end_time = time.perf_counter()
        
        total_messages = num_connections * messages_per_connection
        total_time = end_time - start_time
        
        print(f"Total time: {total_time:.2f} seconds")
        print(f"Total messages: {total_messages}")
        print(f"Messages per second: {total_messages / total_time:.2f}")
        print(f"Average response time: {statistics.mean(all_times) * 1000:.2f} ms")
        print(f"95th percentile: {statistics.quantiles(all_times, n=20)[18] * 1000:.2f} ms")
        
    def latency_test(self, num_requests=1000):
        """ì§€ì—°ì‹œê°„ í…ŒìŠ¤íŠ¸"""
        print(f"Latency test: {num_requests} sequential requests")
        
        latencies = []
        
        for i in range(num_requests):
            message = f"Latency test message {i}"
            duration, success = self.send_log_message(message)
            
            if success and duration:
                latencies.append(duration * 1000)  # ë°€ë¦¬ì´ˆë¡œ ë³€í™˜
            
            if i % 100 == 0:
                print(f"Progress: {i}/{num_requests}")
        
        print(f"Average latency: {statistics.mean(latencies):.2f} ms")
        print(f"Median latency: {statistics.median(latencies):.2f} ms")
        print(f"95th percentile: {statistics.quantiles(latencies, n=20)[18]:.2f} ms")
        print(f"99th percentile: {statistics.quantiles(latencies, n=100)[98]:.2f} ms")
        print(f"Max latency: {max(latencies):.2f} ms")
        
    def stress_test(self, duration_seconds=60, concurrent_connections=20):
        """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸"""
        print(f"Stress test: {concurrent_connections} concurrent connections for {duration_seconds} seconds")
        
        start_time = time.perf_counter()
        end_time = start_time + duration_seconds
        message_count = 0
        error_count = 0
        
        def stress_worker():
            nonlocal message_count, error_count
            worker_message_count = 0
            
            while time.perf_counter() < end_time:
                message = f"Stress test message {worker_message_count}"
                duration, success = self.send_log_message(message)
                
                if success:
                    message_count += 1
                else:
                    error_count += 1
                
                worker_message_count += 1
                time.sleep(0.01)  # 10ms ê°„ê²©
        
        threads = []
        for _ in range(concurrent_connections):
            thread = threading.Thread(target=stress_worker)
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join()
        
        actual_duration = time.perf_counter() - start_time
        
        print(f"Actual duration: {actual_duration:.2f} seconds")
        print(f"Total messages sent: {message_count}")
        print(f"Errors: {error_count}")
        print(f"Success rate: {message_count / (message_count + error_count) * 100:.2f}%")
        print(f"Messages per second: {message_count / actual_duration:.2f}")

def main():
    parser = argparse.ArgumentParser(description='LogCaster Benchmark Tool')
    parser.add_argument('--host', default='localhost', help='Server host')
    parser.add_argument('--port', type=int, default=9999, help='Server port')
    parser.add_argument('--test', choices=['throughput', 'latency', 'stress', 'all'], 
                       default='all', help='Test type to run')
    
    args = parser.parse_args()
    
    benchmark = LogCasterBenchmark(args.host, args.port)
    
    print("=== LogCaster Benchmark ===")
    print(f"Target: {args.host}:{args.port}")
    print()
    
    if args.test in ['throughput', 'all']:
        benchmark.connection_throughput_test()
        print()
    
    if args.test in ['latency', 'all']:
        benchmark.latency_test()
        print()
    
    if args.test in ['stress', 'all']:
        benchmark.stress_test()
        print()

if __name__ == '__main__':
    main()
```

### ìë™í™”ëœ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```bash
#!/bin/bash
# scripts/performance_monitor.sh

# ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
monitor_resources() {
    local pid=$1
    local duration=$2
    local output_file=$3
    
    echo "timestamp,cpu_percent,memory_mb,threads,fds" > "$output_file"
    
    for ((i=0; i<duration; i++)); do
        local timestamp=$(date +%s)
        local cpu=$(ps -p $pid -o %cpu --no-headers | tr -d ' ')
        local memory=$(ps -p $pid -o rss --no-headers | tr -d ' ')
        local threads=$(ps -p $pid -o nlwp --no-headers | tr -d ' ')
        local fds=$(ls /proc/$pid/fd 2>/dev/null | wc -l)
        
        echo "$timestamp,$cpu,$memory,$threads,$fds" >> "$output_file"
        sleep 1
    done
}

# ë„¤íŠ¸ì›Œí¬ í†µê³„ ëª¨ë‹ˆí„°ë§
monitor_network() {
    local duration=$1
    local output_file=$2
    
    ss -tuln > "${output_file}_before.txt"
    
    sleep $duration
    
    ss -tuln > "${output_file}_after.txt"
    netstat -i > "${output_file}_interface.txt"
}

# ë©”ì¸ ëª¨ë‹ˆí„°ë§ ì‹¤í–‰
main() {
    local server_pid=$(pgrep logcaster)
    
    if [ -z "$server_pid" ]; then
        echo "LogCaster server not running"
        exit 1
    fi
    
    echo "Monitoring LogCaster (PID: $server_pid)"
    
    monitor_resources $server_pid 300 "resources.csv" &
    monitor_network 300 "network" &
    
    wait
    
    echo "Monitoring completed. Check resources.csv and network files."
}

main
```

---

## âœ… 6. ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸

### êµ¬í˜„ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ê¸°ë³¸ ê¸°ëŠ¥ (MVP 1)
- [ ] TCP ì†Œì¼“ ì„œë²„ êµ¬í˜„
- [ ] í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½
- [ ] ë¡œê·¸ ë©”ì‹œì§€ ìˆ˜ì‹  ë° ì¶œë ¥
- [ ] ê¸°ë³¸ ì—ëŸ¬ ì²˜ë¦¬
- [ ] Makefile/CMake ì„¤ì •

#### ê³ ê¸‰ ê¸°ëŠ¥ (MVP 2)
- [ ] ë©€í‹°ìŠ¤ë ˆë”© ì§€ì›
- [ ] ë¡œê·¸ ë©”ëª¨ë¦¬ ì €ì¥
- [ ] Thread-safe ë™ê¸°í™”
- [ ] ì—°ê²° ê´€ë¦¬ (ì—°ê²°/í•´ì œ)
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### ì „ë¬¸ ê¸°ëŠ¥ (MVP 3)
- [ ] ë¡œê·¸ ê²€ìƒ‰ ê¸°ëŠ¥
- [ ] ì¿¼ë¦¬ ì„œë²„ êµ¬í˜„
- [ ] í•„í„°ë§ ë° ì •ë ¬
- [ ] í†µê³„ ì •ë³´ ì œê³µ
- [ ] API ë¬¸ì„œí™”

### ì„±ëŠ¥ ëª©í‘œ
- [ ] 1000+ ë™ì‹œ ì—°ê²° ì§€ì›
- [ ] 10,000+ ë©”ì‹œì§€/ì´ˆ ì²˜ë¦¬
- [ ] 100MB+ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ì‚¬ìš©
- [ ] 1ms ë¯¸ë§Œ í‰ê·  ì‘ë‹µ ì‹œê°„
- [ ] 24ì‹œê°„ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸ í†µê³¼

### ì½”ë“œ í’ˆì§ˆ
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 80%+
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ìŒ (Valgrind ê²€ì¦)
- [ ] ì½”ë”© ìŠ¤íƒ€ì¼ ì¼ê´€ì„±
- [ ] API ë¬¸ì„œ ì™„ì„±
- [ ] ì˜ˆì œ ì½”ë“œ ì œê³µ

### ë°°í¬ ì¤€ë¹„
- [ ] ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
- [ ] ì„¤ì • íŒŒì¼ í…œí”Œë¦¿
- [ ] ë¡œê·¸ ë¡œí…Œì´ì…˜ ì§€ì›
- [ ] ì„œë¹„ìŠ¤ ë°ëª¬í™”
- [ ] ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

---

## ğŸ‰ ë§ˆë¬´ë¦¬

LogCaster í”„ë¡œì íŠ¸ë¥¼ í†µí•´ ë‹¤ìŒì„ ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **C/C++ ì–¸ì–´ ìˆ™ë ¨ë„ í–¥ìƒ**: ì €ìˆ˜ì¤€ ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë°ë¶€í„° ê³ ìˆ˜ì¤€ ê°ì²´ ì§€í–¥ ì„¤ê³„ê¹Œì§€
2. **ì‹œìŠ¤í…œ í”„ë¡œê·¸ë˜ë° ì´í•´**: ë„¤íŠ¸ì›Œí‚¹, ë©€í‹°ìŠ¤ë ˆë”©, ë©”ëª¨ë¦¬ ê´€ë¦¬
3. **ì„±ëŠ¥ ìµœì í™” ê²½í—˜**: í”„ë¡œíŒŒì¼ë§, ë³‘ëª©ì  ë¶„ì„, ê³ ì„±ëŠ¥ ì½”ë“œ ì‘ì„±
4. **ì†Œí”„íŠ¸ì›¨ì–´ ì—”ì§€ë‹ˆì–´ë§**: í…ŒìŠ¤íŠ¸, ë””ë²„ê¹…, ë¬¸ì„œí™”, ë°°í¬

### ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ
1. **ê¸°ë³¸ êµ¬í˜„ ì™„ì„±** â†’ GitHubì— ì½”ë“œ ê³µê°œ
2. **ê³ ê¸‰ ê¸°ëŠ¥ ì¶”ê°€** â†’ í¬íŠ¸í´ë¦¬ì˜¤ ê°•í™”
3. **ì˜¤í”ˆì†ŒìŠ¤ ê¸°ì—¬** â†’ ìœ ëª… ë¡œê¹… ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ê¸°ì—¬
4. **í™•ì¥ í”„ë¡œì íŠ¸** â†’ ë¶„ì‚° ë¡œê¹… ì‹œìŠ¤í…œ, ë¡œê·¸ ë¶„ì„ ì—”ì§„ ë“±

## ğŸš¨ ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ì™€ í•´ê²°ë²•

### 1. ë¹Œë“œ ì‹œìŠ¤í…œ ì„¤ì • ì˜¤ë¥˜
**ë¬¸ì œ**: CMakeLists.txtì—ì„œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë§í¬ ìˆœì„œ ì˜¤ë¥˜
```cmake
# âŒ ì˜ëª»ëœ ìˆœì„œ
target_link_libraries(logcaster pthread logcraft_lib)

# âœ… ì˜¬ë°”ë¥¸ ìˆœì„œ (ì˜ì¡´ì„± ìˆëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¨¼ì €)
target_link_libraries(logcaster logcraft_lib pthread)
```

### 2. ë„¤íŠ¸ì›Œí¬ í”„ë¡œê·¸ë˜ë° ì‹¤ìˆ˜
**ë¬¸ì œ**: TIME_WAIT ìƒíƒœë¡œ ì¸í•œ "Address already in use" ì˜¤ë¥˜
```c
// âŒ SO_REUSEADDR ì„¤ì • ëˆ„ë½
int server_fd = socket(AF_INET, SOCK_STREAM, 0);
bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));

// âœ… SO_REUSEADDR ì„¤ì •
int server_fd = socket(AF_INET, SOCK_STREAM, 0);
int opt = 1;
setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
```

### 3. ìŠ¤ë ˆë“œ ë™ê¸°í™” ëˆ„ë½
**ë¬¸ì œ**: ë°ì´í„° ê²½ìŸ ìƒíƒœ ë°œìƒ
```cpp
// âŒ ë™ê¸°í™” ì—†ëŠ” ì ‘ê·¼
class LogStorage {
    std::vector<LogEntry> logs_;
public:
    void addLog(const LogEntry& log) {
        logs_.push_back(log);  // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œ ì ‘ê·¼ ì‹œ ë¬¸ì œ!
    }
};

// âœ… ë®¤í…ìŠ¤ë¡œ ë³´í˜¸
class LogStorage {
    std::vector<LogEntry> logs_;
    mutable std::mutex mutex_;
public:
    void addLog(const LogEntry& log) {
        std::lock_guard<std::mutex> lock(mutex_);
        logs_.push_back(log);
    }
};
```

### 4. íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° ëˆ„ìˆ˜
**ë¬¸ì œ**: í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ì„ ë‹«ì§€ ì•ŠìŒ
```c
// âŒ ì—ëŸ¬ ì‹œ ë¦¬í„´ë§Œ í•˜ê³  ì†Œì¼“ ë‹«ì§€ ì•ŠìŒ
void handle_client(int client_fd) {
    if (recv(client_fd, buffer, size, 0) < 0) {
        return;  // ì†Œì¼“ ëˆ„ìˆ˜!
    }
}

// âœ… ëª¨ë“  ê²½ë¡œì—ì„œ ì†Œì¼“ ë‹«ê¸°
void handle_client(int client_fd) {
    if (recv(client_fd, buffer, size, 0) < 0) {
        close(client_fd);
        return;
    }
    // ... ì²˜ë¦¬ ...
    close(client_fd);
}
```

## ğŸ’¡ ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ë¯¸ë‹ˆ LogCaster (1-2ì¼)
```c
// ë‹¤ìŒ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ì„¸ìš”:
// 1. ë‹¨ì¼ ìŠ¤ë ˆë“œ TCP ì„œë²„
// 2. 10ê°œ ë¡œê·¸ ë©”ëª¨ë¦¬ ì €ì¥
// 3. ê°„ë‹¨í•œ ì¶œë ¥ ê¸°ëŠ¥

// mini_logcaster.c
typedef struct {
    char message[256];
    time_t timestamp;
} SimpleLog;

typedef struct {
    SimpleLog logs[10];
    int count;
    int server_fd;
} MiniLogCaster;

// êµ¬í˜„í•´ì•¼ í•  í•¨ìˆ˜ë“¤
MiniLogCaster* create_mini_logcaster(int port);
void run_mini_logcaster(MiniLogCaster* lc);
void destroy_mini_logcaster(MiniLogCaster* lc);
```

### í”„ë¡œì íŠ¸ 2: ë©€í‹°ìŠ¤ë ˆë“œ LogCaster (3-4ì¼)
```cpp
// C++ ë²„ì „ìœ¼ë¡œ ë‹¤ìŒ êµ¬í˜„:
// 1. Thread pool íŒ¨í„´
// 2. Lock-free í
// 3. ë¹„ë™ê¸° ë¡œê¹…

class AsyncLogCaster {
    // êµ¬í˜„ ìš”êµ¬ì‚¬í•­:
    // - Worker thread pool
    // - Concurrent queue for logs
    // - Async file writer
    // - Performance metrics
};
```

### í”„ë¡œì íŠ¸ 3: ê³ ì„±ëŠ¥ LogCaster (1ì£¼)
```cpp
// ìµœì¢… ë²„ì „ êµ¬í˜„:
// 1. epoll/kqueue ì‚¬ìš©
// 2. Zero-copy ê¸°ë²•
// 3. Memory pool
// 4. ë¶„ì‚° ë¡œê¹… ì§€ì›

class DistributedLogCaster {
    // ìš”êµ¬ì‚¬í•­:
    // - 100k+ connections
    // - 1M+ logs/sec
    // - Clustering support
};
```

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì±… ì¶”ì²œ
- "Unix Network Programming" - W. Richard Stevens
- "The Linux Programming Interface" - Michael Kerrisk
- "C++ Concurrency in Action" - Anthony Williams

### ì˜¨ë¼ì¸ ìë£Œ
- [Beej's Guide to Network Programming](https://beej.us/guide/bgnet/)
- [Linux System Programming](https://man7.org/tlpi/)
- [Modern CMake Tutorial](https://cliutils.gitlab.io/modern-cmake/)

### ë„êµ¬ ë¬¸ì„œ
- [GDB Documentation](https://www.gnu.org/software/gdb/documentation/)
- [Valgrind User Manual](https://valgrind.org/docs/manual/)
- [Perf Tutorial](https://perf.wiki.kernel.org/index.php/Tutorial)

## âœ… í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í™˜ê²½ ì„¤ì • (1ì¼)
- [ ] ê°œë°œ ë„êµ¬ ì„¤ì¹˜ ì™„ë£Œ
- [ ] IDE/ì—ë””í„° ì„¤ì •
- [ ] ë¹Œë“œ ì‹œìŠ¤í…œ ì´í•´
- [ ] Git ì €ì¥ì†Œ ìƒì„±

### ê¸°ë³¸ êµ¬í˜„ (1ì£¼)
- [ ] TCP ì„œë²„ êµ¬í˜„
- [ ] í´ë¼ì´ì–¸íŠ¸ ì²˜ë¦¬
- [ ] ë¡œê·¸ ì €ì¥ êµ¬ì¡°
- [ ] ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì‘ì„±

### ê³ ê¸‰ ê¸°ëŠ¥ (2ì£¼)
- [ ] ë©€í‹°ìŠ¤ë ˆë”© ì ìš©
- [ ] ë™ê¸°í™” êµ¬í˜„
- [ ] ì„±ëŠ¥ ìµœì í™”
- [ ] ì¿¼ë¦¬ ê¸°ëŠ¥ ì¶”ê°€

### í”„ë¡œë•ì…˜ ì¤€ë¹„ (1ì£¼)
- [ ] í†µí•© í…ŒìŠ¤íŠ¸
- [ ] ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
- [ ] ë¬¸ì„œí™” ì™„ì„±
- [ ] ë°°í¬ ìŠ¤í¬ë¦½íŠ¸

## ğŸ”„ ë‹¤ìŒ í•™ìŠµ ë‹¨ê³„

ì´ ë¬¸ì„œë¥¼ ì™„ë£Œí–ˆë‹¤ë©´ ë‹¤ìŒìœ¼ë¡œ ì§„í–‰í•˜ì„¸ìš”:

1. **ì‹¤ì œ í”„ë¡œì íŠ¸ êµ¬í˜„** - LogCaster ì½”ë”© ì‹œì‘
   - GitHub ì €ì¥ì†Œ ìƒì„±
   - ë‹¨ê³„ë³„ ì»¤ë°‹
   - CI/CD ì„¤ì •

2. **í¬íŠ¸í´ë¦¬ì˜¤ ì‘ì„±** - í”„ë¡œì íŠ¸ ë¬¸ì„œí™”
   - README ì‘ì„±
   - ê¸°ìˆ  ë¸”ë¡œê·¸ í¬ìŠ¤íŒ…
   - ì„±ëŠ¥ ë¶„ì„ ë¦¬í¬íŠ¸

3. **ì˜¤í”ˆì†ŒìŠ¤ ê¸°ì—¬** - ì‹¤ë ¥ í–¥ìƒ
   - ìœ ëª… C/C++ í”„ë¡œì íŠ¸ ë¶„ì„
   - ì´ìŠˆ í•´ê²°
   - Pull Request ì œì¶œ

---

*ğŸ¯ ì„±ê³µì ì¸ LogCaster êµ¬í˜„ì„ ìœ„í•´ ë‹¨ê³„ë³„ë¡œ ì²œì²œíˆ ì§„í–‰í•˜ì„¸ìš”. ê° ë‹¨ê³„ì—ì„œ ì¶©ë¶„íˆ í…ŒìŠ¤íŠ¸í•˜ê³  ê²€ì¦í•œ í›„ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°€ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤!*