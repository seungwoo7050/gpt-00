# C/C++ 프로젝트: PhysiSim - 2D 물리 엔진 및 시뮬레이터

**프로젝트**: `PhysiSim`
**목표**: C의 데이터 지향 설계(DOD)와 C++의 객체 지향 설계(OOP)를 비교하며 2D 물리 엔진을 구현합니다.
**수준**: 42 C/C++ 과정 이수자 (2-4년차 수준)

---

## 💡 프로젝트 개요

PhysiSim은 2D 공간에서 물리 법칙에 따라 움직이는 객체들을 시뮬레이션하는 물리 엔진을 개발하는 프로젝트입니다. 이 프로젝트는 두 가지 버전으로 구현됩니다.

1.  **`PhysiSim-C`**: C언어와 데이터 지향 설계(Data-Oriented Design)를 통해 캐시 효율성을 극대화하여 고성능 연산에 초점을 맞춥니다.
2.  **`PhysiSim-CPP`**: C++의 객체 지향 프로그래밍(OOP) 특성을 활용하여 직관적이고 유연하며 확장 가능한 구조를 만드는 데 중점을 둡니다.

두 버전을 모두 구현함으로써, 개발자는 동일한 문제를 다른 설계 패러다임으로 해결하며 성능과 코드 구조화 방식의 근본적인 차이와 트레이드오프를 학습할 수 있습니다.

---

## 🚀 `PhysiSim-C`: 데이터 지향 설계 (DOD)

### Prerequisites

*   **Language**: C11
*   **Compiler**: `gcc` or `clang`
*   **Build Tool**: `make`
*   **Graphics Library**: `SDL2` 또는 `Raylib` (2D 렌더링 및 입력 처리용)

### MVP 1: 기본 렌더링 및 게임 루프

*   **[구현]** 그래픽 라이브러리(e.g., SDL2)를 사용하여 윈도우를 생성하고, 닫기 전까지 유지되는 게임 루프를 구현합니다.
*   **[구현]** 화면에 원, 사각형과 같은 기본 도형을 그리는 함수를 작성합니다.
*   **[구현]** FPS(Frames Per Second)를 계산하고 화면에 표시하는 기능을 구현합니다.

### MVP 2: 데이터 중심의 물리 객체

*   **[구현]** 물리 객체의 데이터를 속성별로 분리된 배열(Structure of Arrays, SoA)로 관리합니다. (e.g., `Vector2 positions[MAX_OBJECTS]`, `Vector2 velocities[MAX_OBJECTS]`).
*   **[구현]** 중력과 같은 외부 힘을 모든 객체에 일괄적으로 적용하는 `PhysicsSystem` 함수를 작성합니다.
*   **[구현]** 각 객체의 위치를 속도와 시간에 따라 업데이트하는 로직을 구현합니다. 이 때, 반복문을 통해 각 데이터 배열을 순차적으로 순회하며 처리합니다.

### MVP 3: 충돌 감지 및 반응 시스템

*   **[구현]** 모든 객체 쌍에 대해 충돌을 검사하는 시스템을 구현합니다. (e.g., AABB vs AABB, Circle vs Circle).
*   **[구현]** 충돌이 감지되면, 물리 법칙에 따라 객체의 속도를 변경하여 튕겨나가는 효과를 구현합니다. (탄성 충돌 모델 적용).
*   **[구현]** 간단한 공간 분할 기법(e.g., 그리드)을 적용하여 불필요한 충돌 검사를 줄이는 최적화를 시도합니다.

---

## 🚀 `PhysiSim-CPP`: 객체 지향 설계 (OOP)

### Prerequisites

*   **Language**: C++17 or higher
*   **Compiler**: `g++` or `clang++`
*   **Build Tool**: `CMake`
*   **Graphics Library**: `SFML` 또는 `SDL2`

### MVP 1: 객체 지향 렌더링 시스템

*   **[구현]** 그래픽 라이브러리(e.g., SFML)를 사용하여 `Window` 클래스를 만들고, 게임 루프를 관리하는 `Game` 클래스를 설계합니다.
*   **[구현]** `GameObject` 추상 기반 클래스를 정의하고, 이를 상속받는 `CircleShape`, `RectangleShape` 클래스를 구현합니다. 각 객체는 스스로를 그리는 `draw()` 메소드를 가집니다.

### MVP 2: 컴포넌트 기반 물리 시스템

*   **[구현]** `GameObject`에 붙일 수 있는 `Component` 기반 클래스를 설계합니다.
*   **[구현]** 물리적 속성(위치, 속도, 질량 등)을 관리하는 `TransformComponent`와 `RigidbodyComponent`를 구현합니다.
*   **[구현]** 각 `GameObject`는 `update(deltaTime)` 메소드를 가지며, 이 메소드 내에서 자신의 컴포넌트들을 업데이트합니다.

### MVP 3: 다형성을 이용한 충돌 처리

*   **[구현]** 충돌체를 표현하는 `ColliderComponent` 추상 클래스를 만들고, `CircleCollider`, `BoxCollider` 등을 파생 클래스로 구현합니다.
*   **[구현]** 가상 함수(`virtual void onCollision(GameObject& other)`)를 이용하여 충돌 이벤트를 처리하는 시스템을 설계합니다.
*   **[구현]** 더블 디스패치(Double Dispatch) 패턴 등을 활용하여 서로 다른 타입의 충돌체 간의 충돌을 정확하게 처리하는 로직을 구현합니다.

---

## ⚖️ 비교 학습 포인트

1.  **설계 패러다임**: 데이터 지향 설계(DOD)와 객체 지향 설계(OOP)가 코드 구조, 유연성, 확장성에 각각 어떤 영향을 미치는가?
2.  **메모리 레이아웃**: C 버전의 SoA(Structure of Arrays) 방식과 C++ 버전의 AoS(Array of Structures) 방식이 CPU 캐시 효율성과 성능에 어떤 차이를 만드는가?
3.  **성능 vs 추상화**: C 버전의 성능 최적화 과정과 C++ 버전의 높은 코드 추상화 및 가독성 사이의 트레이드오프는 무엇인가?
4.  **코드의 진화**: 새로운 기능(e.g., 새로운 종류의 물리 객체)을 추가할 때, 두 설계 방식에서 코드 변경의 범위와 복잡도는 어떻게 다른가?

이 프로젝트를 통해 게임 개발의 핵심인 실시간 시뮬레이션 루프를 깊이 있게 이해하고, 성능과 코드 설계 사이의 균형점을 찾는 능력을 기를 수 있습니다.
